# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2025-11-10T09:40:33+00:00

from __future__ import annotations

from typing import List, Optional, Union


from .unpackers import PydanticUnpacker
from pydantic import BaseModel, Field, conint, constr


class AddRequest(BaseModel):
    a: float = Field(..., description="First addend.", title="A")
    b: float = Field(..., description="Second addend.", title="B")


class AddResponse(BaseModel):
    result: float = Field(..., description="Sum of 'a' and 'b'.", title="Result")


class HealthResponse(BaseModel):
    status: str = Field(
        ..., description="Overall service status, typically 'ok'.", title="Status"
    )
    uptime_seconds: float = Field(
        ...,
        description="Approximate process uptime in seconds.",
        title="Uptime Seconds",
    )


class ReverseResponse(BaseModel):
    reversed: str = Field(..., description="Reversed text.", title="Reversed")


class TextRequest(BaseModel):
    text: constr(min_length=0) = Field(..., description="Input text.", title="Text")


class TimeNowResponse(BaseModel):
    iso8601: str = Field(
        ..., description="Current UTC time in ISO 8601 format.", title="Iso8601"
    )
    epoch_seconds: float = Field(
        ..., description="Current time as Unix epoch seconds.", title="Epoch Seconds"
    )


class UUIDsResponse(BaseModel):
    uuids: List[str] = Field(
        ..., description="List of generated UUID v4 strings.", title="Uuids"
    )


class ValidationError(BaseModel):
    loc: List[Union[str, int]] = Field(..., title="Location")
    msg: str = Field(..., title="Message")
    type: str = Field(..., title="Error Type")


class WordCountResponse(BaseModel):
    words: conint(ge=0) = Field(
        ..., description="Number of whitespace-delimited words.", title="Words"
    )
    characters: conint(ge=0) = Field(
        ..., description="Number of characters.", title="Characters"
    )
    lines: conint(ge=0) = Field(..., description="Number of lines.", title="Lines")


class HTTPValidationError(BaseModel):
    detail: Optional[List[ValidationError]] = Field(None, title="Detail")


# ---- Auto-generated client below ----
from typing import Optional, Union, Annotated, Literal, Mapping, Any
from pydantic import BaseModel, Field
from urllib.parse import quote
import httpx

import funcnodes as fn


class UnexpectedStatusError(RuntimeError):
    def __init__(self, method: str, url: str, status_code: int, body: str):
        super().__init__(f"Unexpected {method} {url} -> {status_code}: {body[:200]}")


def _model_dump(obj: Any) -> Any:
    # Pydantic v2 / v1 compatibility
    if hasattr(obj, "model_dump"):
        return obj.model_dump(mode="json", by_alias=True)
    if hasattr(obj, "dict"):
        return obj.dict(by_alias=True)
    return obj


def _model_validate(Model: Any, data: Any) -> Any:
    # Pydantic v2 / v1 compatibility
    if hasattr(Model, "model_validate"):
        return Model.model_validate(data)
    if hasattr(Model, "parse_obj"):
        return Model.parse_obj(data)
    return Model(**data)


@fn.NodeDecorator("health_health_get")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def health_health_get(
    *,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> HealthResponse:
    """Health"""
    method = "GET"
    url = base_url.rstrip("/") + "/health"
    params = None
    json_body = None
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(HealthResponse, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


AddMathAddPostResponse = Union[AddResponse, HTTPValidationError]


@fn.NodeDecorator("add_math_add_post")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def add_math_add_post(
    request: AddRequest,
    *,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> AddMathAddPostResponse:
    """Add"""
    method = "POST"
    url = base_url.rstrip("/") + "/math/add"
    params = None
    json_body = _model_dump(request)
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params, json=json_body)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(AddResponse, resp.json())
    if resp.status_code == 422:
        return _model_validate(HTTPValidationError, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


ReverseTextTextReversePostResponse = Union[ReverseResponse, HTTPValidationError]


@fn.NodeDecorator("reverse_text_text_reverse_post")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def reverse_text_text_reverse_post(
    request: TextRequest,
    *,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> ReverseTextTextReversePostResponse:
    """Reverse Text"""
    method = "POST"
    url = base_url.rstrip("/") + "/text/reverse"
    params = None
    json_body = _model_dump(request)
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params, json=json_body)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(ReverseResponse, resp.json())
    if resp.status_code == 422:
        return _model_validate(HTTPValidationError, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


WordcountTextWordcountPostResponse = Union[WordCountResponse, HTTPValidationError]


@fn.NodeDecorator("wordcount_text_wordcount_post")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def wordcount_text_wordcount_post(
    request: TextRequest,
    *,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> WordcountTextWordcountPostResponse:
    """Wordcount"""
    method = "POST"
    url = base_url.rstrip("/") + "/text/wordcount"
    params = None
    json_body = _model_dump(request)
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params, json=json_body)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(WordCountResponse, resp.json())
    if resp.status_code == 422:
        return _model_validate(HTTPValidationError, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


MakeUuidsUtilsUuidGetResponse = Union[UUIDsResponse, HTTPValidationError]


@fn.NodeDecorator("make_uuids_utils_uuid_get")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def make_uuids_utils_uuid_get(
    *,
    count: Optional[int] = 1,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> MakeUuidsUtilsUuidGetResponse:
    """Make Uuids"""
    method = "GET"
    url = base_url.rstrip("/") + "/utils/uuid"
    params: dict[str, Any] = {}
    if count is not None:
        params["count"] = count
    json_body = None
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(UUIDsResponse, resp.json())
    if resp.status_code == 422:
        return _model_validate(HTTPValidationError, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


@fn.NodeDecorator("time_now_time_now_get")
@PydanticUnpacker(input_levels=-1, output_levels=-1)
def time_now_time_now_get(
    *,
    client: Optional[httpx.Client] = None,
    base_url: str = "http://localhost:8000",
    timeout: Optional[float] = None,
) -> TimeNowResponse:
    """Time Now"""
    method = "GET"
    url = base_url.rstrip("/") + "/time/now"
    params = None
    json_body = None
    _own = client is None
    _client = client or httpx.Client(timeout=timeout)
    try:
        resp = _client.request(method, url, params=params)
    finally:
        if _own:
            _client.close()
    if resp.status_code == 200:
        return _model_validate(TimeNowResponse, resp.json())
    raise UnexpectedStatusError(method, url, resp.status_code, resp.text)


NODE_SHELF = fn.Shelf(
    name="Funcnodes Pydantic Demo",
    description="Demo nodes for Funcnodes Pydantic",
    nodes=[
        health_health_get,
        add_math_add_post,
        reverse_text_text_reverse_post,
        wordcount_text_wordcount_post,
        make_uuids_utils_uuid_get,
        time_now_time_now_get,
    ],
    subshelves=[],
)
