# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from cobo_waas2.models.order_status import OrderStatus
from cobo_waas2.models.payment_transaction import PaymentTransaction
from cobo_waas2.models.settle_status import SettleStatus
from typing import Optional, Set
from typing_extensions import Self


class PaymentOrderEventData(BaseModel):
    """
    PaymentOrderEventData
    """  # noqa: E501
    data_type: StrictStr = Field(description=" The data type of the event. - `Transaction`: The transaction event data. - `TSSRequest`: The TSS request event data. - `Addresses`: The addresses event data. - `WalletInfo`: The wallet information event data. - `MPCVault`: The MPC vault event data. - `Chains`: The enabled chain event data. - `Tokens`: The enabled token event data. - `TokenListing`: The token listing event data.        - `PaymentOrder`: The payment order event data. - `PaymentRefund`: The payment refund event data. - `PaymentSettlement`: The payment settlement event data. - `PaymentTransaction`: The payment transaction event data. - `PaymentAddressUpdate`: The top-up address update event data. - `BalanceUpdateInfo`: The balance update event data. - `SuspendedToken`: The token suspension event data. - `ComplianceDisposition`: The compliance disposition event data. - `ComplianceKytScreenings`: The compliance KYT screenings event data.")
    order_id: StrictStr = Field(description="The order ID.")
    merchant_id: Optional[StrictStr] = Field(default=None, description="The merchant ID.")
    token_id: StrictStr = Field(description=" The ID of the cryptocurrency used for payment. Supported tokens:  - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC` - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")
    chain_id: StrictStr = Field(description=" The ID of the blockchain network where the payment transaction should be made. Supported chains:  - USDC: `ETH`, `ARBITRUM`, `SOL`, `BASE`, `MATIC`, `BSC` - USDT: `TRON`, `ETH`, `ARBITRUM`, `SOL`, `BASE`, `MATIC`, `BSC` ")
    payable_amount: StrictStr = Field(description="The cryptocurrency amount to be paid for this order.")
    receive_address: StrictStr = Field(description="The recipient wallet address to be used for the payment transaction.")
    currency: StrictStr = Field(description="The fiat currency of the order.")
    order_amount: StrictStr = Field(description="The base amount of the order in fiat currency, excluding the developer fee (specified in `fee_amount`).")
    fee_amount: StrictStr = Field(description="The developer fee for the order in fiat currency. It is added to the base amount (`order_amount`) to determine the final charge.")
    exchange_rate: StrictStr = Field(description="The exchange rate between a currency pair. Expressed as the amount of fiat currency per one unit of cryptocurrency. For example, if the cryptocurrency is USDT and the fiat currency is USD, a rate of \"0.99\" means 1 USDT = 0.99 USD.")
    expired_at: Optional[StrictInt] = Field(default=None, description="The expiration time of the pay-in order, represented as a UNIX timestamp in seconds.")
    merchant_order_code: Optional[StrictStr] = Field(default=None, description="A unique reference code assigned by the merchant to identify this order in their system.")
    psp_order_code: StrictStr = Field(description="A unique reference code assigned by the developer to identify this order in their system.")
    status: OrderStatus
    received_token_amount: StrictStr = Field(description="The total cryptocurrency amount received for this order. Updates until the expiration time. Precision matches the token standard (e.g., 6 decimals for USDT).")
    created_timestamp: Optional[StrictInt] = Field(default=None, description="The creation time of the order, represented as a UNIX timestamp in seconds.")
    updated_timestamp: Optional[StrictInt] = Field(default=None, description="The last update time of the order, represented as a UNIX timestamp in seconds.")
    transactions: Optional[List[PaymentTransaction]] = Field(default=None, description="An array of transactions associated with this pay-in order. Each transaction represents a separate blockchain operation related to the pay-in process.")
    settlement_status: Optional[SettleStatus] = None
    amount_tolerance: Optional[StrictStr] = Field(default=None, description="The maximum allowed deviation from the payable amount in the case of underpayment, specified as a positive value with up to one decimal place. If you provide more than one decimal place, an error will occur.  When the actual received amount is within this deviation (inclusive) of the payable amount, the order status will be set to `Completed` rather than `Underpaid`. ")
    __properties: ClassVar[List[str]] = ["data_type", "order_id", "merchant_id", "token_id", "chain_id", "payable_amount", "receive_address", "currency", "order_amount", "fee_amount", "exchange_rate", "expired_at", "merchant_order_code", "psp_order_code", "status", "received_token_amount", "created_timestamp", "updated_timestamp", "transactions", "settlement_status", "amount_tolerance"]

    @field_validator('data_type')
    def data_type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['Transaction', 'TSSRequest', 'Addresses', 'WalletInfo', 'MPCVault', 'Chains', 'Tokens', 'TokenListing', 'PaymentOrder', 'PaymentRefund', 'PaymentSettlement', 'PaymentTransaction', 'PaymentAddressUpdate', 'BalanceUpdateInfo', 'SuspendedToken', 'ComplianceDisposition', 'ComplianceKytScreenings']):
            raise ValueError("must be one of enum values ('Transaction', 'TSSRequest', 'Addresses', 'WalletInfo', 'MPCVault', 'Chains', 'Tokens', 'TokenListing', 'PaymentOrder', 'PaymentRefund', 'PaymentSettlement', 'PaymentTransaction', 'PaymentAddressUpdate', 'BalanceUpdateInfo', 'SuspendedToken', 'ComplianceDisposition', 'ComplianceKytScreenings')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PaymentOrderEventData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in transactions (list)
        _items = []
        if self.transactions:
            for _item in self.transactions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['transactions'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PaymentOrderEventData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "data_type": obj.get("data_type"),
            "order_id": obj.get("order_id"),
            "merchant_id": obj.get("merchant_id"),
            "token_id": obj.get("token_id"),
            "chain_id": obj.get("chain_id"),
            "payable_amount": obj.get("payable_amount"),
            "receive_address": obj.get("receive_address"),
            "currency": obj.get("currency"),
            "order_amount": obj.get("order_amount"),
            "fee_amount": obj.get("fee_amount"),
            "exchange_rate": obj.get("exchange_rate"),
            "expired_at": obj.get("expired_at"),
            "merchant_order_code": obj.get("merchant_order_code"),
            "psp_order_code": obj.get("psp_order_code"),
            "status": obj.get("status"),
            "received_token_amount": obj.get("received_token_amount"),
            "created_timestamp": obj.get("created_timestamp"),
            "updated_timestamp": obj.get("updated_timestamp"),
            "transactions": [PaymentTransaction.from_dict(_item) for _item in obj["transactions"]] if obj.get("transactions") is not None else None,
            "settlement_status": obj.get("settlement_status"),
            "amount_tolerance": obj.get("amount_tolerance")
        })
        return _obj


