# coding: utf-8

"""
    Cobo Wallet as a Service 2.0

    Contact: help@cobo.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from cobo_waas2.models.order_link_business_info_custom_exchange_rates_inner import OrderLinkBusinessInfoCustomExchangeRatesInner
from typing import Optional, Set
from typing_extensions import Self


class OrderLinkBusinessInfo(BaseModel):
    """
    OrderLinkBusinessInfo
    """  # noqa: E501
    token_ids: List[StrictStr] = Field(description="An array of token IDs representing the cryptocurrencies and chains available for payment. These options will be shown to users on the payment page for them to choose from. Supported token IDs include:   - USDC: `ETH_USDC`, `ARBITRUM_USDCOIN`, `SOL_USDC`, `BASE_USDC`, `MATIC_USDC2`, `BSC_USDC`   - USDT: `TRON_USDT`, `ETH_USDT`, `ARBITRUM_USDT`, `SOL_USDT`, `BASE_USDT`, `MATIC_USDT`, `BSC_USDT` ")
    custom_exchange_rates: Optional[List[OrderLinkBusinessInfoCustomExchangeRatesInner]] = Field(default=None, description="A list of custom exchange rates defining how much one unit of a specific cryptocurrency (`token_id`) is valued in the selected fiat or crypto currency (`currency`). If this field is omitted, the systemâ€™s default exchange rates will apply.  Each item specifies a `token_id` and its corresponding `exchange_rate`. For example, to treat 1 USDT (on Ethereum) as equivalent to 0.99 USD, provide:  ```json {   \"custom_exchange_rates\": [     {       \"token_id\": \"ETH_USDT\",       \"exchange_rate\": \"0.99\"     }   ],   \"currency\": \"USD\" } ``` ")
    currency: StrictStr = Field(description="The currency in which both the order amount (`order_amount`) and the developer fee (`fee_amount`) are denominated. Only the following values are supported: `USD`, `USDT`, or `USDC`. ")
    fee_amount: StrictStr = Field(description="The developer fee for the order, denominated in the currency specified by `currency`.   If you are a merchant directly serving payers, set this field to `0`. Developer fees are only relevant for platforms like payment service providers (PSPs) that charge fees to their downstream merchants.  The developer fee is added to the base amount (`order_amount`) to determine the final charge. For example: - Base amount (`order_amount`): \"100.00\" - Developer fee (`fee_amount`): \"2.00\"  - Total charged to customer: \"102.00\"  Values can contain up to two decimal places. ")
    merchant_id: StrictStr = Field(description="The merchant ID.")
    order_amount: StrictStr = Field(description="The base amount of the order, excluding the developer fee (specified in `fee_amount`), denominated in the currency specified by `currency`.  Values must be greater than `0` and contain two decimal places.  ")
    merchant_order_code: Optional[StrictStr] = Field(default=None, description="A unique reference code assigned by the merchant to identify this order in their system. The code should have a maximum length of 128 characters.")
    psp_order_code: StrictStr = Field(description="A unique reference code assigned by you as a developer to identify this order in your system. This code must be unique across all orders in your system. The code should have a maximum length of 128 characters. ")
    expired_in: Optional[StrictInt] = Field(default=1800, description="The number of seconds until the pay-in order expires, counted from when the request is sent. For example, if set to `1800`, the order will expire in 30 minutes. Must be greater than zero and cannot exceed 3 hours (10800 seconds). After expiration:  - The order status becomes final and cannot be changed - The `received_token_amount` field will no longer be updated - Funds received after expiration will be categorized as late payments and can only be settled from the developer balance. - A late payment will trigger a `transactionLate` webhook event. ")
    use_dedicated_address: Optional[StrictBool] = Field(default=None, description="This field has been deprecated. ")
    amount_tolerance: Optional[StrictStr] = Field(default=None, description="The maximum allowed deviation from the payable amount in the case of underpayment, specified as a positive value with up to one decimal place. If you provide more than one decimal place, an error will occur.  When the actual received amount is within this deviation (inclusive) of the payable amount, the order status will be set to `Completed` rather than `Underpaid`. ")
    __properties: ClassVar[List[str]] = ["token_ids", "custom_exchange_rates", "currency", "fee_amount", "merchant_id", "order_amount", "merchant_order_code", "psp_order_code", "expired_in", "use_dedicated_address", "amount_tolerance"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderLinkBusinessInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in custom_exchange_rates (list)
        _items = []
        if self.custom_exchange_rates:
            for _item in self.custom_exchange_rates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['custom_exchange_rates'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderLinkBusinessInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "token_ids": obj.get("token_ids"),
            "custom_exchange_rates": [OrderLinkBusinessInfoCustomExchangeRatesInner.from_dict(_item) for _item in obj["custom_exchange_rates"]] if obj.get("custom_exchange_rates") is not None else None,
            "currency": obj.get("currency"),
            "fee_amount": obj.get("fee_amount"),
            "merchant_id": obj.get("merchant_id"),
            "order_amount": obj.get("order_amount"),
            "merchant_order_code": obj.get("merchant_order_code"),
            "psp_order_code": obj.get("psp_order_code"),
            "expired_in": obj.get("expired_in") if obj.get("expired_in") is not None else 1800,
            "use_dedicated_address": obj.get("use_dedicated_address"),
            "amount_tolerance": obj.get("amount_tolerance")
        })
        return _obj


