"""Typed protocol for the asyncio Redis client used in MAS.

This narrows the subset of methods we rely on with precise async
signatures, avoiding the need for "Any" while remaining compatible
with redis.asyncio.client.Redis via structural typing.
"""

from __future__ import annotations

from typing import (
    Any,
    AsyncIterator,
    Awaitable,
    MutableMapping,
    Protocol,
    overload,
    Literal,
)


class PubSubProtocol(Protocol):
    async def subscribe(self, *channels: str) -> None: ...
    async def unsubscribe(self, *channels: str) -> None: ...
    async def aclose(self) -> None: ...
    def listen(self) -> AsyncIterator[MutableMapping[str, Any]]: ...


class AsyncRedisProtocol(Protocol):
    # Connection
    def aclose(self) -> Awaitable[None]: ...

    # Keys
    def exists(self, key: str) -> Awaitable[int]: ...
    def delete(self, *keys: str) -> Awaitable[int]: ...
    def expire(self, key: str, seconds: int) -> Awaitable[int]: ...
    def ttl(self, key: str) -> Awaitable[int]: ...
    def scan(
        self, cursor: int, *, match: str, count: int
    ) -> Awaitable[tuple[int, list[str]]]: ...
    def scan_iter(self, *, match: str) -> AsyncIterator[str]: ...

    # Strings
    def get(self, key: str) -> Awaitable[str | None]: ...
    def set(self, key: str, value: str) -> Awaitable[bool | str]: ...
    def setex(self, key: str, seconds: int, value: str) -> Awaitable[bool | str]: ...
    def publish(self, channel: str, message: str) -> Awaitable[int]: ...
    def pubsub(self) -> PubSubProtocol: ...

    # Hashes
    def hget(self, key: str, field: str) -> Awaitable[str | None]: ...
    def hset(self, key: str, *, mapping: dict[str, str]) -> Awaitable[int]: ...
    def hgetall(self, key: str) -> Awaitable[dict[str, str]]: ...
    def hdel(self, key: str, *fields: str) -> Awaitable[int]: ...

    # Sets
    def sadd(self, key: str, *members: str) -> Awaitable[int]: ...
    def srem(self, key: str, *members: str) -> Awaitable[int]: ...
    def smembers(self, key: str) -> Awaitable[set[str]]: ...
    def sismember(self, key: str, member: str) -> Awaitable[bool]: ...

    # Sorted sets
    def zadd(self, key: str, mapping: dict[str, float]) -> Awaitable[int]: ...
    def zcard(self, key: str) -> Awaitable[int]: ...
    def zrem(self, key: str, *members: str) -> Awaitable[int]: ...
    def zremrangebyscore(
        self, key: str, min: float | str, max: float | str
    ) -> Awaitable[int]: ...
    def zcount(
        self, key: str, min: float | str, max: float | str
    ) -> Awaitable[int]: ...
    def zscore(self, key: str, member: str) -> Awaitable[float | None]: ...

    @overload
    def zrange(
        self, key: str, start: int, end: int, *, withscores: Literal[True]
    ) -> Awaitable[list[tuple[str, float]]]: ...

    @overload
    def zrange(
        self, key: str, start: int, end: int, *, withscores: Literal[False] = ...
    ) -> Awaitable[list[str]]: ...

    # Streams
    def xadd(self, name: str, fields: dict[str, str]) -> Awaitable[str]: ...
    def xrange(
        self, name: str, min: str, max: str, count: int | None = ...
    ) -> Awaitable[list[tuple[str, dict[str, str]]]]: ...
    def xlen(self, name: str) -> Awaitable[int]: ...
    def xgroup_create(
        self, name: str, groupname: str, id: str = "$", mkstream: bool = ...
    ) -> Awaitable[str]: ...
    def xreadgroup(
        self,
        groupname: str,
        consumername: str,
        *,
        streams: dict[str, str],
        count: int | None = ...,
        block: int | None = ...,
    ) -> Awaitable[list[tuple[str, list[tuple[str, dict[str, str]]]]] | None]: ...
    def xack(self, name: str, groupname: str, *ids: str) -> Awaitable[int]: ...
