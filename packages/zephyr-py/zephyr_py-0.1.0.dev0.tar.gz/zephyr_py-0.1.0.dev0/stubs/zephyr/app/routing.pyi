from _typeshed import Incomplete
from collections.abc import Awaitable, Callable as Callable, Coroutine, Sequence
from enum import Enum
from pydantic_core.core_schema import ModelField as ModelField
from typing import Annotated, Any, Pattern
from zephyr import BaseZephyrException as BaseZephyrException
from zephyr._types import ASGIApp as ASGIApp, AppType as AppType, DecoratedCallable as DecoratedCallable, IncEx as IncEx, Receive as Receive, Scope as Scope, Send as Send
from zephyr.app import params as params
from zephyr.app._compat import Undefined as Undefined
from zephyr.app._exception_handler import wrap_app_handling_exceptions as wrap_app_handling_exceptions
from zephyr.app._utils import create_model_field as create_model_field, generate_unique_id as generate_unique_id, get_name as get_name, get_route_path as get_route_path, get_typed_return_annotation as get_typed_return_annotation, get_value_or_default as get_value_or_default, is_async_callable as is_async_callable, is_body_allowed_for_status_code as is_body_allowed_for_status_code
from zephyr.app.concurrency import run_in_threadpool as run_in_threadpool
from zephyr.app.convertors import CONVERTOR_TYPES as CONVERTOR_TYPES, Convertor as Convertor
from zephyr.app.datastructures import Default as Default, DefaultPlaceholder as DefaultPlaceholder, URLPath as URLPath
from zephyr.app.dependencies.models import Dependant as Dependant
from zephyr.app.dependencies.utils import get_body_field as get_body_field, get_dependant as get_dependant, get_flat_dependant as get_flat_dependant, get_parameterless_sub_dependant as get_parameterless_sub_dependant, solve_dependencies as solve_dependencies
from zephyr.app.encoders import jsonable_encoder as jsonable_encoder
from zephyr.app.exceptions import HTTPException as HTTPException, NoMatchFound as NoMatchFound, RequestValidationError as RequestValidationError, ResponseValidationError as ResponseValidationError
from zephyr.app.middleware import Middleware as Middleware
from zephyr.app.requests import Request as Request
from zephyr.app.responses import JSONResponse as JSONResponse, PlainTextResponse as PlainTextResponse, Response as Response
from zephyr.core.zserver.lifespan import Lifespan as Lifespan

class Match(Enum):
    NONE = 0
    PARTIAL = 1
    FULL = 2

def replace_params(path: str, param_convertors: dict[str, Convertor[Any]], path_params: dict[str, str]) -> tuple[str, dict[str, str]]: ...
async def serialize_response(*, field: ModelField | None = None, response_content: Any, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = True, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, is_coroutine: bool = True) -> Any: ...
async def run_endpoint_function(*, dependant: Dependant, values: dict[str, Any], is_coroutine: bool) -> Any: ...
def get_request_handler(dependant: Dependant, body_field: ModelField | None = None, status_code: int | None = None, response_class: type[Response] | DefaultPlaceholder = ..., response_field: ModelField | None = None, response_model_include: IncEx | None = None, response_model_exclude: IncEx | None = None, response_model_by_alias: bool = True, response_model_exclude_unset: bool = False, response_model_exclude_defaults: bool = False, response_model_exclude_none: bool = False, dependency_overrides_provider: Any | None = None, embed_body_fields: bool = False) -> Callable[[Request], Coroutine[Any, Any, Response]]: ...
def request_response(func: Callable[[Request], Awaitable[Response] | Response]) -> ASGIApp: ...

class _DefaultLifespan:
    def __init__(self, router: Router) -> None: ...
    async def __aenter__(self) -> None: ...
    async def __aexit__(self, *exc_info: object) -> None: ...
    def __call__(self, app: object) -> _T: ...

PARAM_REGEX: Incomplete

def compile_path(path: str) -> tuple[Pattern[str], str, dict[str, Convertor[Any]]]: ...

class BaseRoute:
    def matches(self, scope: Scope) -> tuple[Match, Scope]: ...
    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath: ...
    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...

class Route(BaseRoute):
    path: Incomplete
    endpoint: Incomplete
    response_model: Incomplete
    response_class: Incomplete
    responses: Incomplete
    operation_id: Incomplete
    generate_unique_id_fn: Incomplete
    name: Incomplete
    methods: set[str]
    unique_id: Incomplete
    status_code: Incomplete
    response_field: Incomplete
    secure_cloned_response_field: Incomplete
    response_fields: dict[int | str, ModelField]
    dependencies: Incomplete
    dependant: Incomplete
    body_field: Incomplete
    app: Incomplete
    def __init__(self, path: str, endpoint: Callable[[Request], Awaitable[Response] | Response], *, response_model: Any = ..., status_code: int | None = None, methods: list[str] | set[str] | None = None, operation_id: str | None = None, name: str | None = None, route_cls_override: type[Route] | None = None, generate_unique_id_fn: Callable[Route, str] | DefaultPlaceholder = ..., responses: dict[int | str, dict[str, Any]] | None = None, response_class: type[Response] | DefaultPlaceholder = ...) -> None: ...
    def get_route_handler(self) -> Callable[[Request], Coroutine[Any, Any, Response]]: ...
    def matches(self, scope: Scope) -> tuple[Match, Scope]: ...
    def url_path_for(self, name: str, /, **path_params: Any) -> URLPath: ...
    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    def __eq__(self, other: Any) -> bool: ...

class Router:
    prefix: Incomplete
    routes: Incomplete
    default: Incomplete
    route_class: Incomplete
    redirect_slashes: Incomplete
    lifespan_context: Incomplete
    generate_unique_id_function: Incomplete
    middleware_stack: Incomplete
    def __init__(self, routes: Sequence[BaseRoute] | None = None, default: ASGIApp | None = None, lifespan: Lifespan[Any] | None = None, *, middlewares: Sequence[Middleware] | None = None, prefix: Annotated[str, None] = '', generate_unique_id_fn: Annotated[Callable[[Route], str], None] = ..., redirect_slashes: Annotated[bool, None] = True) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    async def lifespan(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    def route(self, path: str, methods: list[str] | None = None, name: str | None = None, include_in_schema: bool = True) -> Callable[[DecoratedCallable], DecoratedCallable]: ...
    async def app(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    def add_route(self, path: str, endpoint: Callable[[Request], Awaitable[Response] | Response], methods: list[str] | None = None, name: str | None = None, include_in_schema: bool = True) -> None: ...
    def add_api_route(self, path: str, endpoint: Callable[[Request], Awaitable[Response] | Response], *, response_model: Any = ..., status_code: int | None = None, methods: list[str] | set[str] | None = None, operation_id: str | None = None, name: str | None = None, route_cls_override: type[Route] | None = None, generate_unique_id_fn: Callable[Route, str] | DefaultPlaceholder = ...): ...
    def api_route(self, path: str, *, response_model: Any = ..., status_code: int | None = None, methods: list[str] | set[str] | None = None, operation_id: str | None = None, name: str | None = None, generate_unique_id_fn: Callable[Route, str] | DefaultPlaceholder = ...): ...
    def get(self, path: str, *, status_code: int | None = None): ...
    def put(self, path: str, *, status_code: int | None = None): ...
    def post(self, path: str, *, status_code: int | None = None): ...
    def delete(self, path: str, *, status_code: int | None = None): ...
    async def startup(self) -> None: ...
    async def shutdown(self) -> None: ...
    @staticmethod
    async def not_found(scope: Scope, receive: Receive, send: Send) -> None: ...
