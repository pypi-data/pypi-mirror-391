import typing
from _typeshed import Incomplete
from collections.abc import Callable as Callable
from contextlib import contextmanager
from pydantic import ConfigDict as ConfigDict
from pydantic.fields import FieldInfo
from pydantic_core import PydanticUndefinedType as PydanticUndefinedType
from typing import TypeGuard
from zephyr._types import Scope as Scope
from zephyr.app._compat import ModelField as ModelField
from zephyr.app.datastructures import DefaultPlaceholder as DefaultPlaceholder, DefaultType as DefaultType
from zephyr.app.routing import Route as Route

has_exceptiongroups: bool
T = typing.TypeVar('T')
AwaitableCallable = typing.Callable[..., typing.Awaitable[T]]

@typing.overload
def is_async_callable(obj: AwaitableCallable[T]) -> TypeGuard[AwaitableCallable[T]]: ...
@typing.overload
def is_async_callable(obj: typing.Any) -> TypeGuard[AwaitableCallable[typing.Any]]: ...
T_co = typing.TypeVar('T_co', covariant=True)

class AwaitableOrContextManager(typing.Awaitable[T_co], typing.AsyncContextManager[T_co], typing.Protocol[T_co]): ...

class SupportsAsyncClose(typing.Protocol):
    async def close(self) -> None: ...
SupportsAsyncCloseType = typing.TypeVar('SupportsAsyncCloseType', bound=SupportsAsyncClose, covariant=False)

class AwaitableOrContextManagerWrapper(typing.Generic[SupportsAsyncCloseType]):
    aw: Incomplete
    def __init__(self, aw: typing.Awaitable[SupportsAsyncCloseType]) -> None: ...
    def __await__(self) -> typing.Generator[typing.Any, None, SupportsAsyncCloseType]: ...
    entered: Incomplete
    async def __aenter__(self) -> SupportsAsyncCloseType: ...
    async def __aexit__(self, *args: typing.Any) -> None | bool: ...

@contextmanager
def collapse_excgroups() -> typing.Generator[None, None, None]: ...
def get_route_path(scope: Scope) -> str: ...
def generate_unique_id(route: Route) -> str: ...
def get_value_or_default(first_item: DefaultPlaceholder | DefaultType, *extra_items: DefaultPlaceholder | DefaultType) -> DefaultPlaceholder | DefaultType: ...
def get_typed_annotation(annotation: typing.Any, globalns: dict[str, typing.Any]) -> typing.Any: ...
def get_typed_return_annotation(call: Callable[..., typing.Any]) -> typing.Any: ...
def get_name(endpoint: typing.Callable[..., typing.Any]) -> str: ...
def is_body_allowed_for_status_code(status_code: int | str | None) -> bool: ...
def get_path_param_names(path: str) -> set[str]: ...
def create_model_field(name: str, type_: typing.Any, class_validators: dict[str, typing.Any] | None = None, default: typing.Any | None = ..., field_info: FieldInfo | None = None, alias: str | None = None, mode: typing.Literal['validation', 'serialization'] = 'validation') -> ModelField: ...
