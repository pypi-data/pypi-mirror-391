import typing
from _typeshed import Incomplete
from collections.abc import Callable as Callable, Iterable
from pydantic import GetJsonSchemaHandler as GetJsonSchemaHandler
from pydantic.json_schema import JsonSchemaValue as JsonSchemaValue
from pydantic_core import CoreSchema as CoreSchema
from typing import Any
from urllib.parse import SplitResult as SplitResult
from zephyr._types import Scope as Scope
from zephyr.app.concurrency import run_in_threadpool as run_in_threadpool

class Address(typing.NamedTuple):
    host: str
    port: int

class URL:
    def __init__(self, url: str = '', scope: Scope | None = None, **components: typing.Any) -> None: ...
    @property
    def components(self) -> SplitResult: ...
    @property
    def scheme(self) -> str: ...
    @property
    def netloc(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def query(self) -> str: ...
    @property
    def fragment(self) -> str: ...
    @property
    def username(self) -> None | str: ...
    @property
    def password(self) -> None | str: ...
    @property
    def hostname(self) -> None | str: ...
    @property
    def port(self) -> int | None: ...
    @property
    def is_secure(self) -> bool: ...
    def replace(self, **kwargs: typing.Any) -> URL: ...
    def include_query_params(self, **kwargs: typing.Any) -> URL: ...
    def replace_query_params(self, **kwargs: typing.Any) -> URL: ...
    def remove_query_params(self, keys: str | typing.Sequence[str]) -> URL: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class URLPath(str):
    def __new__(cls, path: str, protocol: str = '', host: str = '') -> URLPath: ...
    protocol: Incomplete
    host: Incomplete
    def __init__(self, path: str, protocol: str = '', host: str = '') -> None: ...
    def make_absolute_url(self, base_url: str | URL) -> URL: ...

class Secret:
    def __init__(self, value: str) -> None: ...
    def __bool__(self) -> bool: ...

class CommaSeparatedStrings(typing.Sequence[str]):
    def __init__(self, value: str | typing.Sequence[str]) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int | slice) -> typing.Any: ...
    def __iter__(self) -> typing.Iterator[str]: ...

class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):
    def __init__(self, *args: ImmutableMultiDict[_KeyType, _CovariantValueType] | typing.Mapping[_KeyType, _CovariantValueType] | typing.Iterable[tuple[_KeyType, _CovariantValueType]], **kwargs: typing.Any) -> None: ...
    def getlist(self, key: typing.Any) -> list[_CovariantValueType]: ...
    def keys(self) -> typing.KeysView[_KeyType]: ...
    def values(self) -> typing.ValuesView[_CovariantValueType]: ...
    def items(self) -> typing.ItemsView[_KeyType, _CovariantValueType]: ...
    def multi_items(self) -> list[tuple[_KeyType, _CovariantValueType]]: ...
    def __getitem__(self, key: _KeyType) -> _CovariantValueType: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[_KeyType]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):
    def __setitem__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __delitem__(self, key: typing.Any) -> None: ...
    def pop(self, key: typing.Any, default: typing.Any = None) -> typing.Any: ...
    def popitem(self) -> tuple[typing.Any, typing.Any]: ...
    def poplist(self, key: typing.Any) -> list[typing.Any]: ...
    def clear(self) -> None: ...
    def setdefault(self, key: typing.Any, default: typing.Any = None) -> typing.Any: ...
    def setlist(self, key: typing.Any, values: list[typing.Any]) -> None: ...
    def append(self, key: typing.Any, value: typing.Any) -> None: ...
    def update(self, *args: MultiDict | typing.Mapping[typing.Any, typing.Any] | list[tuple[typing.Any, typing.Any]], **kwargs: typing.Any) -> None: ...

class QueryParams(ImmutableMultiDict[str, str]):
    def __init__(self, *args: ImmutableMultiDict[typing.Any, typing.Any] | typing.Mapping[typing.Any, typing.Any] | list[tuple[typing.Any, typing.Any]] | str | bytes, **kwargs: typing.Any) -> None: ...

class UploadFile:
    filename: Incomplete
    file: Incomplete
    size: Incomplete
    headers: Incomplete
    def __init__(self, file: typing.BinaryIO, *, size: int | None = None, filename: str | None = None, headers: Headers | None = None) -> None: ...
    @property
    def content_type(self) -> str | None: ...
    async def write(self, data: bytes) -> None: ...
    async def read(self, size: int = -1) -> bytes: ...
    async def seek(self, offset: int) -> None: ...
    async def close(self) -> None: ...
    @classmethod
    def __get_validators__(cls) -> Iterable[Callable[..., Any]]: ...
    @classmethod
    def validate(cls, v: Any) -> Any: ...
    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue: ...
    @classmethod
    def __get_pydantic_core_schema__(cls, source: type[Any], handler: Callable[[Any], CoreSchema]) -> CoreSchema: ...

class FormData(ImmutableMultiDict[str, UploadFile | str]):
    def __init__(self, *args: FormData | typing.Mapping[str, str | UploadFile] | list[tuple[str, str | UploadFile]], **kwargs: str | UploadFile) -> None: ...
    async def close(self) -> None: ...

class Headers(typing.Mapping[str, str]):
    def __init__(self, headers: list[tuple[bytes, bytes]] | None = None, raw: list[tuple[bytes, bytes]] | None = None, scope: typing.MutableMapping[str, typing.Any] | None = None) -> None: ...
    @property
    def raw(self) -> list[tuple[bytes, bytes]]: ...
    def keys(self) -> list[str]: ...
    def values(self) -> list[str]: ...
    def items(self) -> list[tuple[str, str]]: ...
    def getlist(self, key: str) -> list[str]: ...
    def mutablecopy(self) -> MutableHeaders: ...
    def __getitem__(self, key: str) -> str: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[typing.Any]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class MutableHeaders(Headers):
    def __setitem__(self, key: str, value: str) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __ior__(self, other: typing.Mapping[str, str]) -> MutableHeaders: ...
    def __or__(self, other: typing.Mapping[str, str]) -> MutableHeaders: ...
    @property
    def raw(self) -> list[tuple[bytes, bytes]]: ...
    def setdefault(self, key: str, value: str) -> str: ...
    def update(self, other: typing.Mapping[str, str]) -> None: ...
    def append(self, key: str, value: str) -> None: ...
    def add_vary_header(self, vary: str) -> None: ...

class State:
    def __init__(self, state: dict[str, typing.Any] | None = None) -> None: ...
    def __setattr__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __getattr__(self, key: typing.Any) -> typing.Any: ...
    def __delattr__(self, key: typing.Any) -> None: ...

class DefaultPlaceholder:
    value: Incomplete
    def __init__(self, value: Any) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, o: object) -> bool: ...
DefaultType = typing.TypeVar('DefaultType')

def Default(value: DefaultType) -> DefaultType: ...
