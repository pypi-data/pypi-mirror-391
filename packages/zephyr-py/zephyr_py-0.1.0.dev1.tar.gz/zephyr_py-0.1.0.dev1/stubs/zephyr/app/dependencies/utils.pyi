import inspect
from contextlib import AsyncExitStack
from dataclasses import dataclass
from typing import Any, Callable, Mapping, Sequence
from zephyr.app import params as params
from zephyr.app._compat import ErrorWrapper as ErrorWrapper, ModelField as ModelField, PYDANTIC_V2 as PYDANTIC_V2, RequiredParam as RequiredParam, Undefined as Undefined, copy_field_info as copy_field_info, create_body_model as create_body_model, evaluate_forwardref as evaluate_forwardref, field_annotation_is_scalar as field_annotation_is_scalar, get_annotation_from_field_info as get_annotation_from_field_info, get_cached_model_fields as get_cached_model_fields, get_missing_field_error as get_missing_field_error, is_bytes_field as is_bytes_field, is_bytes_sequence_field as is_bytes_sequence_field, is_scalar_field as is_scalar_field, is_scalar_sequence_field as is_scalar_sequence_field, is_sequence_field as is_sequence_field, is_uploadfile_or_nonable_uploadfile_annotation as is_uploadfile_or_nonable_uploadfile_annotation, is_uploadfile_sequence_annotation as is_uploadfile_sequence_annotation, lenient_issubclass as lenient_issubclass, sequence_types as sequence_types, serialize_sequence_value as serialize_sequence_value, value_is_sequence as value_is_sequence
from zephyr.app._utils import create_model_field as create_model_field, get_path_param_names as get_path_param_names
from zephyr.app.background import BackgroundTasks as BackgroundTasks
from zephyr.app.concurrency import asynccontextmanager as asynccontextmanager, contextmanager_in_threadpool as contextmanager_in_threadpool, run_in_threadpool as run_in_threadpool
from zephyr.app.datastructures import FormData as FormData, Headers as Headers, ImmutableMultiDict as ImmutableMultiDict, QueryParams as QueryParams, UploadFile as UploadFile
from zephyr.app.dependencies.models import Dependant as Dependant, SecurityRequirement as SecurityRequirement
from zephyr.app.requests import HTTPConnection as HTTPConnection, Request as Request
from zephyr.app.responses import Response as Response
from zephyr.app.security.base import SecurityBase as SecurityBase
from zephyr.app.websockets import WebSocket as WebSocket
from zephyr.core.logging import logger as logger

multipart_not_installed_error: str
multipart_incorrect_install_error: str

def ensure_multipart_is_installed() -> None: ...
def get_param_sub_dependant(*, param_name: str, depends: params.Depends, path: str, security_scopes: list[str] | None = None) -> Dependant: ...
def get_parameterless_sub_dependant(*, depends: params.Depends, path: str) -> Dependant: ...
def get_sub_dependant(*, depends: params.Depends, dependency: Callable[..., Any], path: str, name: str | None = None, security_scopes: list[str] | None = None) -> Dependant: ...
CacheKey = tuple[Callable[..., Any] | None, tuple[str, ...]]

def get_flat_dependant(dependant: Dependant, *, skip_repeats: bool = False, visited: list[CacheKey] | None = None) -> Dependant: ...
def get_flat_params(dependant: Dependant) -> list[ModelField]: ...
def get_typed_signature(call: Callable[..., Any]) -> inspect.Signature: ...
def get_typed_annotation(annotation: Any, globalns: dict[str, Any]) -> Any: ...
def get_typed_return_annotation(call: Callable[..., Any]) -> Any: ...
def get_dependant(*, path: str, call: Callable[..., Any], name: str | None = None, security_scopes: list[str] | None = None, use_cache: bool = True) -> Dependant: ...
def add_non_field_param_to_dependency(*, param_name: str, type_annotation: Any, dependant: Dependant) -> bool | None: ...

@dataclass
class ParamDetails:
    type_annotation: Any
    depends: params.Depends | None
    field: ModelField | None

def analyze_param(*, param_name: str, annotation: Any, value: Any, is_path_param: bool) -> ParamDetails: ...
def add_param_to_fields(*, field: ModelField, dependant: Dependant) -> None: ...
def is_coroutine_callable(call: Callable[..., Any]) -> bool: ...
def is_async_gen_callable(call: Callable[..., Any]) -> bool: ...
def is_gen_callable(call: Callable[..., Any]) -> bool: ...
async def solve_generator(*, call: Callable[..., Any], stack: AsyncExitStack, sub_values: dict[str, Any]) -> Any: ...

@dataclass
class SolvedDependency:
    values: dict[str, Any]
    errors: list[Any]
    background_tasks: BackgroundTasks | None
    response: Response
    dependency_cache: dict[tuple[Callable[..., Any], tuple[str]], Any]

async def solve_dependencies(*, request: Request | WebSocket, dependant: Dependant, body: dict[str, Any] | FormData | None = None, background_tasks: BackgroundTasks | None = None, response: Response | None = None, dependency_overrides_provider: Any | None = None, dependency_cache: dict[tuple[Callable[..., Any], tuple[str]], Any] | None = None, async_exit_stack: AsyncExitStack, embed_body_fields: bool) -> SolvedDependency: ...
def request_params_to_args(fields: Sequence[ModelField], received_params: Mapping[str, Any] | QueryParams | Headers) -> tuple[dict[str, Any], list[Any]]: ...
async def request_body_to_args(body_fields: list[ModelField], received_body: dict[str, Any] | FormData | None, embed_body_fields: bool) -> tuple[dict[str, Any], list[dict[str, Any]]]: ...
def get_body_field(*, flat_dependant: Dependant, name: str, embed_body_fields: bool) -> ModelField | None: ...
