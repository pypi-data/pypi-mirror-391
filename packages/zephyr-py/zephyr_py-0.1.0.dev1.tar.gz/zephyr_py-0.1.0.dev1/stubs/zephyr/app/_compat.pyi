from _typeshed import Incomplete
from dataclasses import dataclass
from enum import Enum
from functools import lru_cache
from pydantic import BaseModel
from pydantic._internal._typing_extra import eval_type_lenient
from pydantic.fields import FieldInfo as FieldInfo, ModelField as ModelField
from pydantic.json_schema import GenerateJsonSchema as GenerateJsonSchema, JsonSchemaValue as JsonSchemaValue
from pydantic_core import PydanticUndefined, PydanticUndefinedType
from typing import Any, Sequence
from typing_extensions import Literal
from zephyr._types import IncEx as IncEx, ModelNameMap as ModelNameMap, UnionType as UnionType
from zephyr.app.datastructures import UploadFile as UploadFile
from zephyr.app.exceptions import RequestErrorModel as RequestErrorModel

PYDANTIC_VERSION_MINOR_TUPLE: Incomplete
PYDANTIC_V2: Incomplete
sequence_annotation_to_type: Incomplete
sequence_types: Incomplete
Url: type[Any]
RequiredParam = PydanticUndefined
Undefined = PydanticUndefined
UndefinedType = PydanticUndefinedType
evaluate_forwardref = eval_type_lenient
Validator = Any

class BaseConfig: ...
class ErrorWrapper(Exception): ...

@dataclass
class ModelField:
    field_info: FieldInfo
    name: str
    mode: Literal['validation', 'serialization'] = ...
    @property
    def alias(self) -> str: ...
    @property
    def required(self) -> bool: ...
    @property
    def default(self) -> Any: ...
    @property
    def type_(self) -> Any: ...
    def __post_init__(self) -> None: ...
    def get_default(self) -> Any: ...
    def validate(self, value: Any, values: dict[str, Any] = {}, *, loc: tuple[int | str, ...] = ()) -> tuple[Any, list[dict[str, Any]] | None]: ...
    def serialize(self, value: Any, *, mode: Literal['json', 'python'] = 'json', include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool = True, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False) -> Any: ...
    def __hash__(self) -> int: ...

def get_annotation_from_field_info(annotation: Any, field_info: FieldInfo, field_name: str) -> Any: ...
def get_schema_from_model_field(*, field: ModelField, schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, field_mapping: dict[tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], separate_input_output_schemas: bool = True) -> dict[str, Any]: ...
def get_compat_model_name_map(fields: list[ModelField]) -> ModelNameMap: ...
def get_definitions(*, fields: list[ModelField], schema_generator: GenerateJsonSchema, model_name_map: ModelNameMap, separate_input_output_schemas: bool = True) -> tuple[dict[tuple[ModelField, Literal['validation', 'serialization']], JsonSchemaValue], dict[str, dict[str, Any]]]: ...
def is_scalar_field(field: ModelField) -> bool: ...
def is_sequence_field(field: ModelField) -> bool: ...
def is_scalar_sequence_field(field: ModelField) -> bool: ...
def is_bytes_field(field: ModelField) -> bool: ...
def is_bytes_sequence_field(field: ModelField) -> bool: ...
def copy_field_info(*, field_info: FieldInfo, annotation: Any) -> FieldInfo: ...
def serialize_sequence_value(*, field: ModelField, value: Any) -> Sequence[Any]: ...
def get_missing_field_error(loc: tuple[str, ...]) -> dict[str, Any]: ...
def create_body_model(*, fields: Sequence[ModelField], model_name: str) -> type[BaseModel]: ...
def get_model_fields(model: type[BaseModel]) -> list[ModelField]: ...
GetJsonSchemaHandler = Any
JsonSchemaValue = dict[str, Any]
CoreSchema = Any
sequence_shapes: Incomplete
sequence_shape_to_type: Incomplete

@dataclass
class GenerateJsonSchema:
    ref_template: str

class PydanticSchemaGenerationError(Exception): ...

def get_model_definitions(*, flat_models: set[type[BaseModel] | type[Enum]], model_name_map: dict[type[BaseModel] | type[Enum], str]) -> dict[str, Any]: ...
def is_pv1_scalar_field(field: ModelField) -> bool: ...
def is_pv1_scalar_sequence_field(field: ModelField) -> bool: ...
def field_annotation_is_sequence(annotation: type[Any] | None) -> bool: ...
def value_is_sequence(value: Any) -> bool: ...
def field_annotation_is_complex(annotation: type[Any] | None) -> bool: ...
def field_annotation_is_scalar(annotation: Any) -> bool: ...
def field_annotation_is_scalar_sequence(annotation: type[Any] | None) -> bool: ...
def is_bytes_or_nonable_bytes_annotation(annotation: Any) -> bool: ...
def is_uploadfile_or_nonable_uploadfile_annotation(annotation: Any) -> bool: ...
def is_bytes_sequence_annotation(annotation: Any) -> bool: ...
def is_uploadfile_sequence_annotation(annotation: Any) -> bool: ...
@lru_cache
def get_cached_model_fields(model: type[BaseModel]) -> list[ModelField]: ...
