#!/usr/bin/env python3
"""
Robot Framework Self-Healing Locator Update Tool

This script automatically updates broken locators in Robot Framework test files
with fixed locators generated by the self-healing library.

Usage:
    python update_locators.py <fixed_locators.json>
    python update_locators.py <fixed_locators.json> --no-backup
    python update_locators.py <fixed_locators.json> --dry-run

Examples:
    # Interactive mode with backup
    python update_locators.py ./fixed_locators.json
    
    # Automatic mode without backup
    python update_locators.py ./fixed_locators.json --no-backup --yes
    
    # Preview changes without applying
    python update_locators.py ./fixed_locators.json --dry-run
"""

import json
import sys
import os
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Tuple
import shutil
import argparse


class LocatorUpdater:
    def __init__(self, json_path: str, create_backup: bool = True, auto_confirm: bool = False, dry_run: bool = False):
        self.json_path = json_path
        self.create_backup = create_backup
        self.auto_confirm = auto_confirm
        self.dry_run = dry_run
        self.updates_applied = 0
        self.files_modified = 0
        
    def print_header(self, text: str):
        """Print formatted header"""
        print("\n" + "=" * 78)
        print(text)
        print("=" * 78 + "\n")
    
    def load_fixed_locators(self) -> List[Dict]:
        """Load fixed locators from JSON file"""
        try:
            with open(self.json_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            print(f"‚úì Loaded {len(data)} fixed locator(s) from {self.json_path}")
            return data
        except FileNotFoundError:
            print(f"‚úó Error: File not found: {self.json_path}")
            sys.exit(1)
        except json.JSONDecodeError as e:
            print(f"‚úó Error: Invalid JSON format: {e}")
            sys.exit(1)
    
    def group_by_file(self, locators: List[Dict]) -> Dict[str, List[Dict]]:
        """Group locators by source file"""
        grouped = {}
        for locator in locators:
            source = locator.get('source')
            if source:
                if source not in grouped:
                    grouped[source] = []
                grouped[source].append(locator)
        return grouped
    
    def preview_changes(self, grouped_locators: Dict[str, List[Dict]]):
        """Display preview of changes to be made"""
        self.print_header("PREVIEW OF CHANGES")
        
        count = 1
        for file_path, locators in grouped_locators.items():
            # Sort by line number
            locators.sort(key=lambda x: x.get('lineno', 0))
            
            for loc in locators:
                print(f"{count}. {loc.get('test_name', 'Unknown Test')}")
                print(f"   File: {file_path}")
                print(f"   Line: {loc.get('lineno', 'N/A')}")
                print(f"   Keyword: {loc.get('keyword_name', 'N/A')}")
                print(f"   Broken: {loc.get('broken_locator', 'N/A')}")
                print(f"   Fixed:  {loc.get('fixed_locator', 'N/A')}")
                print()
                count += 1
    
    def confirm_action(self, prompt: str, default: str = "yes") -> bool:
        """Ask user for confirmation"""
        if self.auto_confirm:
            return True
        
        choices = "yes/no"
        default_indicator = f"[{default}]" if default else ""
        
        while True:
            response = input(f"{prompt} ({choices}) {default_indicator}: ").lower().strip()
            
            if not response and default:
                response = default
            
            if response in ['yes', 'y']:
                return True
            elif response in ['no', 'n']:
                return False
            else:
                print("Please answer 'yes' or 'no'")
    
    def backup_file(self, file_path: str) -> str:
        """Create a backup of the file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{file_path}.backup_{timestamp}"
        shutil.copy2(file_path, backup_path)
        return backup_path
    
    def apply_updates_to_file(self, file_path: str, locators: List[Dict]) -> Tuple[int, List[str]]:
        """Apply locator updates to a single file"""
        if not os.path.exists(file_path):
            print(f"   ‚úó File not found: {file_path}")
            return 0, []
        
        # Read file content
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
        except Exception as e:
            print(f"   ‚úó Error reading file: {e}")
            return 0, []
        
        # Sort locators by line number in descending order to avoid line number shifts
        locators.sort(key=lambda x: x.get('lineno', 0), reverse=True)
        
        updates_count = 0
        changes = []
        
        for loc in locators:
            lineno = loc.get('lineno')
            broken = loc.get('broken_locator')
            fixed = loc.get('fixed_locator')
            
            if not lineno or not broken or not fixed:
                continue
            
            # Convert to 0-based index
            line_index = lineno - 1
            
            if line_index < 0 or line_index >= len(lines):
                print(f"   ‚ö† Warning: Line {lineno} out of range")
                continue
            
            original_line = lines[line_index]
            
            # Replace broken locator with fixed locator
            if broken in original_line:
                new_line = original_line.replace(broken, fixed, 1)
                lines[line_index] = new_line
                updates_count += 1
                changes.append(f"   ‚úì Line {lineno}: Updated locator\n"
                             f"      Old: {broken}\n"
                             f"      New: {fixed}")
            else:
                print(f"   ‚ö† Warning: Locator not found on line {lineno}")
                print(f"      Looking for: {broken}")
                print(f"      Found: {original_line.strip()}")
        
        # Write updated content back to file (if not dry run)
        if updates_count > 0 and not self.dry_run:
            try:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.writelines(lines)
            except Exception as e:
                print(f"   ‚úó Error writing file: {e}")
                return 0, []
        
        return updates_count, changes
    
    def run(self):
        """Main execution flow"""
        self.print_header("Robot Framework Self-Healing Locator Update Tool")
        
        # Load locators
        locators = self.load_fixed_locators()
        
        if not locators:
            print("No locators to update.")
            return
        
        # Group by file
        grouped = self.group_by_file(locators)
        
        # Preview changes
        self.preview_changes(grouped)
        
        # Confirm action
        if self.dry_run:
            print("üîç DRY RUN MODE - No changes will be applied\n")
        else:
            if not self.confirm_action("Apply these updates to source files?"):
                print("‚ùå Update cancelled by user")
                return
            
            if self.create_backup and not self.auto_confirm:
                self.create_backup = self.confirm_action("Create backups before updating?", "yes")
        
        # Apply updates
        self.print_header("APPLYING UPDATES" if not self.dry_run else "DRY RUN PREVIEW")
        
        for file_path, locators in grouped.items():
            print(f"üìÑ Processing: {file_path}")
            
            # Create backup if requested
            if self.create_backup and not self.dry_run:
                try:
                    backup_path = self.backup_file(file_path)
                    print(f"   üíæ Backup created: {backup_path}")
                except Exception as e:
                    print(f"   ‚úó Error creating backup: {e}")
                    if not self.confirm_action(f"Continue without backup for {file_path}?", "no"):
                        continue
            
            # Apply updates
            updates_count, changes = self.apply_updates_to_file(file_path, locators)
            
            # Print changes
            for change in changes:
                print(change)
            
            if updates_count > 0:
                mode = "(would be updated)" if self.dry_run else "updated successfully"
                print(f"\n   ‚úì {updates_count} locator(s) {mode}\n")
                self.updates_applied += updates_count
                self.files_modified += 1
            else:
                print(f"   ‚Ñπ No updates applied\n")
        
        # Summary
        self.print_header("SUMMARY")
        if self.dry_run:
            print(f"üîç Would update: {self.updates_applied} locator(s) in {self.files_modified} file(s)")
        else:
            print(f"‚úì Successfully updated: {self.updates_applied} locator(s) in {self.files_modified} file(s)")
        self.print_header("")


def main():
    parser = argparse.ArgumentParser(
        description="Update Robot Framework test locators from self-healing results",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Interactive mode with backup
  python update_locators.py fixed_locators.json
  
  # Automatic mode without prompts
  python update_locators.py fixed_locators.json --yes --no-backup
  
  # Preview changes without applying
  python update_locators.py fixed_locators.json --dry-run
        """
    )
    
    parser.add_argument(
        'json_file',
        help='Path to fixed_locators.json file'
    )
    
    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Skip creating backup files'
    )
    
    parser.add_argument(
        '--yes', '-y',
        action='store_true',
        help='Automatically confirm all prompts'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview changes without applying them'
    )
    
    args = parser.parse_args()
    
    # Validate JSON file exists
    if not os.path.exists(args.json_file):
        print(f"Error: File not found: {args.json_file}")
        sys.exit(1)
    
    # Create updater and run
    updater = LocatorUpdater(
        json_path=args.json_file,
        create_backup=not args.no_backup,
        auto_confirm=args.yes,
        dry_run=args.dry_run
    )
    
    try:
        updater.run()
    except KeyboardInterrupt:
        print("\n\n‚ùå Operation cancelled by user (Ctrl+C)")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚úó Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
