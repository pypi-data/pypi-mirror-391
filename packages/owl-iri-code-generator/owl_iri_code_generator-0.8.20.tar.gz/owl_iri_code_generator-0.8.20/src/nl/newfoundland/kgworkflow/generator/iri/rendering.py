"""Module responsible for rendering the generated Python code.

It formats a top-of-file header, emits module-level constants for entities,
and emits rich comments with annotations and optional Manchester axioms.
"""
from pathlib import Path
from typing import Dict, List
import logging

from nl.newfoundland.kgworkflow.generator.iri.discovery import (
    K_CLASS,
    K_OBJECT_PROPERTY,
    K_DATA_PROPERTY,
    K_INDIVIDUAL,
    K_ANNOTATION_PROPERTY,
)
from nl.newfoundland.kgworkflow.generator.iri.graph_loader import GraphMeta

HEADER = """# Generated by owl_to_python
# Deterministic output; do not edit by hand.
# Source: {source}
# Ontology IRI: {ont}
# Version IRI: {ver}
# Triple count: {triples}
# Graph hash: {h}
"""

_KIND_TITLES = {
    K_CLASS: "Classes",
    K_OBJECT_PROPERTY: "Object properties",
    K_DATA_PROPERTY: "Data properties",
    K_INDIVIDUAL: "Individuals",
    K_ANNOTATION_PROPERTY: "Annotation properties",
}

# Singular names for comments and type resolution
_KIND_NAMES = {
    K_CLASS: "Class",
    K_OBJECT_PROPERTY: "ObjectProperty",
    K_DATA_PROPERTY: "DataProperty",
    K_INDIVIDUAL: "Individual",
    K_ANNOTATION_PROPERTY: "AnnotationProperty",
}

# Type alias names corresponding to kinds
_KIND_TYPE_ALIAS = {
    K_CLASS: "ClassIRI",
    K_OBJECT_PROPERTY: "ObjectPropertyIRI",
    K_DATA_PROPERTY: "DataPropertyIRI",
    K_INDIVIDUAL: "IndividualIRI",
    K_ANNOTATION_PROPERTY: "AnnotationPropertyIRI",
}


def _module_name_from_namespace(ns: str) -> str:
    """Derive a safe Python module name from a namespace base IRI.

    Kept for potential future use; currently output naming is driven by
    --class-name or --out-file.
    """
    base = ns.rstrip("/").rsplit("/", 1)[-1]
    if not base:
        base = "generated"
    safe = "".join(ch if ch.isalnum() or ch == "_" else "_" for ch in base)
    if safe and safe[0].isdigit():
        safe = f"_{safe}"
    return safe


def _write_section(lines: List[str], title: str):
    """Append a section header comment line to the output buffer."""
    lines.append("")
    lines.append(f"# === {title} ===")


def _comment_block(entity: dict, cfg, kind: str) -> List[str]:
    """Build the wrapped comment block for a single entity.

    Includes: separator, label/alt labels, identifier/definition/comment,
    examples/scope notes, and optionally a blank line + Manchester axioms.
    """

    def _shorten_pred(iri: str) -> str:
        # Map known IRIs to CURIE-like names; else return full IRI
        mapping = {
            "http://www.w3.org/2000/01/rdf-schema#comment": "rdfs:comment",
            "http://www.w3.org/2004/02/skos/core#definition": "skos:definition",
            "http://www.w3.org/2004/02/skos/core#example": "skos:example",
            "http://www.w3.org/2004/02/skos/core#scopeNote": "skos:scopeNote",
            "http://purl.org/dc/terms/description": "dc:description",
            "http://purl.org/dc/elements/1.1/identifier": "dc11:identifier",
            "http://purl.org/dc/terms/identifier": "dc:identifier",
            "http://purl.obolibrary.org/obo/IAO_0000115": "IAO:0000115",
        }
        return mapping.get(iri, iri)

    def _wrap_comment(text: str, width: int = 84) -> List[str]:
        """Wrap text to a fixed width with '# ' prefixes.

        The first line uses '# ' and continuations use '#   ' for readability.
        An empty text produces a single '#'.
        """
        first_prefix = "# "
        cont_prefix = "#   "
        max_first = max(1, width - len(first_prefix))
        max_cont = max(1, width - len(cont_prefix))
        words = text.split()
        if not words:
            return [first_prefix.rstrip()]  # just '#'
        lines: List[str] = []
        cur = words[0]
        cur_len = len(cur)
        limit = max_first
        prefix = first_prefix
        for w in words[1:]:
            if cur_len + 1 + len(w) <= limit:
                cur += " " + w
                cur_len += 1 + len(w)
            else:
                lines.append(prefix + cur)
                # switch to continuation settings
                prefix = cont_prefix
                limit = max_cont
                cur = w
                cur_len = len(w)
        lines.append(prefix + cur)
        return lines

    lines: List[str] = []
    # Separator at the start of each comment block
    lines.append("#" * 84)

    # Explicit kind hint to help IDE quick docs/completion context
    kind_name = _KIND_NAMES.get(kind, "Entity")
    lines.extend(_wrap_comment(f"kind: {kind_name}"))

    if entity.get("deprecated"):
        lines.extend(_wrap_comment("DEPRECATED"))
    pref = entity.get("preferred_label")
    if pref:
        lines.extend(_wrap_comment(f"label: {pref}"))
    all_labels = entity.get("labels", {})
    # Show up to two alt labels for context
    alt_count = 0
    for p, arr in all_labels.items():
        for val, lang in arr:
            if pref and val == pref:
                continue
            if alt_count >= 2:
                break
            if lang:
                lines.extend(_wrap_comment(f"alt: {val} (@{lang})"))
            else:
                lines.extend(_wrap_comment(f"alt: {val}"))
            alt_count += 1
        if alt_count >= 2:
            break

    # Annotations-based comments (full predicate names)
    ann = entity.get("annotations", {}) or {}
    identifier = ann.get("identifier")
    if identifier:
        pid, ival, ilang = identifier
        if ival:
            tag = _shorten_pred(pid)
            if ilang:
                lines.extend(_wrap_comment(f"{tag}: {ival} (@{ilang})"))
            else:
                lines.extend(_wrap_comment(f"{tag}: {ival}"))
    definition = ann.get("definition")
    if definition:
        pd, dval, dlang = definition
        if dval:
            tag = _shorten_pred(pd)
            if dlang:
                lines.extend(_wrap_comment(f"{tag}: {dval} (@{dlang})"))
            else:
                lines.extend(_wrap_comment(f"{tag}: {dval}"))
    comment = ann.get("comment")
    if comment:
        pc, cval, clang = comment
        if cval:
            tag = _shorten_pred(pc)
            if clang:
                lines.extend(_wrap_comment(f"{tag}: {cval} (@{clang})"))
            else:
                lines.extend(_wrap_comment(f"{tag}: {cval}"))
    examples = ann.get("examples") or []
    for p_ex, ex_val, ex_lang in examples:
        tag = _shorten_pred(p_ex)
        if ex_lang:
            lines.extend(_wrap_comment(f"{tag}: {ex_val} (@{ex_lang})"))
        else:
            lines.extend(_wrap_comment(f"{tag}: {ex_val}"))
    scope_notes = ann.get("scope_notes") or []
    for p_note, note_val, note_lang in scope_notes:
        tag = _shorten_pred(p_note)
        if note_lang:
            lines.extend(_wrap_comment(f"{tag}: {note_val} (@{note_lang})"))
        else:
            lines.extend(_wrap_comment(f"{tag}: {note_val}"))

    if cfg.manchester_comments and entity.get("manchester"):
        # Empty line between annotations and axiomatization
        lines.extend(_wrap_comment(""))
        for m in entity["manchester"]:
            lines.extend(_wrap_comment(m))
    return lines


def render_output(assigned: Dict[str, Dict[str, dict]], meta: GraphMeta, cfg) -> None:
    """Render the final Python module to disk based on the assigned symbols.

    The output location is `cfg.out_dir` and the file name comes from
    `--out-file`, else defaults to `generated.py`.
    """
    out_dir: Path = cfg.out_dir
    out_dir.mkdir(parents=True, exist_ok=True)
    log = logging.getLogger("owl_to_python.render")

    # Determine module name / output file name
    if cfg.out_file:
        out_filename = cfg.out_file
        if not out_filename.endswith(".py"):
            out_filename += ".py"
        mod_name = Path(out_filename).stem
    else:
        mod_name = "generated"
        out_filename = mod_name + ".py"

    # Single module emission
    for mod_name in [mod_name]:
        lines: List[str] = []
        lines.append(
            HEADER.format(
                source=meta.source_path,
                ont=meta.ontology_iri or "",
                ver=meta.version_iri or "",
                triples=meta.triple_count,
                h=meta.content_hash,
            )
        )
        lines.append("from rdflib import URIRef")
        lines.append("from typing import Final, NewType")
        # Type aliases to improve IDE completion: distinct kinds over URIRef
        lines.append("")
        lines.append("ClassIRI = NewType('ClassIRI', URIRef)")
        lines.append("ObjectPropertyIRI = NewType('ObjectPropertyIRI', URIRef)")
        lines.append("DataPropertyIRI = NewType('DataPropertyIRI', URIRef)")
        lines.append("AnnotationPropertyIRI = NewType('AnnotationPropertyIRI', URIRef)")
        lines.append("IndividualIRI = NewType('IndividualIRI', URIRef)")
        # Keep the generated module self-contained
        lines.append("")

        indent = ""

        def add_section(kind: str):
            """Append a section of constants for the given kind to the buffer."""
            title = _KIND_TITLES[kind]
            _write_section(lines, title)

            items = assigned.get(kind, {})
            # Optionally skip annotation properties
            if kind == K_ANNOTATION_PROPERTY and not cfg.emit_annotation_properties:
                log.debug("Skipping %s (disabled)", title)
                return

            n = len(items)
            if n:
                log.info("Rendering: %s (%d items)â€¦", title, n)
            step = max(1, max(100, n // 20))  # every 100 or ~5%

            for idx, (iri, info) in enumerate(sorted(items.items(), key=lambda t: t[1]["identifier"]), start=1):
                cmt = _comment_block(info, cfg, kind)
                for l in cmt:
                    lines.append(indent + l)
                ident = info["identifier"]
                type_alias = _KIND_TYPE_ALIAS.get(kind, "URIRef")
                lines.append(indent + f"{ident}: Final[{type_alias}] = URIRef(\"{info['iri']}\")")
                # blank line after each generated symbol for readability
                lines.append("")
                if idx % step == 0 or idx == n:
                    log.debug("Rendering: %s %d/%d (%.0f%%)", title, idx, n, (idx / max(1, n)) * 100)
            if n:
                log.info("Rendered: %s", title)

        for kind in [K_CLASS, K_OBJECT_PROPERTY, K_DATA_PROPERTY, K_INDIVIDUAL]:
            add_section(kind)
        if cfg.emit_annotation_properties:
            add_section(K_ANNOTATION_PROPERTY)

        content = "\n".join(lines) + "\n"
        out_path = out_dir / out_filename
        out_path.write_text(content, encoding="utf-8")
