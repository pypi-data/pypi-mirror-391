"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from documenso_sdk.utils import FieldMetadata, MultipartFormMetadata
from enum import Enum
import httpx
import io
import pydantic
from pydantic import model_serializer
from typing import Dict, IO, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EnvelopeCreateType(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"


class EnvelopeCreateVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class EnvelopeCreateGlobalAccessAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class EnvelopeCreateGlobalActionAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"


EnvelopeCreateFormValuesTypedDict = TypeAliasType(
    "EnvelopeCreateFormValuesTypedDict", Union[str, bool, float]
)


EnvelopeCreateFormValues = TypeAliasType(
    "EnvelopeCreateFormValues", Union[str, bool, float]
)


class EnvelopeCreateRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class EnvelopeCreateAccessAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class EnvelopeCreateActionAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class EnvelopeCreateTypeDropdown1(str, Enum):
    DROPDOWN = "DROPDOWN"


class EnvelopeCreateTypeDropdown2(str, Enum):
    DROPDOWN = "dropdown"


class EnvelopeCreateValueDropdownTypedDict(TypedDict):
    value: str


class EnvelopeCreateValueDropdown(BaseModel):
    value: str


class EnvelopeCreateFieldMetaDropdownTypedDict(TypedDict):
    type: EnvelopeCreateTypeDropdown2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeCreateValueDropdownTypedDict]]
    default_value: NotRequired[str]


class EnvelopeCreateFieldMetaDropdown(BaseModel):
    type: EnvelopeCreateTypeDropdown2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeCreateValueDropdown]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


EnvelopeCreateIdentifier11TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier11TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier11 = TypeAliasType(
    "EnvelopeCreateIdentifier11", Union[str, float]
)


class EnvelopeCreateFieldDropdownTypedDict(TypedDict):
    type: EnvelopeCreateTypeDropdown1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaDropdownTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier11TypedDict]


class EnvelopeCreateFieldDropdown(BaseModel):
    type: EnvelopeCreateTypeDropdown1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaDropdown], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier11] = None


class EnvelopeCreateTypeCheckbox1(str, Enum):
    CHECKBOX = "CHECKBOX"


class EnvelopeCreateTypeCheckbox2(str, Enum):
    CHECKBOX = "checkbox"


class EnvelopeCreateValueCheckboxTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeCreateValueCheckbox(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeCreateDirectionCheckbox(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeCreateFieldMetaCheckboxTypedDict(TypedDict):
    type: EnvelopeCreateTypeCheckbox2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeCreateValueCheckboxTypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]
    direction: NotRequired[EnvelopeCreateDirectionCheckbox]


class EnvelopeCreateFieldMetaCheckbox(BaseModel):
    type: EnvelopeCreateTypeCheckbox2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeCreateValueCheckbox]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None

    direction: Optional[EnvelopeCreateDirectionCheckbox] = (
        EnvelopeCreateDirectionCheckbox.VERTICAL
    )


EnvelopeCreateIdentifier10TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier10TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier10 = TypeAliasType(
    "EnvelopeCreateIdentifier10", Union[str, float]
)


class EnvelopeCreateFieldCheckboxTypedDict(TypedDict):
    type: EnvelopeCreateTypeCheckbox1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaCheckboxTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier10TypedDict]


class EnvelopeCreateFieldCheckbox(BaseModel):
    type: EnvelopeCreateTypeCheckbox1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaCheckbox], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier10] = None


class EnvelopeCreateTypeRadio1(str, Enum):
    RADIO = "RADIO"


class EnvelopeCreateTypeRadio2(str, Enum):
    RADIO = "radio"


class EnvelopeCreateValueRadioTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeCreateValueRadio(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeCreateDirectionRadio(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeCreateFieldMetaRadioTypedDict(TypedDict):
    type: EnvelopeCreateTypeRadio2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeCreateValueRadioTypedDict]]
    direction: NotRequired[EnvelopeCreateDirectionRadio]


class EnvelopeCreateFieldMetaRadio(BaseModel):
    type: EnvelopeCreateTypeRadio2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeCreateValueRadio]] = None

    direction: Optional[EnvelopeCreateDirectionRadio] = (
        EnvelopeCreateDirectionRadio.VERTICAL
    )


EnvelopeCreateIdentifier9TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier9TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier9 = TypeAliasType(
    "EnvelopeCreateIdentifier9", Union[str, float]
)


class EnvelopeCreateFieldRadioTypedDict(TypedDict):
    type: EnvelopeCreateTypeRadio1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaRadioTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier9TypedDict]


class EnvelopeCreateFieldRadio(BaseModel):
    type: EnvelopeCreateTypeRadio1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaRadio], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier9] = None


class EnvelopeCreateTypeNumber1(str, Enum):
    NUMBER = "NUMBER"


class EnvelopeCreateTypeNumber2(str, Enum):
    NUMBER = "number"


class EnvelopeCreateTextAlignNumber(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateVerticalAlignNumber(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeCreateFieldMetaNumberTypedDict(TypedDict):
    type: EnvelopeCreateTypeNumber2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    number_format: NotRequired[Nullable[str]]
    value: NotRequired[str]
    min_value: NotRequired[Nullable[float]]
    max_value: NotRequired[Nullable[float]]
    text_align: NotRequired[EnvelopeCreateTextAlignNumber]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeCreateVerticalAlignNumber]]


class EnvelopeCreateFieldMetaNumber(BaseModel):
    type: EnvelopeCreateTypeNumber2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    number_format: Annotated[
        OptionalNullable[str], pydantic.Field(alias="numberFormat")
    ] = UNSET

    value: Optional[str] = None

    min_value: Annotated[OptionalNullable[float], pydantic.Field(alias="minValue")] = (
        UNSET
    )

    max_value: Annotated[OptionalNullable[float], pydantic.Field(alias="maxValue")] = (
        UNSET
    )

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignNumber], pydantic.Field(alias="textAlign")
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeCreateVerticalAlignNumber],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "numberFormat",
            "value",
            "minValue",
            "maxValue",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = [
            "numberFormat",
            "minValue",
            "maxValue",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


EnvelopeCreateIdentifier8TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier8TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier8 = TypeAliasType(
    "EnvelopeCreateIdentifier8", Union[str, float]
)


class EnvelopeCreateFieldNumberTypedDict(TypedDict):
    type: EnvelopeCreateTypeNumber1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaNumberTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier8TypedDict]


class EnvelopeCreateFieldNumber(BaseModel):
    type: EnvelopeCreateTypeNumber1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaNumber], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier8] = None


class EnvelopeCreateTypeText1(str, Enum):
    TEXT = "TEXT"


class EnvelopeCreateTypeText2(str, Enum):
    TEXT = "text"


class EnvelopeCreateTextAlignText(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateVerticalAlignText(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeCreateFieldMetaTextTypedDict(TypedDict):
    type: EnvelopeCreateTypeText2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    text_align: NotRequired[EnvelopeCreateTextAlignText]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeCreateVerticalAlignText]]


class EnvelopeCreateFieldMetaText(BaseModel):
    type: EnvelopeCreateTypeText2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignText], pydantic.Field(alias="textAlign")
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeCreateVerticalAlignText],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "text",
            "characterLimit",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = ["lineHeight", "letterSpacing", "verticalAlign"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


EnvelopeCreateIdentifier7TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier7TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier7 = TypeAliasType(
    "EnvelopeCreateIdentifier7", Union[str, float]
)


class EnvelopeCreateFieldTextTypedDict(TypedDict):
    type: EnvelopeCreateTypeText1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaTextTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier7TypedDict]


class EnvelopeCreateFieldText(BaseModel):
    type: EnvelopeCreateTypeText1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaText], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier7] = None


class EnvelopeCreateTypeDate1(str, Enum):
    DATE = "DATE"


class EnvelopeCreateTypeDate2(str, Enum):
    DATE = "date"


class EnvelopeCreateTextAlignDate(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateFieldMetaDateTypedDict(TypedDict):
    type: EnvelopeCreateTypeDate2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeCreateTextAlignDate]


class EnvelopeCreateFieldMetaDate(BaseModel):
    type: EnvelopeCreateTypeDate2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignDate], pydantic.Field(alias="textAlign")
    ] = None


EnvelopeCreateIdentifier6TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier6TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier6 = TypeAliasType(
    "EnvelopeCreateIdentifier6", Union[str, float]
)


class EnvelopeCreateFieldDateTypedDict(TypedDict):
    type: EnvelopeCreateTypeDate1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaDateTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier6TypedDict]


class EnvelopeCreateFieldDate(BaseModel):
    type: EnvelopeCreateTypeDate1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaDate], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier6] = None


class EnvelopeCreateTypeEmail1(str, Enum):
    EMAIL = "EMAIL"


class EnvelopeCreateTypeEmail2(str, Enum):
    EMAIL = "email"


class EnvelopeCreateTextAlignEmail(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateFieldMetaEmailTypedDict(TypedDict):
    type: EnvelopeCreateTypeEmail2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeCreateTextAlignEmail]


class EnvelopeCreateFieldMetaEmail(BaseModel):
    type: EnvelopeCreateTypeEmail2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignEmail], pydantic.Field(alias="textAlign")
    ] = None


EnvelopeCreateIdentifier5TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier5TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier5 = TypeAliasType(
    "EnvelopeCreateIdentifier5", Union[str, float]
)


class EnvelopeCreateFieldEmailTypedDict(TypedDict):
    type: EnvelopeCreateTypeEmail1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaEmailTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier5TypedDict]


class EnvelopeCreateFieldEmail(BaseModel):
    type: EnvelopeCreateTypeEmail1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaEmail], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier5] = None


class EnvelopeCreateTypeName1(str, Enum):
    NAME = "NAME"


class EnvelopeCreateTypeName2(str, Enum):
    NAME = "name"


class EnvelopeCreateTextAlignName(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateFieldMetaNameTypedDict(TypedDict):
    type: EnvelopeCreateTypeName2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeCreateTextAlignName]


class EnvelopeCreateFieldMetaName(BaseModel):
    type: EnvelopeCreateTypeName2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignName], pydantic.Field(alias="textAlign")
    ] = None


EnvelopeCreateIdentifier4TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier4TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier4 = TypeAliasType(
    "EnvelopeCreateIdentifier4", Union[str, float]
)


class EnvelopeCreateFieldNameTypedDict(TypedDict):
    type: EnvelopeCreateTypeName1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaNameTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier4TypedDict]


class EnvelopeCreateFieldName(BaseModel):
    type: EnvelopeCreateTypeName1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaName], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier4] = None


class EnvelopeCreateTypeInitials1(str, Enum):
    INITIALS = "INITIALS"


class EnvelopeCreateTypeInitials2(str, Enum):
    INITIALS = "initials"


class EnvelopeCreateTextAlignInitials(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeCreateFieldMetaInitialsTypedDict(TypedDict):
    type: EnvelopeCreateTypeInitials2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeCreateTextAlignInitials]


class EnvelopeCreateFieldMetaInitials(BaseModel):
    type: EnvelopeCreateTypeInitials2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeCreateTextAlignInitials], pydantic.Field(alias="textAlign")
    ] = None


EnvelopeCreateIdentifier3TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier3TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier3 = TypeAliasType(
    "EnvelopeCreateIdentifier3", Union[str, float]
)


class EnvelopeCreateFieldInitialsTypedDict(TypedDict):
    type: EnvelopeCreateTypeInitials1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaInitialsTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier3TypedDict]


class EnvelopeCreateFieldInitials(BaseModel):
    type: EnvelopeCreateTypeInitials1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaInitials], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier3] = None


class EnvelopeCreateTypeFreeSignature(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


EnvelopeCreateIdentifier2TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier2TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier2 = TypeAliasType(
    "EnvelopeCreateIdentifier2", Union[str, float]
)


class EnvelopeCreateFieldFreeSignatureTypedDict(TypedDict):
    type: EnvelopeCreateTypeFreeSignature
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    identifier: NotRequired[EnvelopeCreateIdentifier2TypedDict]


class EnvelopeCreateFieldFreeSignature(BaseModel):
    type: EnvelopeCreateTypeFreeSignature

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    identifier: Optional[EnvelopeCreateIdentifier2] = None


class EnvelopeCreateTypeSignature1(str, Enum):
    SIGNATURE = "SIGNATURE"


class EnvelopeCreateTypeSignature2(str, Enum):
    SIGNATURE = "signature"


class EnvelopeCreateFieldMetaSignatureTypedDict(TypedDict):
    type: EnvelopeCreateTypeSignature2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class EnvelopeCreateFieldMetaSignature(BaseModel):
    type: EnvelopeCreateTypeSignature2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12


EnvelopeCreateIdentifier1TypedDict = TypeAliasType(
    "EnvelopeCreateIdentifier1TypedDict", Union[str, float]
)


EnvelopeCreateIdentifier1 = TypeAliasType(
    "EnvelopeCreateIdentifier1", Union[str, float]
)


class EnvelopeCreateFieldSignatureTypedDict(TypedDict):
    type: EnvelopeCreateTypeSignature1
    page: float
    position_x: float
    position_y: float
    width: float
    height: float
    field_meta: NotRequired[EnvelopeCreateFieldMetaSignatureTypedDict]
    identifier: NotRequired[EnvelopeCreateIdentifier1TypedDict]


class EnvelopeCreateFieldSignature(BaseModel):
    type: EnvelopeCreateTypeSignature1

    page: float

    position_x: Annotated[float, pydantic.Field(alias="positionX")]

    position_y: Annotated[float, pydantic.Field(alias="positionY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[EnvelopeCreateFieldMetaSignature], pydantic.Field(alias="fieldMeta")
    ] = None

    identifier: Optional[EnvelopeCreateIdentifier1] = None


EnvelopeCreateFieldUnionTypedDict = TypeAliasType(
    "EnvelopeCreateFieldUnionTypedDict",
    Union[
        EnvelopeCreateFieldFreeSignatureTypedDict,
        EnvelopeCreateFieldSignatureTypedDict,
        EnvelopeCreateFieldInitialsTypedDict,
        EnvelopeCreateFieldNameTypedDict,
        EnvelopeCreateFieldEmailTypedDict,
        EnvelopeCreateFieldDateTypedDict,
        EnvelopeCreateFieldTextTypedDict,
        EnvelopeCreateFieldNumberTypedDict,
        EnvelopeCreateFieldRadioTypedDict,
        EnvelopeCreateFieldCheckboxTypedDict,
        EnvelopeCreateFieldDropdownTypedDict,
    ],
)


EnvelopeCreateFieldUnion = TypeAliasType(
    "EnvelopeCreateFieldUnion",
    Union[
        EnvelopeCreateFieldFreeSignature,
        EnvelopeCreateFieldSignature,
        EnvelopeCreateFieldInitials,
        EnvelopeCreateFieldName,
        EnvelopeCreateFieldEmail,
        EnvelopeCreateFieldDate,
        EnvelopeCreateFieldText,
        EnvelopeCreateFieldNumber,
        EnvelopeCreateFieldRadio,
        EnvelopeCreateFieldCheckbox,
        EnvelopeCreateFieldDropdown,
    ],
)


class EnvelopeCreateRecipientTypedDict(TypedDict):
    email: str
    name: str
    role: EnvelopeCreateRole
    signing_order: NotRequired[float]
    access_auth: NotRequired[List[EnvelopeCreateAccessAuth]]
    action_auth: NotRequired[List[EnvelopeCreateActionAuth]]
    fields: NotRequired[List[EnvelopeCreateFieldUnionTypedDict]]


class EnvelopeCreateRecipient(BaseModel):
    email: str

    name: str

    role: EnvelopeCreateRole

    signing_order: Annotated[Optional[float], pydantic.Field(alias="signingOrder")] = (
        None
    )

    access_auth: Annotated[
        Optional[List[EnvelopeCreateAccessAuth]], pydantic.Field(alias="accessAuth")
    ] = None

    action_auth: Annotated[
        Optional[List[EnvelopeCreateActionAuth]], pydantic.Field(alias="actionAuth")
    ] = None

    fields: Optional[List[EnvelopeCreateFieldUnion]] = None


class EnvelopeCreateDateFormat(str, Enum):
    YYYY_M_MDD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_M_MDD = "yyyy-MM-dd"
    DD_MM_SLASH_YYYY = "dd/MM/yyyy"
    MM_DD_SLASH_YYYY = "MM/dd/yyyy"
    YY_M_MDD = "yy-MM-dd"
    MMMM_DD_COMMA_YYYY = "MMMM dd, yyyy"
    EEEE_MMMM_DD_COMMA_YYYY = "EEEE, MMMM dd, yyyy"
    DD_MM_SLASH_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    DD_MM_SLASH_YYYY_H_HMM = "dd/MM/yyyy HH:mm"
    MM_DD_SLASH_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    MM_DD_SLASH_YYYY_H_HMM = "MM/dd/yyyy HH:mm"
    DD_DOT_MM_DOT_YYYY = "dd.MM.yyyy"
    DD_DOT_MM_DOT_YYYY_H_HMM = "dd.MM.yyyy HH:mm"
    YYYY_M_MDD_H_HMM = "yyyy-MM-dd HH:mm"
    YY_M_MDD_HH_MM_A = "yy-MM-dd hh:mm a"
    YY_M_MDD_H_HMM = "yy-MM-dd HH:mm"
    YYYY_M_MDD_H_HMMSS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_COMMA_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    MMMM_DD_COMMA_YYYY_H_HMM = "MMMM dd, yyyy HH:mm"
    EEEE_MMMM_DD_COMMA_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_COMMA_YYYY_H_HMM = "EEEE, MMMM dd, yyyy HH:mm"
    ISO8601_FULL = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class EnvelopeCreateDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class EnvelopeCreateSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class EnvelopeCreateLanguage(str, Enum):
    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"
    IT = "it"
    PL = "pl"


class EnvelopeCreateEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    recipient_removed: NotRequired[bool]
    recipient_signed: NotRequired[bool]
    document_pending: NotRequired[bool]
    document_completed: NotRequired[bool]
    document_deleted: NotRequired[bool]
    owner_document_completed: NotRequired[bool]


class EnvelopeCreateEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True


class EnvelopeCreateMetaTypedDict(TypedDict):
    subject: NotRequired[str]
    message: NotRequired[str]
    timezone: NotRequired[str]
    date_format: NotRequired[EnvelopeCreateDateFormat]
    distribution_method: NotRequired[EnvelopeCreateDistributionMethod]
    signing_order: NotRequired[EnvelopeCreateSigningOrder]
    allow_dictate_next_signer: NotRequired[bool]
    redirect_url: NotRequired[str]
    language: NotRequired[EnvelopeCreateLanguage]
    typed_signature_enabled: NotRequired[bool]
    upload_signature_enabled: NotRequired[bool]
    draw_signature_enabled: NotRequired[bool]
    email_id: NotRequired[Nullable[str]]
    email_reply_to: NotRequired[Nullable[str]]
    email_settings: NotRequired[Nullable[EnvelopeCreateEmailSettingsTypedDict]]


class EnvelopeCreateMeta(BaseModel):
    subject: Optional[str] = None

    message: Optional[str] = None

    timezone: Optional[str] = None

    date_format: Annotated[
        Optional[EnvelopeCreateDateFormat], pydantic.Field(alias="dateFormat")
    ] = None

    distribution_method: Annotated[
        Optional[EnvelopeCreateDistributionMethod],
        pydantic.Field(alias="distributionMethod"),
    ] = None

    signing_order: Annotated[
        Optional[EnvelopeCreateSigningOrder], pydantic.Field(alias="signingOrder")
    ] = None

    allow_dictate_next_signer: Annotated[
        Optional[bool], pydantic.Field(alias="allowDictateNextSigner")
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None

    language: Optional[EnvelopeCreateLanguage] = None

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None

    upload_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="uploadSignatureEnabled")
    ] = None

    draw_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="drawSignatureEnabled")
    ] = None

    email_id: Annotated[OptionalNullable[str], pydantic.Field(alias="emailId")] = UNSET

    email_reply_to: Annotated[
        OptionalNullable[str], pydantic.Field(alias="emailReplyTo")
    ] = UNSET

    email_settings: Annotated[
        OptionalNullable[EnvelopeCreateEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "subject",
            "message",
            "timezone",
            "dateFormat",
            "distributionMethod",
            "signingOrder",
            "allowDictateNextSigner",
            "redirectUrl",
            "language",
            "typedSignatureEnabled",
            "uploadSignatureEnabled",
            "drawSignatureEnabled",
            "emailId",
            "emailReplyTo",
            "emailSettings",
        ]
        nullable_fields = ["emailId", "emailReplyTo", "emailSettings"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeCreateTypeLink(str, Enum):
    LINK = "link"


class EnvelopeCreateAttachmentTypedDict(TypedDict):
    label: str
    data: str
    type: NotRequired[EnvelopeCreateTypeLink]


class EnvelopeCreateAttachment(BaseModel):
    label: str

    data: str

    type: Optional[EnvelopeCreateTypeLink] = EnvelopeCreateTypeLink.LINK


class EnvelopeCreatePayloadTypedDict(TypedDict):
    title: str
    type: EnvelopeCreateType
    external_id: NotRequired[str]
    visibility: NotRequired[EnvelopeCreateVisibility]
    global_access_auth: NotRequired[List[EnvelopeCreateGlobalAccessAuth]]
    global_action_auth: NotRequired[List[EnvelopeCreateGlobalActionAuth]]
    form_values: NotRequired[Dict[str, EnvelopeCreateFormValuesTypedDict]]
    folder_id: NotRequired[str]
    recipients: NotRequired[List[EnvelopeCreateRecipientTypedDict]]
    meta: NotRequired[EnvelopeCreateMetaTypedDict]
    attachments: NotRequired[List[EnvelopeCreateAttachmentTypedDict]]


class EnvelopeCreatePayload(BaseModel):
    title: str

    type: EnvelopeCreateType

    external_id: Annotated[Optional[str], pydantic.Field(alias="externalId")] = None

    visibility: Optional[EnvelopeCreateVisibility] = None

    global_access_auth: Annotated[
        Optional[List[EnvelopeCreateGlobalAccessAuth]],
        pydantic.Field(alias="globalAccessAuth"),
    ] = None

    global_action_auth: Annotated[
        Optional[List[EnvelopeCreateGlobalActionAuth]],
        pydantic.Field(alias="globalActionAuth"),
    ] = None

    form_values: Annotated[
        Optional[Dict[str, EnvelopeCreateFormValues]],
        pydantic.Field(alias="formValues"),
    ] = None

    folder_id: Annotated[Optional[str], pydantic.Field(alias="folderId")] = None

    recipients: Optional[List[EnvelopeCreateRecipient]] = None

    meta: Optional[EnvelopeCreateMeta] = None

    attachments: Optional[List[EnvelopeCreateAttachment]] = None


class EnvelopeCreateFileTypedDict(TypedDict):
    file_name: str
    content: Union[bytes, IO[bytes], io.BufferedReader]
    content_type: NotRequired[str]


class EnvelopeCreateFile(BaseModel):
    file_name: Annotated[
        str, pydantic.Field(alias="fileName"), FieldMetadata(multipart=True)
    ]

    content: Annotated[
        Union[bytes, IO[bytes], io.BufferedReader],
        pydantic.Field(alias=""),
        FieldMetadata(multipart=MultipartFormMetadata(content=True)),
    ]

    content_type: Annotated[
        Optional[str],
        pydantic.Field(alias="Content-Type"),
        FieldMetadata(multipart=True),
    ] = None


class EnvelopeCreateRequestTypedDict(TypedDict):
    payload: EnvelopeCreatePayloadTypedDict
    files: NotRequired[List[EnvelopeCreateFileTypedDict]]


class EnvelopeCreateRequest(BaseModel):
    payload: Annotated[
        EnvelopeCreatePayload, FieldMetadata(multipart=MultipartFormMetadata(json=True))
    ]

    files: Annotated[
        Optional[List[EnvelopeCreateFile]],
        FieldMetadata(multipart=MultipartFormMetadata(file=True)),
    ] = None


class EnvelopeCreateInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class EnvelopeCreateInternalServerErrorIssue(BaseModel):
    message: str


class EnvelopeCreateInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeCreateInternalServerErrorIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeCreateInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: EnvelopeCreateInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeCreateInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeCreateForbiddenIssueTypedDict(TypedDict):
    message: str


class EnvelopeCreateForbiddenIssue(BaseModel):
    message: str


class EnvelopeCreateForbiddenErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeCreateForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeCreateForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: EnvelopeCreateForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeCreateForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeCreateUnauthorizedIssueTypedDict(TypedDict):
    message: str


class EnvelopeCreateUnauthorizedIssue(BaseModel):
    message: str


class EnvelopeCreateUnauthorizedErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeCreateUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeCreateUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: EnvelopeCreateUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeCreateUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeCreateBadRequestIssueTypedDict(TypedDict):
    message: str


class EnvelopeCreateBadRequestIssue(BaseModel):
    message: str


class EnvelopeCreateBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeCreateBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeCreateBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: EnvelopeCreateBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeCreateBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeCreateResponseTypedDict(TypedDict):
    r"""Successful response"""

    id: str


class EnvelopeCreateResponse(BaseModel):
    r"""Successful response"""

    id: str
