"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import BaseModel
from documenso_sdk.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
from enum import Enum
import httpx
import pydantic
from typing import Any, Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class DocumentDownloadVersion(str, Enum):
    r"""The version of the document to download. \"signed\" returns the completed document with signatures, \"original\" returns the original uploaded document."""

    ORIGINAL = "original"
    SIGNED = "signed"


class DocumentDownloadRequestTypedDict(TypedDict):
    document_id: float
    r"""The ID of the document to download."""
    version: NotRequired[DocumentDownloadVersion]
    r"""The version of the document to download. \"signed\" returns the completed document with signatures, \"original\" returns the original uploaded document."""


class DocumentDownloadRequest(BaseModel):
    document_id: Annotated[
        float,
        pydantic.Field(alias="documentId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The ID of the document to download."""

    version: Annotated[
        Optional[DocumentDownloadVersion],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = DocumentDownloadVersion.SIGNED
    r"""The version of the document to download. \"signed\" returns the completed document with signatures, \"original\" returns the original uploaded document."""


class DocumentDownloadInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class DocumentDownloadInternalServerErrorIssue(BaseModel):
    message: str


class DocumentDownloadInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentDownloadInternalServerErrorIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentDownloadInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: DocumentDownloadInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentDownloadInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentDownloadNotFoundIssueTypedDict(TypedDict):
    message: str


class DocumentDownloadNotFoundIssue(BaseModel):
    message: str


class DocumentDownloadNotFoundErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentDownloadNotFoundIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentDownloadNotFoundError(DocumensoError):
    r"""Not found"""

    data: DocumentDownloadNotFoundErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentDownloadNotFoundErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentDownloadForbiddenIssueTypedDict(TypedDict):
    message: str


class DocumentDownloadForbiddenIssue(BaseModel):
    message: str


class DocumentDownloadForbiddenErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentDownloadForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentDownloadForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: DocumentDownloadForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentDownloadForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentDownloadUnauthorizedIssueTypedDict(TypedDict):
    message: str


class DocumentDownloadUnauthorizedIssue(BaseModel):
    message: str


class DocumentDownloadUnauthorizedErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentDownloadUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentDownloadUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: DocumentDownloadUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentDownloadUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentDownloadBadRequestIssueTypedDict(TypedDict):
    message: str


class DocumentDownloadBadRequestIssue(BaseModel):
    message: str


class DocumentDownloadBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentDownloadBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentDownloadBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: DocumentDownloadBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentDownloadBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentDownloadResponseTypedDict(TypedDict):
    headers: Dict[str, List[str]]
    result: Any


class DocumentDownloadResponse(BaseModel):
    headers: Dict[str, List[str]]

    result: Any
