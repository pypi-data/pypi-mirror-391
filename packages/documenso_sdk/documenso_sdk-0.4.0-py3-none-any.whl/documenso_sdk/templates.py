"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .sdkconfiguration import SDKConfiguration
from documenso_sdk import models, utils
from documenso_sdk._hooks import HookContext
from documenso_sdk.directlink_sdk import DirectLinkSDK
from documenso_sdk.templates_fields import TemplatesFields
from documenso_sdk.templates_recipients import TemplatesRecipients
from documenso_sdk.types import OptionalNullable, UNSET
from documenso_sdk.utils import get_security_from_env
from documenso_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, List, Mapping, Optional, Union


class Templates(BaseSDK):
    fields: TemplatesFields
    recipients: TemplatesRecipients
    direct_link: DirectLinkSDK

    def __init__(
        self, sdk_config: SDKConfiguration, parent_ref: Optional[object] = None
    ) -> None:
        BaseSDK.__init__(self, sdk_config, parent_ref=parent_ref)
        self.sdk_configuration = sdk_config
        self._init_sdks()

    def _init_sdks(self):
        self.fields = TemplatesFields(
            self.sdk_configuration, parent_ref=self.parent_ref
        )
        self.recipients = TemplatesRecipients(
            self.sdk_configuration, parent_ref=self.parent_ref
        )
        self.direct_link = DirectLinkSDK(
            self.sdk_configuration, parent_ref=self.parent_ref
        )

    def find(
        self,
        *,
        query: Optional[str] = None,
        page: Optional[float] = None,
        per_page: Optional[float] = None,
        type_: Optional[models.TemplateFindTemplatesQueryParamType] = None,
        folder_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateFindTemplatesResponse:
        r"""Find templates

        Find templates based on a search criteria

        :param query: The search query.
        :param page: The pagination page number, starts at 1.
        :param per_page: The number of items per page.
        :param type: Filter templates by type.
        :param folder_id: The ID of the folder to filter templates by.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateFindTemplatesRequest(
            query=query,
            page=page,
            per_page=per_page,
            type=type_,
            folder_id=folder_id,
        )

        req = self._build_request(
            method="GET",
            path="/template",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-findTemplates",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateFindTemplatesResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesBadRequestErrorData, http_res
            )
            raise models.TemplateFindTemplatesBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesUnauthorizedErrorData, http_res
            )
            raise models.TemplateFindTemplatesUnauthorizedError(response_data, http_res)
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesForbiddenErrorData, http_res
            )
            raise models.TemplateFindTemplatesForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesNotFoundErrorData, http_res
            )
            raise models.TemplateFindTemplatesNotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesInternalServerErrorData, http_res
            )
            raise models.TemplateFindTemplatesInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def find_async(
        self,
        *,
        query: Optional[str] = None,
        page: Optional[float] = None,
        per_page: Optional[float] = None,
        type_: Optional[models.TemplateFindTemplatesQueryParamType] = None,
        folder_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateFindTemplatesResponse:
        r"""Find templates

        Find templates based on a search criteria

        :param query: The search query.
        :param page: The pagination page number, starts at 1.
        :param per_page: The number of items per page.
        :param type: Filter templates by type.
        :param folder_id: The ID of the folder to filter templates by.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateFindTemplatesRequest(
            query=query,
            page=page,
            per_page=per_page,
            type=type_,
            folder_id=folder_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/template",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-findTemplates",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateFindTemplatesResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesBadRequestErrorData, http_res
            )
            raise models.TemplateFindTemplatesBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesUnauthorizedErrorData, http_res
            )
            raise models.TemplateFindTemplatesUnauthorizedError(response_data, http_res)
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesForbiddenErrorData, http_res
            )
            raise models.TemplateFindTemplatesForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesNotFoundErrorData, http_res
            )
            raise models.TemplateFindTemplatesNotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateFindTemplatesInternalServerErrorData, http_res
            )
            raise models.TemplateFindTemplatesInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def get(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateGetTemplateByIDResponse:
        r"""Get template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateGetTemplateByIDRequest(
            template_id=template_id,
        )

        req = self._build_request(
            method="GET",
            path="/template/{templateId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-getTemplateById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateGetTemplateByIDResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDBadRequestErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDUnauthorizedErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDForbiddenErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDNotFoundErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDNotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDInternalServerErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def get_async(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateGetTemplateByIDResponse:
        r"""Get template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateGetTemplateByIDRequest(
            template_id=template_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/template/{templateId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-getTemplateById",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "404", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateGetTemplateByIDResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDBadRequestErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDUnauthorizedErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDForbiddenErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "404", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDNotFoundErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDNotFoundError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateGetTemplateByIDInternalServerErrorData, http_res
            )
            raise models.TemplateGetTemplateByIDInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def create(
        self,
        *,
        payload: Union[
            models.TemplateCreateTemplatePayload,
            models.TemplateCreateTemplatePayloadTypedDict,
        ],
        file: Union[
            models.TemplateCreateTemplateFile,
            models.TemplateCreateTemplateFileTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateCreateTemplateResponse:
        r"""Create template

        Create a new template

        :param payload:
        :param file:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateCreateTemplateRequest(
            payload=utils.get_pydantic_model(
                payload, models.TemplateCreateTemplatePayload
            ),
            file=utils.get_pydantic_model(file, models.TemplateCreateTemplateFile),
        )

        req = self._build_request(
            method="POST",
            path="/template/create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.TemplateCreateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-createTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateCreateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateCreateTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateCreateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateCreateTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateCreateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def create_async(
        self,
        *,
        payload: Union[
            models.TemplateCreateTemplatePayload,
            models.TemplateCreateTemplatePayloadTypedDict,
        ],
        file: Union[
            models.TemplateCreateTemplateFile,
            models.TemplateCreateTemplateFileTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateCreateTemplateResponse:
        r"""Create template

        Create a new template

        :param payload:
        :param file:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateCreateTemplateRequest(
            payload=utils.get_pydantic_model(
                payload, models.TemplateCreateTemplatePayload
            ),
            file=utils.get_pydantic_model(file, models.TemplateCreateTemplateFile),
        )

        req = self._build_request_async(
            method="POST",
            path="/template/create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "multipart", models.TemplateCreateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-createTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateCreateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateCreateTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateCreateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateCreateTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateCreateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def update(
        self,
        *,
        template_id: float,
        data: Optional[
            Union[
                models.TemplateUpdateTemplateData,
                models.TemplateUpdateTemplateDataTypedDict,
            ]
        ] = None,
        meta: Optional[
            Union[
                models.TemplateUpdateTemplateMeta,
                models.TemplateUpdateTemplateMetaTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateUpdateTemplateResponse:
        r"""Update template

        :param template_id:
        :param data:
        :param meta:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateUpdateTemplateRequest(
            template_id=template_id,
            data=utils.get_pydantic_model(
                data, Optional[models.TemplateUpdateTemplateData]
            ),
            meta=utils.get_pydantic_model(
                meta, Optional[models.TemplateUpdateTemplateMeta]
            ),
        )

        req = self._build_request(
            method="POST",
            path="/template/update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateUpdateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-updateTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateUpdateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateUpdateTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateUpdateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateUpdateTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateUpdateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def update_async(
        self,
        *,
        template_id: float,
        data: Optional[
            Union[
                models.TemplateUpdateTemplateData,
                models.TemplateUpdateTemplateDataTypedDict,
            ]
        ] = None,
        meta: Optional[
            Union[
                models.TemplateUpdateTemplateMeta,
                models.TemplateUpdateTemplateMetaTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateUpdateTemplateResponse:
        r"""Update template

        :param template_id:
        :param data:
        :param meta:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateUpdateTemplateRequest(
            template_id=template_id,
            data=utils.get_pydantic_model(
                data, Optional[models.TemplateUpdateTemplateData]
            ),
            meta=utils.get_pydantic_model(
                meta, Optional[models.TemplateUpdateTemplateMeta]
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/template/update",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateUpdateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-updateTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateUpdateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateUpdateTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateUpdateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateUpdateTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateUpdateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateUpdateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def duplicate(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateDuplicateTemplateResponse:
        r"""Duplicate template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateDuplicateTemplateRequest(
            template_id=template_id,
        )

        req = self._build_request(
            method="POST",
            path="/template/duplicate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateDuplicateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-duplicateTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateDuplicateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateBadRequestError(
                response_data, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateForbiddenError(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def duplicate_async(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateDuplicateTemplateResponse:
        r"""Duplicate template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateDuplicateTemplateRequest(
            template_id=template_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/template/duplicate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateDuplicateTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-duplicateTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateDuplicateTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateBadRequestError(
                response_data, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateForbiddenError(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDuplicateTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateDuplicateTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateDeleteTemplateResponse:
        r"""Delete template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateDeleteTemplateRequest(
            template_id=template_id,
        )

        req = self._build_request(
            method="POST",
            path="/template/delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateDeleteTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-deleteTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateDeleteTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateDeleteTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateDeleteTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateDeleteTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateDeleteTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def delete_async(
        self,
        *,
        template_id: float,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateDeleteTemplateResponse:
        r"""Delete template

        :param template_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateDeleteTemplateRequest(
            template_id=template_id,
        )

        req = self._build_request_async(
            method="POST",
            path="/template/delete",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, False, "json", models.TemplateDeleteTemplateRequest
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-deleteTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateDeleteTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateDeleteTemplateBadRequestError(response_data, http_res)
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateDeleteTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateDeleteTemplateForbiddenError(response_data, http_res)
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateDeleteTemplateInternalServerErrorData, http_res
            )
            raise models.TemplateDeleteTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    def use(
        self,
        *,
        template_id: float,
        recipients: Union[
            List[models.TemplateCreateDocumentFromTemplateRecipientRequest],
            List[models.TemplateCreateDocumentFromTemplateRecipientRequestTypedDict],
        ],
        distribute_document: Optional[bool] = None,
        custom_document_data_id: Optional[str] = None,
        custom_document_data: Optional[
            Union[
                List[models.TemplateCreateDocumentFromTemplateCustomDocumentDatum],
                List[
                    models.TemplateCreateDocumentFromTemplateCustomDocumentDatumTypedDict
                ],
            ]
        ] = None,
        folder_id: Optional[str] = None,
        prefill_fields: Optional[
            Union[
                List[models.TemplateCreateDocumentFromTemplatePrefillFieldUnion],
                List[
                    models.TemplateCreateDocumentFromTemplatePrefillFieldUnionTypedDict
                ],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateCreateDocumentFromTemplateResponse:
        r"""Use template

        Use the template to create a document

        :param template_id:
        :param recipients:
        :param distribute_document:
        :param custom_document_data_id:
        :param custom_document_data:
        :param folder_id:
        :param prefill_fields:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateCreateDocumentFromTemplateRequest(
            template_id=template_id,
            recipients=utils.get_pydantic_model(
                recipients,
                List[models.TemplateCreateDocumentFromTemplateRecipientRequest],
            ),
            distribute_document=distribute_document,
            custom_document_data_id=custom_document_data_id,
            custom_document_data=utils.get_pydantic_model(
                custom_document_data,
                Optional[
                    List[models.TemplateCreateDocumentFromTemplateCustomDocumentDatum]
                ],
            ),
            folder_id=folder_id,
            prefill_fields=utils.get_pydantic_model(
                prefill_fields,
                Optional[
                    List[models.TemplateCreateDocumentFromTemplatePrefillFieldUnion]
                ],
            ),
        )

        req = self._build_request(
            method="POST",
            path="/template/use",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.TemplateCreateDocumentFromTemplateRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-createDocumentFromTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateBadRequestError(
                response_data, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateForbiddenError(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateInternalServerErrorData,
                http_res,
            )
            raise models.TemplateCreateDocumentFromTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)

    async def use_async(
        self,
        *,
        template_id: float,
        recipients: Union[
            List[models.TemplateCreateDocumentFromTemplateRecipientRequest],
            List[models.TemplateCreateDocumentFromTemplateRecipientRequestTypedDict],
        ],
        distribute_document: Optional[bool] = None,
        custom_document_data_id: Optional[str] = None,
        custom_document_data: Optional[
            Union[
                List[models.TemplateCreateDocumentFromTemplateCustomDocumentDatum],
                List[
                    models.TemplateCreateDocumentFromTemplateCustomDocumentDatumTypedDict
                ],
            ]
        ] = None,
        folder_id: Optional[str] = None,
        prefill_fields: Optional[
            Union[
                List[models.TemplateCreateDocumentFromTemplatePrefillFieldUnion],
                List[
                    models.TemplateCreateDocumentFromTemplatePrefillFieldUnionTypedDict
                ],
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TemplateCreateDocumentFromTemplateResponse:
        r"""Use template

        Use the template to create a document

        :param template_id:
        :param recipients:
        :param distribute_document:
        :param custom_document_data_id:
        :param custom_document_data:
        :param folder_id:
        :param prefill_fields:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TemplateCreateDocumentFromTemplateRequest(
            template_id=template_id,
            recipients=utils.get_pydantic_model(
                recipients,
                List[models.TemplateCreateDocumentFromTemplateRecipientRequest],
            ),
            distribute_document=distribute_document,
            custom_document_data_id=custom_document_data_id,
            custom_document_data=utils.get_pydantic_model(
                custom_document_data,
                Optional[
                    List[models.TemplateCreateDocumentFromTemplateCustomDocumentDatum]
                ],
            ),
            folder_id=folder_id,
            prefill_fields=utils.get_pydantic_model(
                prefill_fields,
                Optional[
                    List[models.TemplateCreateDocumentFromTemplatePrefillFieldUnion]
                ],
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/template/use",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                models.TemplateCreateDocumentFromTemplateRequest,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="template-createDocumentFromTemplate",
                oauth2_scopes=None,
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["400", "401", "403", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateResponse, http_res
            )
        if utils.match_response(http_res, "400", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateBadRequestErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateBadRequestError(
                response_data, http_res
            )
        if utils.match_response(http_res, "401", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateUnauthorizedErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateUnauthorizedError(
                response_data, http_res
            )
        if utils.match_response(http_res, "403", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateForbiddenErrorData, http_res
            )
            raise models.TemplateCreateDocumentFromTemplateForbiddenError(
                response_data, http_res
            )
        if utils.match_response(http_res, "500", "application/json"):
            response_data = unmarshal_json_response(
                models.TemplateCreateDocumentFromTemplateInternalServerErrorData,
                http_res,
            )
            raise models.TemplateCreateDocumentFromTemplateInternalServerError(
                response_data, http_res
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.APIError("API error occurred", http_res, http_res_text)

        raise models.APIError("Unexpected response received", http_res)
