"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
import httpx
import pydantic
from pydantic import model_serializer
from typing import Any, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EnvelopeFieldUpdateManyTypeDropdownRequest1(str, Enum):
    DROPDOWN = "DROPDOWN"


class EnvelopeFieldUpdateManyTypeDropdownRequest2(str, Enum):
    DROPDOWN = "dropdown"


class EnvelopeFieldUpdateManyValueDropdownTypedDict(TypedDict):
    value: str


class EnvelopeFieldUpdateManyValueDropdown(BaseModel):
    value: str


class EnvelopeFieldUpdateManyFieldMetaDropdownRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeDropdownRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueDropdownTypedDict]]
    default_value: NotRequired[str]


class EnvelopeFieldUpdateManyFieldMetaDropdownRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeDropdownRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueDropdown]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class EnvelopeFieldUpdateManyDataDropdownTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeDropdownRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaDropdownRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataDropdown(BaseModel):
    type: EnvelopeFieldUpdateManyTypeDropdownRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaDropdownRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeCheckboxRequest1(str, Enum):
    CHECKBOX = "CHECKBOX"


class EnvelopeFieldUpdateManyTypeCheckboxRequest2(str, Enum):
    CHECKBOX = "checkbox"


class EnvelopeFieldUpdateManyValueCheckboxTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeFieldUpdateManyValueCheckbox(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeFieldUpdateManyDirectionCheckbox(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeFieldUpdateManyFieldMetaCheckboxRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeCheckboxRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueCheckboxTypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]
    direction: NotRequired[EnvelopeFieldUpdateManyDirectionCheckbox]


class EnvelopeFieldUpdateManyFieldMetaCheckboxRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeCheckboxRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueCheckbox]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None

    direction: Optional[EnvelopeFieldUpdateManyDirectionCheckbox] = (
        EnvelopeFieldUpdateManyDirectionCheckbox.VERTICAL
    )


class EnvelopeFieldUpdateManyDataCheckboxTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeCheckboxRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaCheckboxRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataCheckbox(BaseModel):
    type: EnvelopeFieldUpdateManyTypeCheckboxRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaCheckboxRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeRadioRequest1(str, Enum):
    RADIO = "RADIO"


class EnvelopeFieldUpdateManyTypeRadioRequest2(str, Enum):
    RADIO = "radio"


class EnvelopeFieldUpdateManyValueRadioTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeFieldUpdateManyValueRadio(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeFieldUpdateManyDirectionRadio(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeFieldUpdateManyFieldMetaRadioRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeRadioRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueRadioTypedDict]]
    direction: NotRequired[EnvelopeFieldUpdateManyDirectionRadio]


class EnvelopeFieldUpdateManyFieldMetaRadioRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeRadioRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueRadio]] = None

    direction: Optional[EnvelopeFieldUpdateManyDirectionRadio] = (
        EnvelopeFieldUpdateManyDirectionRadio.VERTICAL
    )


class EnvelopeFieldUpdateManyDataRadioTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeRadioRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaRadioRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataRadio(BaseModel):
    type: EnvelopeFieldUpdateManyTypeRadioRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaRadioRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeNumberRequest1(str, Enum):
    NUMBER = "NUMBER"


class EnvelopeFieldUpdateManyTypeNumberRequest2(str, Enum):
    NUMBER = "number"


class EnvelopeFieldUpdateManyTextAlignNumber(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyVerticalAlignNumber(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeFieldUpdateManyFieldMetaNumberRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeNumberRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    number_format: NotRequired[Nullable[str]]
    value: NotRequired[str]
    min_value: NotRequired[Nullable[float]]
    max_value: NotRequired[Nullable[float]]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignNumber]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeFieldUpdateManyVerticalAlignNumber]]


class EnvelopeFieldUpdateManyFieldMetaNumberRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeNumberRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    number_format: Annotated[
        OptionalNullable[str], pydantic.Field(alias="numberFormat")
    ] = UNSET

    value: Optional[str] = None

    min_value: Annotated[OptionalNullable[float], pydantic.Field(alias="minValue")] = (
        UNSET
    )

    max_value: Annotated[OptionalNullable[float], pydantic.Field(alias="maxValue")] = (
        UNSET
    )

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignNumber],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeFieldUpdateManyVerticalAlignNumber],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "numberFormat",
            "value",
            "minValue",
            "maxValue",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = [
            "numberFormat",
            "minValue",
            "maxValue",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeFieldUpdateManyDataNumberTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeNumberRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaNumberRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataNumber(BaseModel):
    type: EnvelopeFieldUpdateManyTypeNumberRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaNumberRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeTextRequest1(str, Enum):
    TEXT = "TEXT"


class EnvelopeFieldUpdateManyTypeTextRequest2(str, Enum):
    TEXT = "text"


class EnvelopeFieldUpdateManyTextAlignText(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyVerticalAlignText(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeFieldUpdateManyFieldMetaTextRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeTextRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignText]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeFieldUpdateManyVerticalAlignText]]


class EnvelopeFieldUpdateManyFieldMetaTextRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeTextRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignText],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeFieldUpdateManyVerticalAlignText],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "text",
            "characterLimit",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = ["lineHeight", "letterSpacing", "verticalAlign"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeFieldUpdateManyDataTextTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeTextRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaTextRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataText(BaseModel):
    type: EnvelopeFieldUpdateManyTypeTextRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaTextRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeDateRequest1(str, Enum):
    DATE = "DATE"


class EnvelopeFieldUpdateManyTypeDateRequest2(str, Enum):
    DATE = "date"


class EnvelopeFieldUpdateManyTextAlignDate(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaDateRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeDateRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignDate]


class EnvelopeFieldUpdateManyFieldMetaDateRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeDateRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignDate],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyDataDateTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeDateRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaDateRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataDate(BaseModel):
    type: EnvelopeFieldUpdateManyTypeDateRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaDateRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeEmailRequest1(str, Enum):
    EMAIL = "EMAIL"


class EnvelopeFieldUpdateManyTypeEmailRequest2(str, Enum):
    EMAIL = "email"


class EnvelopeFieldUpdateManyTextAlignEmail(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaEmailRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeEmailRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignEmail]


class EnvelopeFieldUpdateManyFieldMetaEmailRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeEmailRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignEmail],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyDataEmailTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeEmailRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaEmailRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataEmail(BaseModel):
    type: EnvelopeFieldUpdateManyTypeEmailRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaEmailRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeNameRequest1(str, Enum):
    NAME = "NAME"


class EnvelopeFieldUpdateManyTypeNameRequest2(str, Enum):
    NAME = "name"


class EnvelopeFieldUpdateManyTextAlignName(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaNameRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeNameRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignName]


class EnvelopeFieldUpdateManyFieldMetaNameRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeNameRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignName],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyDataNameTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeNameRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaNameRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataName(BaseModel):
    type: EnvelopeFieldUpdateManyTypeNameRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaNameRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeInitialsRequest1(str, Enum):
    INITIALS = "INITIALS"


class EnvelopeFieldUpdateManyTypeInitialsRequest2(str, Enum):
    INITIALS = "initials"


class EnvelopeFieldUpdateManyTextAlignInitials(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaInitialsRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeInitialsRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignInitials]


class EnvelopeFieldUpdateManyFieldMetaInitialsRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeInitialsRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignInitials],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyDataInitialsTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeInitialsRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaInitialsRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataInitials(BaseModel):
    type: EnvelopeFieldUpdateManyTypeInitialsRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaInitialsRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeFreeSignature(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class EnvelopeFieldUpdateManyDataFreeSignatureTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeFreeSignature
    id: float
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataFreeSignature(BaseModel):
    type: EnvelopeFieldUpdateManyTypeFreeSignature

    id: float

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


class EnvelopeFieldUpdateManyTypeSignatureRequest1(str, Enum):
    SIGNATURE = "SIGNATURE"


class EnvelopeFieldUpdateManyTypeSignatureRequest2(str, Enum):
    SIGNATURE = "signature"


class EnvelopeFieldUpdateManyFieldMetaSignatureRequestTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeSignatureRequest2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class EnvelopeFieldUpdateManyFieldMetaSignatureRequest(BaseModel):
    type: EnvelopeFieldUpdateManyTypeSignatureRequest2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12


class EnvelopeFieldUpdateManyDataSignatureTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyTypeSignatureRequest1
    id: float
    field_meta: NotRequired[EnvelopeFieldUpdateManyFieldMetaSignatureRequestTypedDict]
    envelope_item_id: NotRequired[str]
    page: NotRequired[float]
    position_x: NotRequired[float]
    position_y: NotRequired[float]
    width: NotRequired[float]
    height: NotRequired[float]


class EnvelopeFieldUpdateManyDataSignature(BaseModel):
    type: EnvelopeFieldUpdateManyTypeSignatureRequest1

    id: float

    field_meta: Annotated[
        Optional[EnvelopeFieldUpdateManyFieldMetaSignatureRequest],
        pydantic.Field(alias="fieldMeta"),
    ] = None

    envelope_item_id: Annotated[
        Optional[str], pydantic.Field(alias="envelopeItemId")
    ] = None

    page: Optional[float] = None

    position_x: Annotated[Optional[float], pydantic.Field(alias="positionX")] = None

    position_y: Annotated[Optional[float], pydantic.Field(alias="positionY")] = None

    width: Optional[float] = None

    height: Optional[float] = None


EnvelopeFieldUpdateManyDataUnionTypedDict = TypeAliasType(
    "EnvelopeFieldUpdateManyDataUnionTypedDict",
    Union[
        EnvelopeFieldUpdateManyDataFreeSignatureTypedDict,
        EnvelopeFieldUpdateManyDataSignatureTypedDict,
        EnvelopeFieldUpdateManyDataInitialsTypedDict,
        EnvelopeFieldUpdateManyDataNameTypedDict,
        EnvelopeFieldUpdateManyDataEmailTypedDict,
        EnvelopeFieldUpdateManyDataDateTypedDict,
        EnvelopeFieldUpdateManyDataTextTypedDict,
        EnvelopeFieldUpdateManyDataNumberTypedDict,
        EnvelopeFieldUpdateManyDataRadioTypedDict,
        EnvelopeFieldUpdateManyDataCheckboxTypedDict,
        EnvelopeFieldUpdateManyDataDropdownTypedDict,
    ],
)


EnvelopeFieldUpdateManyDataUnion = TypeAliasType(
    "EnvelopeFieldUpdateManyDataUnion",
    Union[
        EnvelopeFieldUpdateManyDataFreeSignature,
        EnvelopeFieldUpdateManyDataSignature,
        EnvelopeFieldUpdateManyDataInitials,
        EnvelopeFieldUpdateManyDataName,
        EnvelopeFieldUpdateManyDataEmail,
        EnvelopeFieldUpdateManyDataDate,
        EnvelopeFieldUpdateManyDataText,
        EnvelopeFieldUpdateManyDataNumber,
        EnvelopeFieldUpdateManyDataRadio,
        EnvelopeFieldUpdateManyDataCheckbox,
        EnvelopeFieldUpdateManyDataDropdown,
    ],
)


class EnvelopeFieldUpdateManyRequestTypedDict(TypedDict):
    envelope_id: str
    data: List[EnvelopeFieldUpdateManyDataUnionTypedDict]


class EnvelopeFieldUpdateManyRequest(BaseModel):
    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    data: List[EnvelopeFieldUpdateManyDataUnion]


class EnvelopeFieldUpdateManyInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class EnvelopeFieldUpdateManyInternalServerErrorIssue(BaseModel):
    message: str


class EnvelopeFieldUpdateManyInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeFieldUpdateManyInternalServerErrorIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeFieldUpdateManyInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: EnvelopeFieldUpdateManyInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeFieldUpdateManyInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeFieldUpdateManyForbiddenIssueTypedDict(TypedDict):
    message: str


class EnvelopeFieldUpdateManyForbiddenIssue(BaseModel):
    message: str


class EnvelopeFieldUpdateManyForbiddenErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeFieldUpdateManyForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeFieldUpdateManyForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: EnvelopeFieldUpdateManyForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeFieldUpdateManyForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeFieldUpdateManyUnauthorizedIssueTypedDict(TypedDict):
    message: str


class EnvelopeFieldUpdateManyUnauthorizedIssue(BaseModel):
    message: str


class EnvelopeFieldUpdateManyUnauthorizedErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeFieldUpdateManyUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeFieldUpdateManyUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: EnvelopeFieldUpdateManyUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeFieldUpdateManyUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeFieldUpdateManyBadRequestIssueTypedDict(TypedDict):
    message: str


class EnvelopeFieldUpdateManyBadRequestIssue(BaseModel):
    message: str


class EnvelopeFieldUpdateManyBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeFieldUpdateManyBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeFieldUpdateManyBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: EnvelopeFieldUpdateManyBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeFieldUpdateManyBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeFieldUpdateManyTypeResponse(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class EnvelopeFieldUpdateManyFieldMetaTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class EnvelopeFieldUpdateManyValueResponse3TypedDict(TypedDict):
    value: str


class EnvelopeFieldUpdateManyValueResponse3(BaseModel):
    value: str


class EnvelopeFieldUpdateManyFieldMetaDropdownResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueResponse3TypedDict]]
    default_value: NotRequired[str]


class EnvelopeFieldUpdateManyFieldMetaDropdownResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueResponse3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class EnvelopeFieldUpdateManyFieldMetaTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class EnvelopeFieldUpdateManyValueResponse2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeFieldUpdateManyValueResponse2(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeFieldUpdateManyDirectionResponse2(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeFieldUpdateManyFieldMetaCheckboxResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueResponse2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]
    direction: NotRequired[EnvelopeFieldUpdateManyDirectionResponse2]


class EnvelopeFieldUpdateManyFieldMetaCheckboxResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueResponse2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None

    direction: Optional[EnvelopeFieldUpdateManyDirectionResponse2] = (
        EnvelopeFieldUpdateManyDirectionResponse2.VERTICAL
    )


class EnvelopeFieldUpdateManyFieldMetaTypeRadio(str, Enum):
    RADIO = "radio"


class EnvelopeFieldUpdateManyValueResponse1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class EnvelopeFieldUpdateManyValueResponse1(BaseModel):
    id: float

    checked: bool

    value: str


class EnvelopeFieldUpdateManyDirectionResponse1(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class EnvelopeFieldUpdateManyFieldMetaRadioResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[EnvelopeFieldUpdateManyValueResponse1TypedDict]]
    direction: NotRequired[EnvelopeFieldUpdateManyDirectionResponse1]


class EnvelopeFieldUpdateManyFieldMetaRadioResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[EnvelopeFieldUpdateManyValueResponse1]] = None

    direction: Optional[EnvelopeFieldUpdateManyDirectionResponse1] = (
        EnvelopeFieldUpdateManyDirectionResponse1.VERTICAL
    )


class EnvelopeFieldUpdateManyFieldMetaTypeNumber(str, Enum):
    NUMBER = "number"


class EnvelopeFieldUpdateManyTextAlignResponse6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyVerticalAlignResponse2(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeFieldUpdateManyFieldMetaNumberResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    number_format: NotRequired[Nullable[str]]
    value: NotRequired[str]
    min_value: NotRequired[Nullable[float]]
    max_value: NotRequired[Nullable[float]]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse6]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeFieldUpdateManyVerticalAlignResponse2]]


class EnvelopeFieldUpdateManyFieldMetaNumberResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    number_format: Annotated[
        OptionalNullable[str], pydantic.Field(alias="numberFormat")
    ] = UNSET

    value: Optional[str] = None

    min_value: Annotated[OptionalNullable[float], pydantic.Field(alias="minValue")] = (
        UNSET
    )

    max_value: Annotated[OptionalNullable[float], pydantic.Field(alias="maxValue")] = (
        UNSET
    )

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse6],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeFieldUpdateManyVerticalAlignResponse2],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "numberFormat",
            "value",
            "minValue",
            "maxValue",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = [
            "numberFormat",
            "minValue",
            "maxValue",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeFieldUpdateManyFieldMetaTypeText(str, Enum):
    TEXT = "text"


class EnvelopeFieldUpdateManyTextAlignResponse5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyVerticalAlignResponse1(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class EnvelopeFieldUpdateManyFieldMetaTextResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse5]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[EnvelopeFieldUpdateManyVerticalAlignResponse1]]


class EnvelopeFieldUpdateManyFieldMetaTextResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse5],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[EnvelopeFieldUpdateManyVerticalAlignResponse1],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "text",
            "characterLimit",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = ["lineHeight", "letterSpacing", "verticalAlign"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeFieldUpdateManyFieldMetaTypeDate(str, Enum):
    DATE = "date"


class EnvelopeFieldUpdateManyTextAlignResponse4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaDateResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse4]


class EnvelopeFieldUpdateManyFieldMetaDateResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse4],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyFieldMetaTypeEmail(str, Enum):
    EMAIL = "email"


class EnvelopeFieldUpdateManyTextAlignResponse3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaEmailResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse3]


class EnvelopeFieldUpdateManyFieldMetaEmailResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse3],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyFieldMetaTypeName(str, Enum):
    NAME = "name"


class EnvelopeFieldUpdateManyTextAlignResponse2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaNameResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse2]


class EnvelopeFieldUpdateManyFieldMetaNameResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse2],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyFieldMetaTypeInitials(str, Enum):
    INITIALS = "initials"


class EnvelopeFieldUpdateManyTextAlignResponse1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class EnvelopeFieldUpdateManyFieldMetaInitialsResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[EnvelopeFieldUpdateManyTextAlignResponse1]


class EnvelopeFieldUpdateManyFieldMetaInitialsResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[EnvelopeFieldUpdateManyTextAlignResponse1],
        pydantic.Field(alias="textAlign"),
    ] = None


class EnvelopeFieldUpdateManyFieldMetaTypeSignature(str, Enum):
    SIGNATURE = "signature"


class EnvelopeFieldUpdateManyFieldMetaSignatureResponseTypedDict(TypedDict):
    type: EnvelopeFieldUpdateManyFieldMetaTypeSignature
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class EnvelopeFieldUpdateManyFieldMetaSignatureResponse(BaseModel):
    type: EnvelopeFieldUpdateManyFieldMetaTypeSignature

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12


EnvelopeFieldUpdateManyFieldMetaUnionTypedDict = TypeAliasType(
    "EnvelopeFieldUpdateManyFieldMetaUnionTypedDict",
    Union[
        EnvelopeFieldUpdateManyFieldMetaSignatureResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaInitialsResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaNameResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaEmailResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaDateResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaRadioResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaDropdownResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaCheckboxResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaTextResponseTypedDict,
        EnvelopeFieldUpdateManyFieldMetaNumberResponseTypedDict,
    ],
)


EnvelopeFieldUpdateManyFieldMetaUnion = TypeAliasType(
    "EnvelopeFieldUpdateManyFieldMetaUnion",
    Union[
        EnvelopeFieldUpdateManyFieldMetaSignatureResponse,
        EnvelopeFieldUpdateManyFieldMetaInitialsResponse,
        EnvelopeFieldUpdateManyFieldMetaNameResponse,
        EnvelopeFieldUpdateManyFieldMetaEmailResponse,
        EnvelopeFieldUpdateManyFieldMetaDateResponse,
        EnvelopeFieldUpdateManyFieldMetaRadioResponse,
        EnvelopeFieldUpdateManyFieldMetaDropdownResponse,
        EnvelopeFieldUpdateManyFieldMetaCheckboxResponse,
        EnvelopeFieldUpdateManyFieldMetaTextResponse,
        EnvelopeFieldUpdateManyFieldMetaNumberResponse,
    ],
)


class EnvelopeFieldUpdateManyDataResponseTypedDict(TypedDict):
    envelope_id: str
    envelope_item_id: str
    type: EnvelopeFieldUpdateManyTypeResponse
    id: float
    secondary_id: str
    recipient_id: float
    page: float
    position_x: Any
    position_y: Any
    width: Any
    height: Any
    custom_text: str
    inserted: bool
    field_meta: Nullable[EnvelopeFieldUpdateManyFieldMetaUnionTypedDict]
    document_id: NotRequired[Nullable[float]]
    template_id: NotRequired[Nullable[float]]


class EnvelopeFieldUpdateManyDataResponse(BaseModel):
    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]

    type: EnvelopeFieldUpdateManyTypeResponse

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float

    position_x: Annotated[Any, pydantic.Field(alias="positionX")]

    position_y: Annotated[Any, pydantic.Field(alias="positionY")]

    width: Any

    height: Any

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[EnvelopeFieldUpdateManyFieldMetaUnion],
        pydantic.Field(alias="fieldMeta"),
    ]

    document_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="documentId")
    ] = UNSET

    template_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="templateId")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["documentId", "templateId"]
        nullable_fields = ["fieldMeta", "documentId", "templateId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class EnvelopeFieldUpdateManyResponseTypedDict(TypedDict):
    r"""Successful response"""

    data: List[EnvelopeFieldUpdateManyDataResponseTypedDict]


class EnvelopeFieldUpdateManyResponse(BaseModel):
    r"""Successful response"""

    data: List[EnvelopeFieldUpdateManyDataResponse]
