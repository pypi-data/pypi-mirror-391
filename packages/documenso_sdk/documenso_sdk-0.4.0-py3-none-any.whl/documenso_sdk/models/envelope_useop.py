"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import BaseModel
from documenso_sdk.utils import FieldMetadata, MultipartFormMetadata
from enum import Enum
import httpx
import io
import pydantic
from typing import IO, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class EnvelopeUseRecipientTypedDict(TypedDict):
    id: float
    email: str
    name: NotRequired[str]
    signing_order: NotRequired[float]


class EnvelopeUseRecipient(BaseModel):
    id: float

    email: str

    name: Optional[str] = None

    signing_order: Annotated[Optional[float], pydantic.Field(alias="signingOrder")] = (
        None
    )


EnvelopeUseIdentifierTypedDict = TypeAliasType(
    "EnvelopeUseIdentifierTypedDict", Union[str, float]
)


EnvelopeUseIdentifier = TypeAliasType("EnvelopeUseIdentifier", Union[str, float])


class EnvelopeUseCustomDocumentDatumTypedDict(TypedDict):
    identifier: EnvelopeUseIdentifierTypedDict
    envelope_item_id: str


class EnvelopeUseCustomDocumentDatum(BaseModel):
    identifier: EnvelopeUseIdentifier

    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]


class EnvelopeUseTypeDate(str, Enum):
    DATE = "date"


class EnvelopeUsePrefillFieldDateTypedDict(TypedDict):
    type: EnvelopeUseTypeDate
    id: float
    value: NotRequired[str]


class EnvelopeUsePrefillFieldDate(BaseModel):
    type: EnvelopeUseTypeDate

    id: float

    value: Optional[str] = None


class EnvelopeUseTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class EnvelopeUsePrefillFieldDropdownTypedDict(TypedDict):
    type: EnvelopeUseTypeDropdown
    id: float
    label: NotRequired[str]
    value: NotRequired[str]


class EnvelopeUsePrefillFieldDropdown(BaseModel):
    type: EnvelopeUseTypeDropdown

    id: float

    label: Optional[str] = None

    value: Optional[str] = None


class EnvelopeUseTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class EnvelopeUsePrefillFieldCheckboxTypedDict(TypedDict):
    type: EnvelopeUseTypeCheckbox
    id: float
    label: NotRequired[str]
    value: NotRequired[List[str]]


class EnvelopeUsePrefillFieldCheckbox(BaseModel):
    type: EnvelopeUseTypeCheckbox

    id: float

    label: Optional[str] = None

    value: Optional[List[str]] = None


class EnvelopeUseTypeRadio(str, Enum):
    RADIO = "radio"


class EnvelopeUsePrefillFieldRadioTypedDict(TypedDict):
    type: EnvelopeUseTypeRadio
    id: float
    label: NotRequired[str]
    value: NotRequired[str]


class EnvelopeUsePrefillFieldRadio(BaseModel):
    type: EnvelopeUseTypeRadio

    id: float

    label: Optional[str] = None

    value: Optional[str] = None


class EnvelopeUseTypeNumber(str, Enum):
    NUMBER = "number"


class EnvelopeUsePrefillFieldNumberTypedDict(TypedDict):
    type: EnvelopeUseTypeNumber
    id: float
    label: NotRequired[str]
    placeholder: NotRequired[str]
    value: NotRequired[str]


class EnvelopeUsePrefillFieldNumber(BaseModel):
    type: EnvelopeUseTypeNumber

    id: float

    label: Optional[str] = None

    placeholder: Optional[str] = None

    value: Optional[str] = None


class EnvelopeUseTypeText(str, Enum):
    TEXT = "text"


class EnvelopeUsePrefillFieldTextTypedDict(TypedDict):
    type: EnvelopeUseTypeText
    id: float
    label: NotRequired[str]
    placeholder: NotRequired[str]
    value: NotRequired[str]


class EnvelopeUsePrefillFieldText(BaseModel):
    type: EnvelopeUseTypeText

    id: float

    label: Optional[str] = None

    placeholder: Optional[str] = None

    value: Optional[str] = None


EnvelopeUsePrefillFieldUnionTypedDict = TypeAliasType(
    "EnvelopeUsePrefillFieldUnionTypedDict",
    Union[
        EnvelopeUsePrefillFieldDateTypedDict,
        EnvelopeUsePrefillFieldRadioTypedDict,
        EnvelopeUsePrefillFieldCheckboxTypedDict,
        EnvelopeUsePrefillFieldDropdownTypedDict,
        EnvelopeUsePrefillFieldTextTypedDict,
        EnvelopeUsePrefillFieldNumberTypedDict,
    ],
)


EnvelopeUsePrefillFieldUnion = TypeAliasType(
    "EnvelopeUsePrefillFieldUnion",
    Union[
        EnvelopeUsePrefillFieldDate,
        EnvelopeUsePrefillFieldRadio,
        EnvelopeUsePrefillFieldCheckbox,
        EnvelopeUsePrefillFieldDropdown,
        EnvelopeUsePrefillFieldText,
        EnvelopeUsePrefillFieldNumber,
    ],
)


class EnvelopeUseDateFormat(str, Enum):
    YYYY_M_MDD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_M_MDD = "yyyy-MM-dd"
    DD_MM_SLASH_YYYY = "dd/MM/yyyy"
    MM_DD_SLASH_YYYY = "MM/dd/yyyy"
    YY_M_MDD = "yy-MM-dd"
    MMMM_DD_COMMA_YYYY = "MMMM dd, yyyy"
    EEEE_MMMM_DD_COMMA_YYYY = "EEEE, MMMM dd, yyyy"
    DD_MM_SLASH_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    DD_MM_SLASH_YYYY_H_HMM = "dd/MM/yyyy HH:mm"
    MM_DD_SLASH_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    MM_DD_SLASH_YYYY_H_HMM = "MM/dd/yyyy HH:mm"
    DD_DOT_MM_DOT_YYYY = "dd.MM.yyyy"
    DD_DOT_MM_DOT_YYYY_H_HMM = "dd.MM.yyyy HH:mm"
    YYYY_M_MDD_H_HMM = "yyyy-MM-dd HH:mm"
    YY_M_MDD_HH_MM_A = "yy-MM-dd hh:mm a"
    YY_M_MDD_H_HMM = "yy-MM-dd HH:mm"
    YYYY_M_MDD_H_HMMSS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_COMMA_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    MMMM_DD_COMMA_YYYY_H_HMM = "MMMM dd, yyyy HH:mm"
    EEEE_MMMM_DD_COMMA_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_COMMA_YYYY_H_HMM = "EEEE, MMMM dd, yyyy HH:mm"
    ISO8601_FULL = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class EnvelopeUseDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class EnvelopeUseEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    recipient_removed: NotRequired[bool]
    recipient_signed: NotRequired[bool]
    document_pending: NotRequired[bool]
    document_completed: NotRequired[bool]
    document_deleted: NotRequired[bool]
    owner_document_completed: NotRequired[bool]


class EnvelopeUseEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True


class EnvelopeUseLanguage(str, Enum):
    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"
    IT = "it"
    PL = "pl"


class OverrideTypedDict(TypedDict):
    title: NotRequired[str]
    subject: NotRequired[str]
    message: NotRequired[str]
    timezone: NotRequired[str]
    date_format: NotRequired[EnvelopeUseDateFormat]
    redirect_url: NotRequired[str]
    distribution_method: NotRequired[EnvelopeUseDistributionMethod]
    email_settings: NotRequired[EnvelopeUseEmailSettingsTypedDict]
    language: NotRequired[EnvelopeUseLanguage]
    typed_signature_enabled: NotRequired[bool]
    upload_signature_enabled: NotRequired[bool]
    draw_signature_enabled: NotRequired[bool]
    allow_dictate_next_signer: NotRequired[bool]


class Override(BaseModel):
    title: Optional[str] = None

    subject: Optional[str] = None

    message: Optional[str] = None

    timezone: Optional[str] = None

    date_format: Annotated[
        Optional[EnvelopeUseDateFormat], pydantic.Field(alias="dateFormat")
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None

    distribution_method: Annotated[
        Optional[EnvelopeUseDistributionMethod],
        pydantic.Field(alias="distributionMethod"),
    ] = None

    email_settings: Annotated[
        Optional[EnvelopeUseEmailSettings], pydantic.Field(alias="emailSettings")
    ] = None

    language: Optional[EnvelopeUseLanguage] = None

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None

    upload_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="uploadSignatureEnabled")
    ] = None

    draw_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="drawSignatureEnabled")
    ] = None

    allow_dictate_next_signer: Annotated[
        Optional[bool], pydantic.Field(alias="allowDictateNextSigner")
    ] = None


class EnvelopeUseTypeLink(str, Enum):
    LINK = "link"


class EnvelopeUseAttachmentTypedDict(TypedDict):
    label: str
    data: str
    type: NotRequired[EnvelopeUseTypeLink]


class EnvelopeUseAttachment(BaseModel):
    label: str

    data: str

    type: Optional[EnvelopeUseTypeLink] = EnvelopeUseTypeLink.LINK


class EnvelopeUsePayloadTypedDict(TypedDict):
    envelope_id: str
    recipients: List[EnvelopeUseRecipientTypedDict]
    external_id: NotRequired[str]
    distribute_document: NotRequired[bool]
    custom_document_data: NotRequired[List[EnvelopeUseCustomDocumentDatumTypedDict]]
    folder_id: NotRequired[str]
    prefill_fields: NotRequired[List[EnvelopeUsePrefillFieldUnionTypedDict]]
    override: NotRequired[OverrideTypedDict]
    attachments: NotRequired[List[EnvelopeUseAttachmentTypedDict]]


class EnvelopeUsePayload(BaseModel):
    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    recipients: List[EnvelopeUseRecipient]

    external_id: Annotated[Optional[str], pydantic.Field(alias="externalId")] = None

    distribute_document: Annotated[
        Optional[bool], pydantic.Field(alias="distributeDocument")
    ] = None

    custom_document_data: Annotated[
        Optional[List[EnvelopeUseCustomDocumentDatum]],
        pydantic.Field(alias="customDocumentData"),
    ] = None

    folder_id: Annotated[Optional[str], pydantic.Field(alias="folderId")] = None

    prefill_fields: Annotated[
        Optional[List[EnvelopeUsePrefillFieldUnion]],
        pydantic.Field(alias="prefillFields"),
    ] = None

    override: Optional[Override] = None

    attachments: Optional[List[EnvelopeUseAttachment]] = None


class EnvelopeUseFileTypedDict(TypedDict):
    file_name: str
    content: Union[bytes, IO[bytes], io.BufferedReader]
    content_type: NotRequired[str]


class EnvelopeUseFile(BaseModel):
    file_name: Annotated[
        str, pydantic.Field(alias="fileName"), FieldMetadata(multipart=True)
    ]

    content: Annotated[
        Union[bytes, IO[bytes], io.BufferedReader],
        pydantic.Field(alias=""),
        FieldMetadata(multipart=MultipartFormMetadata(content=True)),
    ]

    content_type: Annotated[
        Optional[str],
        pydantic.Field(alias="Content-Type"),
        FieldMetadata(multipart=True),
    ] = None


class EnvelopeUseRequestTypedDict(TypedDict):
    payload: EnvelopeUsePayloadTypedDict
    files: NotRequired[List[EnvelopeUseFileTypedDict]]


class EnvelopeUseRequest(BaseModel):
    payload: Annotated[
        EnvelopeUsePayload, FieldMetadata(multipart=MultipartFormMetadata(json=True))
    ]

    files: Annotated[
        Optional[List[EnvelopeUseFile]],
        FieldMetadata(multipart=MultipartFormMetadata(file=True)),
    ] = None


class EnvelopeUseInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class EnvelopeUseInternalServerErrorIssue(BaseModel):
    message: str


class EnvelopeUseInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeUseInternalServerErrorIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeUseInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: EnvelopeUseInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeUseInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeUseForbiddenIssueTypedDict(TypedDict):
    message: str


class EnvelopeUseForbiddenIssue(BaseModel):
    message: str


class EnvelopeUseForbiddenErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeUseForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeUseForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: EnvelopeUseForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeUseForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeUseUnauthorizedIssueTypedDict(TypedDict):
    message: str


class EnvelopeUseUnauthorizedIssue(BaseModel):
    message: str


class EnvelopeUseUnauthorizedErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeUseUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeUseUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: EnvelopeUseUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeUseUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeUseBadRequestIssueTypedDict(TypedDict):
    message: str


class EnvelopeUseBadRequestIssue(BaseModel):
    message: str


class EnvelopeUseBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[EnvelopeUseBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class EnvelopeUseBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: EnvelopeUseBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: EnvelopeUseBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class EnvelopeUseResponseTypedDict(TypedDict):
    r"""Successful response"""

    id: str


class EnvelopeUseResponse(BaseModel):
    r"""Successful response"""

    id: str
