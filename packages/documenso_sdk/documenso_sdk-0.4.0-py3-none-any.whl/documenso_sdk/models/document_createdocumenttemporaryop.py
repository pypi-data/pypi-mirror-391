"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from dataclasses import dataclass, field
from documenso_sdk.models import DocumensoError
from documenso_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
import httpx
import pydantic
from pydantic import model_serializer
from typing import Any, Dict, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class DocumentCreateDocumentTemporaryVisibilityRequest(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryGlobalAccessAuthRequest(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentCreateDocumentTemporaryGlobalActionAuthRequest(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"


DocumentCreateDocumentTemporaryFormValuesRequestTypedDict = TypeAliasType(
    "DocumentCreateDocumentTemporaryFormValuesRequestTypedDict", Union[str, bool, float]
)


DocumentCreateDocumentTemporaryFormValuesRequest = TypeAliasType(
    "DocumentCreateDocumentTemporaryFormValuesRequest", Union[str, bool, float]
)


class DocumentCreateDocumentTemporaryRoleRequest(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class DocumentCreateDocumentTemporaryAccessAuthRequest(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentCreateDocumentTemporaryActionAuthRequest(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentCreateDocumentTemporaryRecipientTypeDropdown1(str, Enum):
    DROPDOWN = "DROPDOWN"


class DocumentCreateDocumentTemporaryRecipientTypeDropdown2(str, Enum):
    DROPDOWN = "dropdown"


class DocumentCreateDocumentTemporaryValueDropdownTypedDict(TypedDict):
    value: str


class DocumentCreateDocumentTemporaryValueDropdown(BaseModel):
    value: str


class DocumentCreateDocumentTemporaryRecipientFieldMetaDropdownTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeDropdown2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentCreateDocumentTemporaryValueDropdownTypedDict]]
    default_value: NotRequired[str]


class DocumentCreateDocumentTemporaryRecipientFieldMetaDropdown(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeDropdown2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentCreateDocumentTemporaryValueDropdown]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class DocumentCreateDocumentTemporaryFieldDropdownTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeDropdown1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaDropdownTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldDropdown(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeDropdown1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaDropdown],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeCheckbox1(str, Enum):
    CHECKBOX = "CHECKBOX"


class DocumentCreateDocumentTemporaryRecipientTypeCheckbox2(str, Enum):
    CHECKBOX = "checkbox"


class DocumentCreateDocumentTemporaryValueCheckboxTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentCreateDocumentTemporaryValueCheckbox(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryDirectionCheckbox(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class DocumentCreateDocumentTemporaryRecipientFieldMetaCheckboxTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeCheckbox2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentCreateDocumentTemporaryValueCheckboxTypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]
    direction: NotRequired[DocumentCreateDocumentTemporaryDirectionCheckbox]


class DocumentCreateDocumentTemporaryRecipientFieldMetaCheckbox(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeCheckbox2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentCreateDocumentTemporaryValueCheckbox]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None

    direction: Optional[DocumentCreateDocumentTemporaryDirectionCheckbox] = (
        DocumentCreateDocumentTemporaryDirectionCheckbox.VERTICAL
    )


class DocumentCreateDocumentTemporaryFieldCheckboxTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeCheckbox1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaCheckboxTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldCheckbox(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeCheckbox1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaCheckbox],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeRadio1(str, Enum):
    RADIO = "RADIO"


class DocumentCreateDocumentTemporaryRecipientTypeRadio2(str, Enum):
    RADIO = "radio"


class DocumentCreateDocumentTemporaryValueRadioTypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentCreateDocumentTemporaryValueRadio(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentCreateDocumentTemporaryDirectionRadio(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class DocumentCreateDocumentTemporaryRecipientFieldMetaRadioTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeRadio2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentCreateDocumentTemporaryValueRadioTypedDict]]
    direction: NotRequired[DocumentCreateDocumentTemporaryDirectionRadio]


class DocumentCreateDocumentTemporaryRecipientFieldMetaRadio(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeRadio2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentCreateDocumentTemporaryValueRadio]] = None

    direction: Optional[DocumentCreateDocumentTemporaryDirectionRadio] = (
        DocumentCreateDocumentTemporaryDirectionRadio.VERTICAL
    )


class DocumentCreateDocumentTemporaryFieldRadioTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeRadio1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaRadioTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldRadio(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeRadio1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaRadio],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeNumber1(str, Enum):
    NUMBER = "NUMBER"


class DocumentCreateDocumentTemporaryRecipientTypeNumber2(str, Enum):
    NUMBER = "number"


class DocumentCreateDocumentTemporaryTextAlignNumber(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryVerticalAlignNumber(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class DocumentCreateDocumentTemporaryRecipientFieldMetaNumberTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeNumber2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    number_format: NotRequired[Nullable[str]]
    value: NotRequired[str]
    min_value: NotRequired[Nullable[float]]
    max_value: NotRequired[Nullable[float]]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignNumber]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[
        Nullable[DocumentCreateDocumentTemporaryVerticalAlignNumber]
    ]


class DocumentCreateDocumentTemporaryRecipientFieldMetaNumber(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeNumber2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    number_format: Annotated[
        OptionalNullable[str], pydantic.Field(alias="numberFormat")
    ] = UNSET

    value: Optional[str] = None

    min_value: Annotated[OptionalNullable[float], pydantic.Field(alias="minValue")] = (
        UNSET
    )

    max_value: Annotated[OptionalNullable[float], pydantic.Field(alias="maxValue")] = (
        UNSET
    )

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignNumber],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[DocumentCreateDocumentTemporaryVerticalAlignNumber],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "numberFormat",
            "value",
            "minValue",
            "maxValue",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = [
            "numberFormat",
            "minValue",
            "maxValue",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryFieldNumberTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeNumber1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaNumberTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldNumber(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeNumber1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaNumber],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeText1(str, Enum):
    TEXT = "TEXT"


class DocumentCreateDocumentTemporaryRecipientTypeText2(str, Enum):
    TEXT = "text"


class DocumentCreateDocumentTemporaryTextAlignText(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryVerticalAlignText(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class DocumentCreateDocumentTemporaryRecipientFieldMetaTextTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeText2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignText]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[
        Nullable[DocumentCreateDocumentTemporaryVerticalAlignText]
    ]


class DocumentCreateDocumentTemporaryRecipientFieldMetaText(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeText2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignText],
        pydantic.Field(alias="textAlign"),
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[DocumentCreateDocumentTemporaryVerticalAlignText],
        pydantic.Field(alias="verticalAlign"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "text",
            "characterLimit",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = ["lineHeight", "letterSpacing", "verticalAlign"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryFieldTextTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeText1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaTextTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldText(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeText1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaText],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeDate1(str, Enum):
    DATE = "DATE"


class DocumentCreateDocumentTemporaryRecipientTypeDate2(str, Enum):
    DATE = "date"


class DocumentCreateDocumentTemporaryTextAlignDate(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryRecipientFieldMetaDateTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeDate2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignDate]


class DocumentCreateDocumentTemporaryRecipientFieldMetaDate(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeDate2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignDate],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentCreateDocumentTemporaryFieldDateTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeDate1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaDateTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldDate(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeDate1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaDate],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeEmail1(str, Enum):
    EMAIL = "EMAIL"


class DocumentCreateDocumentTemporaryRecipientTypeEmail2(str, Enum):
    EMAIL = "email"


class DocumentCreateDocumentTemporaryTextAlignEmail(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryRecipientFieldMetaEmailTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeEmail2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignEmail]


class DocumentCreateDocumentTemporaryRecipientFieldMetaEmail(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeEmail2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignEmail],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentCreateDocumentTemporaryFieldEmailTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeEmail1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaEmailTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldEmail(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeEmail1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaEmail],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeName1(str, Enum):
    NAME = "NAME"


class DocumentCreateDocumentTemporaryRecipientTypeName2(str, Enum):
    NAME = "name"


class DocumentCreateDocumentTemporaryTextAlignName(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryRecipientFieldMetaNameTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeName2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignName]


class DocumentCreateDocumentTemporaryRecipientFieldMetaName(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeName2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignName],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentCreateDocumentTemporaryFieldNameTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeName1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaNameTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldName(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeName1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaName],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryRecipientTypeInitials1(str, Enum):
    INITIALS = "INITIALS"


class DocumentCreateDocumentTemporaryRecipientTypeInitials2(str, Enum):
    INITIALS = "initials"


class DocumentCreateDocumentTemporaryTextAlignInitials(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentCreateDocumentTemporaryRecipientFieldMetaInitialsTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeInitials2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentCreateDocumentTemporaryTextAlignInitials]


class DocumentCreateDocumentTemporaryRecipientFieldMetaInitials(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeInitials2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentCreateDocumentTemporaryTextAlignInitials],
        pydantic.Field(alias="textAlign"),
    ] = None


class DocumentCreateDocumentTemporaryFieldInitialsTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeInitials1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaInitialsTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldInitials(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeInitials1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaInitials],
        pydantic.Field(alias="fieldMeta"),
    ] = None


class DocumentCreateDocumentTemporaryTypeFreeSignature(str, Enum):
    FREE_SIGNATURE = "FREE_SIGNATURE"


class DocumentCreateDocumentTemporaryFieldFreeSignatureTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryTypeFreeSignature
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float


class DocumentCreateDocumentTemporaryFieldFreeSignature(BaseModel):
    type: DocumentCreateDocumentTemporaryTypeFreeSignature

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float


class DocumentCreateDocumentTemporaryRecipientTypeSignature1(str, Enum):
    SIGNATURE = "SIGNATURE"


class DocumentCreateDocumentTemporaryRecipientTypeSignature2(str, Enum):
    SIGNATURE = "signature"


class DocumentCreateDocumentTemporaryRecipientFieldMetaSignatureTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeSignature2
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class DocumentCreateDocumentTemporaryRecipientFieldMetaSignature(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeSignature2

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12


class DocumentCreateDocumentTemporaryFieldSignatureTypedDict(TypedDict):
    type: DocumentCreateDocumentTemporaryRecipientTypeSignature1
    page_number: float
    page_x: float
    page_y: float
    width: float
    height: float
    field_meta: NotRequired[
        DocumentCreateDocumentTemporaryRecipientFieldMetaSignatureTypedDict
    ]


class DocumentCreateDocumentTemporaryFieldSignature(BaseModel):
    type: DocumentCreateDocumentTemporaryRecipientTypeSignature1

    page_number: Annotated[float, pydantic.Field(alias="pageNumber")]

    page_x: Annotated[float, pydantic.Field(alias="pageX")]

    page_y: Annotated[float, pydantic.Field(alias="pageY")]

    width: float

    height: float

    field_meta: Annotated[
        Optional[DocumentCreateDocumentTemporaryRecipientFieldMetaSignature],
        pydantic.Field(alias="fieldMeta"),
    ] = None


DocumentCreateDocumentTemporaryFieldUnionTypedDict = TypeAliasType(
    "DocumentCreateDocumentTemporaryFieldUnionTypedDict",
    Union[
        DocumentCreateDocumentTemporaryFieldFreeSignatureTypedDict,
        DocumentCreateDocumentTemporaryFieldSignatureTypedDict,
        DocumentCreateDocumentTemporaryFieldInitialsTypedDict,
        DocumentCreateDocumentTemporaryFieldNameTypedDict,
        DocumentCreateDocumentTemporaryFieldEmailTypedDict,
        DocumentCreateDocumentTemporaryFieldDateTypedDict,
        DocumentCreateDocumentTemporaryFieldTextTypedDict,
        DocumentCreateDocumentTemporaryFieldNumberTypedDict,
        DocumentCreateDocumentTemporaryFieldRadioTypedDict,
        DocumentCreateDocumentTemporaryFieldCheckboxTypedDict,
        DocumentCreateDocumentTemporaryFieldDropdownTypedDict,
    ],
)


DocumentCreateDocumentTemporaryFieldUnion = TypeAliasType(
    "DocumentCreateDocumentTemporaryFieldUnion",
    Union[
        DocumentCreateDocumentTemporaryFieldFreeSignature,
        DocumentCreateDocumentTemporaryFieldSignature,
        DocumentCreateDocumentTemporaryFieldInitials,
        DocumentCreateDocumentTemporaryFieldName,
        DocumentCreateDocumentTemporaryFieldEmail,
        DocumentCreateDocumentTemporaryFieldDate,
        DocumentCreateDocumentTemporaryFieldText,
        DocumentCreateDocumentTemporaryFieldNumber,
        DocumentCreateDocumentTemporaryFieldRadio,
        DocumentCreateDocumentTemporaryFieldCheckbox,
        DocumentCreateDocumentTemporaryFieldDropdown,
    ],
)


class DocumentCreateDocumentTemporaryRecipientRequestTypedDict(TypedDict):
    email: str
    name: str
    role: DocumentCreateDocumentTemporaryRoleRequest
    signing_order: NotRequired[float]
    access_auth: NotRequired[List[DocumentCreateDocumentTemporaryAccessAuthRequest]]
    action_auth: NotRequired[List[DocumentCreateDocumentTemporaryActionAuthRequest]]
    fields: NotRequired[List[DocumentCreateDocumentTemporaryFieldUnionTypedDict]]


class DocumentCreateDocumentTemporaryRecipientRequest(BaseModel):
    email: str

    name: str

    role: DocumentCreateDocumentTemporaryRoleRequest

    signing_order: Annotated[Optional[float], pydantic.Field(alias="signingOrder")] = (
        None
    )

    access_auth: Annotated[
        Optional[List[DocumentCreateDocumentTemporaryAccessAuthRequest]],
        pydantic.Field(alias="accessAuth"),
    ] = None

    action_auth: Annotated[
        Optional[List[DocumentCreateDocumentTemporaryActionAuthRequest]],
        pydantic.Field(alias="actionAuth"),
    ] = None

    fields: Optional[List[DocumentCreateDocumentTemporaryFieldUnion]] = None


class DocumentCreateDocumentTemporaryTypeLink(str, Enum):
    LINK = "link"


class DocumentCreateDocumentTemporaryAttachmentTypedDict(TypedDict):
    label: str
    data: str
    type: NotRequired[DocumentCreateDocumentTemporaryTypeLink]


class DocumentCreateDocumentTemporaryAttachment(BaseModel):
    label: str

    data: str

    type: Optional[DocumentCreateDocumentTemporaryTypeLink] = (
        DocumentCreateDocumentTemporaryTypeLink.LINK
    )


class DocumentCreateDocumentTemporaryDateFormat(str, Enum):
    YYYY_M_MDD_HH_MM_A = "yyyy-MM-dd hh:mm a"
    YYYY_M_MDD = "yyyy-MM-dd"
    DD_MM_SLASH_YYYY = "dd/MM/yyyy"
    MM_DD_SLASH_YYYY = "MM/dd/yyyy"
    YY_M_MDD = "yy-MM-dd"
    MMMM_DD_COMMA_YYYY = "MMMM dd, yyyy"
    EEEE_MMMM_DD_COMMA_YYYY = "EEEE, MMMM dd, yyyy"
    DD_MM_SLASH_YYYY_HH_MM_A = "dd/MM/yyyy hh:mm a"
    DD_MM_SLASH_YYYY_H_HMM = "dd/MM/yyyy HH:mm"
    MM_DD_SLASH_YYYY_HH_MM_A = "MM/dd/yyyy hh:mm a"
    MM_DD_SLASH_YYYY_H_HMM = "MM/dd/yyyy HH:mm"
    DD_DOT_MM_DOT_YYYY = "dd.MM.yyyy"
    DD_DOT_MM_DOT_YYYY_H_HMM = "dd.MM.yyyy HH:mm"
    YYYY_M_MDD_H_HMM = "yyyy-MM-dd HH:mm"
    YY_M_MDD_HH_MM_A = "yy-MM-dd hh:mm a"
    YY_M_MDD_H_HMM = "yy-MM-dd HH:mm"
    YYYY_M_MDD_H_HMMSS = "yyyy-MM-dd HH:mm:ss"
    MMMM_DD_COMMA_YYYY_HH_MM_A = "MMMM dd, yyyy hh:mm a"
    MMMM_DD_COMMA_YYYY_H_HMM = "MMMM dd, yyyy HH:mm"
    EEEE_MMMM_DD_COMMA_YYYY_HH_MM_A = "EEEE, MMMM dd, yyyy hh:mm a"
    EEEE_MMMM_DD_COMMA_YYYY_H_HMM = "EEEE, MMMM dd, yyyy HH:mm"
    ISO8601_FULL = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"


class DocumentCreateDocumentTemporaryMetaDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class DocumentCreateDocumentTemporarySigningOrderRequest(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentCreateDocumentTemporaryLanguage(str, Enum):
    DE = "de"
    EN = "en"
    FR = "fr"
    ES = "es"
    IT = "it"
    PL = "pl"


class DocumentCreateDocumentTemporaryMetaEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    recipient_removed: NotRequired[bool]
    recipient_signed: NotRequired[bool]
    document_pending: NotRequired[bool]
    document_completed: NotRequired[bool]
    document_deleted: NotRequired[bool]
    owner_document_completed: NotRequired[bool]


class DocumentCreateDocumentTemporaryMetaEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True


class DocumentCreateDocumentTemporaryMetaTypedDict(TypedDict):
    subject: NotRequired[str]
    message: NotRequired[str]
    timezone: NotRequired[str]
    date_format: NotRequired[DocumentCreateDocumentTemporaryDateFormat]
    distribution_method: NotRequired[
        DocumentCreateDocumentTemporaryMetaDistributionMethod
    ]
    signing_order: NotRequired[DocumentCreateDocumentTemporarySigningOrderRequest]
    allow_dictate_next_signer: NotRequired[bool]
    redirect_url: NotRequired[str]
    language: NotRequired[DocumentCreateDocumentTemporaryLanguage]
    typed_signature_enabled: NotRequired[bool]
    upload_signature_enabled: NotRequired[bool]
    draw_signature_enabled: NotRequired[bool]
    email_id: NotRequired[Nullable[str]]
    email_reply_to: NotRequired[Nullable[str]]
    email_settings: NotRequired[
        Nullable[DocumentCreateDocumentTemporaryMetaEmailSettingsTypedDict]
    ]


class DocumentCreateDocumentTemporaryMeta(BaseModel):
    subject: Optional[str] = None

    message: Optional[str] = None

    timezone: Optional[str] = None

    date_format: Annotated[
        Optional[DocumentCreateDocumentTemporaryDateFormat],
        pydantic.Field(alias="dateFormat"),
    ] = None

    distribution_method: Annotated[
        Optional[DocumentCreateDocumentTemporaryMetaDistributionMethod],
        pydantic.Field(alias="distributionMethod"),
    ] = None

    signing_order: Annotated[
        Optional[DocumentCreateDocumentTemporarySigningOrderRequest],
        pydantic.Field(alias="signingOrder"),
    ] = None

    allow_dictate_next_signer: Annotated[
        Optional[bool], pydantic.Field(alias="allowDictateNextSigner")
    ] = None

    redirect_url: Annotated[Optional[str], pydantic.Field(alias="redirectUrl")] = None

    language: Optional[DocumentCreateDocumentTemporaryLanguage] = None

    typed_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="typedSignatureEnabled")
    ] = None

    upload_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="uploadSignatureEnabled")
    ] = None

    draw_signature_enabled: Annotated[
        Optional[bool], pydantic.Field(alias="drawSignatureEnabled")
    ] = None

    email_id: Annotated[OptionalNullable[str], pydantic.Field(alias="emailId")] = UNSET

    email_reply_to: Annotated[
        OptionalNullable[str], pydantic.Field(alias="emailReplyTo")
    ] = UNSET

    email_settings: Annotated[
        OptionalNullable[DocumentCreateDocumentTemporaryMetaEmailSettings],
        pydantic.Field(alias="emailSettings"),
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "subject",
            "message",
            "timezone",
            "dateFormat",
            "distributionMethod",
            "signingOrder",
            "allowDictateNextSigner",
            "redirectUrl",
            "language",
            "typedSignatureEnabled",
            "uploadSignatureEnabled",
            "drawSignatureEnabled",
            "emailId",
            "emailReplyTo",
            "emailSettings",
        ]
        nullable_fields = ["emailId", "emailReplyTo", "emailSettings"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryRequestTypedDict(TypedDict):
    title: str
    external_id: NotRequired[str]
    visibility: NotRequired[DocumentCreateDocumentTemporaryVisibilityRequest]
    global_access_auth: NotRequired[
        List[DocumentCreateDocumentTemporaryGlobalAccessAuthRequest]
    ]
    global_action_auth: NotRequired[
        List[DocumentCreateDocumentTemporaryGlobalActionAuthRequest]
    ]
    form_values: NotRequired[
        Dict[str, DocumentCreateDocumentTemporaryFormValuesRequestTypedDict]
    ]
    folder_id: NotRequired[str]
    recipients: NotRequired[
        List[DocumentCreateDocumentTemporaryRecipientRequestTypedDict]
    ]
    attachments: NotRequired[List[DocumentCreateDocumentTemporaryAttachmentTypedDict]]
    meta: NotRequired[DocumentCreateDocumentTemporaryMetaTypedDict]


class DocumentCreateDocumentTemporaryRequest(BaseModel):
    title: str

    external_id: Annotated[Optional[str], pydantic.Field(alias="externalId")] = None

    visibility: Optional[DocumentCreateDocumentTemporaryVisibilityRequest] = None

    global_access_auth: Annotated[
        Optional[List[DocumentCreateDocumentTemporaryGlobalAccessAuthRequest]],
        pydantic.Field(alias="globalAccessAuth"),
    ] = None

    global_action_auth: Annotated[
        Optional[List[DocumentCreateDocumentTemporaryGlobalActionAuthRequest]],
        pydantic.Field(alias="globalActionAuth"),
    ] = None

    form_values: Annotated[
        Optional[Dict[str, DocumentCreateDocumentTemporaryFormValuesRequest]],
        pydantic.Field(alias="formValues"),
    ] = None

    folder_id: Annotated[Optional[str], pydantic.Field(alias="folderId")] = None

    recipients: Optional[List[DocumentCreateDocumentTemporaryRecipientRequest]] = None

    attachments: Optional[List[DocumentCreateDocumentTemporaryAttachment]] = None

    meta: Optional[DocumentCreateDocumentTemporaryMeta] = None


class DocumentCreateDocumentTemporaryInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryInternalServerErrorIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryInternalServerErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryInternalServerErrorIssue]] = (
        None
    )


@dataclass(unsafe_hash=True)
class DocumentCreateDocumentTemporaryInternalServerError(DocumensoError):
    r"""Internal server error"""

    data: DocumentCreateDocumentTemporaryInternalServerErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentCreateDocumentTemporaryInternalServerErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentCreateDocumentTemporaryForbiddenIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryForbiddenIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryForbiddenErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryForbiddenIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentCreateDocumentTemporaryForbiddenError(DocumensoError):
    r"""Insufficient access"""

    data: DocumentCreateDocumentTemporaryForbiddenErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentCreateDocumentTemporaryForbiddenErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentCreateDocumentTemporaryUnauthorizedIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryUnauthorizedIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryUnauthorizedErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryUnauthorizedIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentCreateDocumentTemporaryUnauthorizedError(DocumensoError):
    r"""Authorization not provided"""

    data: DocumentCreateDocumentTemporaryUnauthorizedErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentCreateDocumentTemporaryUnauthorizedErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentCreateDocumentTemporaryBadRequestIssueTypedDict(TypedDict):
    message: str


class DocumentCreateDocumentTemporaryBadRequestIssue(BaseModel):
    message: str


class DocumentCreateDocumentTemporaryBadRequestErrorData(BaseModel):
    message: str

    code: str

    issues: Optional[List[DocumentCreateDocumentTemporaryBadRequestIssue]] = None


@dataclass(unsafe_hash=True)
class DocumentCreateDocumentTemporaryBadRequestError(DocumensoError):
    r"""Invalid input data"""

    data: DocumentCreateDocumentTemporaryBadRequestErrorData = field(hash=False)

    def __init__(
        self,
        data: DocumentCreateDocumentTemporaryBadRequestErrorData,
        raw_response: httpx.Response,
        body: Optional[str] = None,
    ):
        fallback = body or raw_response.text
        message = str(data.message) or fallback
        super().__init__(message, raw_response, body)
        object.__setattr__(self, "data", data)


class DocumentVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryStatus(str, Enum):
    DRAFT = "DRAFT"
    PENDING = "PENDING"
    COMPLETED = "COMPLETED"
    REJECTED = "REJECTED"


class DocumentCreateDocumentTemporarySource(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"
    TEMPLATE_DIRECT_LINK = "TEMPLATE_DIRECT_LINK"


class DocumentGlobalAccessAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentGlobalActionAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"


class DocumentCreateDocumentTemporaryAuthOptionsTypedDict(TypedDict):
    global_access_auth: List[DocumentGlobalAccessAuth]
    global_action_auth: List[DocumentGlobalActionAuth]


class DocumentCreateDocumentTemporaryAuthOptions(BaseModel):
    global_access_auth: Annotated[
        List[DocumentGlobalAccessAuth], pydantic.Field(alias="globalAccessAuth")
    ]

    global_action_auth: Annotated[
        List[DocumentGlobalActionAuth], pydantic.Field(alias="globalActionAuth")
    ]


DocumentFormValuesTypedDict = TypeAliasType(
    "DocumentFormValuesTypedDict", Union[str, bool, float]
)


DocumentFormValues = TypeAliasType("DocumentFormValues", Union[str, bool, float])


class DocumentDocumentDataType(str, Enum):
    S3_PATH = "S3_PATH"
    BYTES = "BYTES"
    BYTES_64 = "BYTES_64"


class DocumentCreateDocumentTemporaryDocumentDataTypedDict(TypedDict):
    type: DocumentDocumentDataType
    id: str
    data: str
    initial_data: str
    envelope_item_id: str


class DocumentCreateDocumentTemporaryDocumentData(BaseModel):
    type: DocumentDocumentDataType

    id: str

    data: str

    initial_data: Annotated[str, pydantic.Field(alias="initialData")]

    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]


class DocumentSigningOrder(str, Enum):
    PARALLEL = "PARALLEL"
    SEQUENTIAL = "SEQUENTIAL"


class DocumentDistributionMethod(str, Enum):
    EMAIL = "EMAIL"
    NONE = "NONE"


class DocumentEmailSettingsTypedDict(TypedDict):
    recipient_signing_request: NotRequired[bool]
    recipient_removed: NotRequired[bool]
    recipient_signed: NotRequired[bool]
    document_pending: NotRequired[bool]
    document_completed: NotRequired[bool]
    document_deleted: NotRequired[bool]
    owner_document_completed: NotRequired[bool]


class DocumentEmailSettings(BaseModel):
    recipient_signing_request: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigningRequest")
    ] = True

    recipient_removed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientRemoved")
    ] = True

    recipient_signed: Annotated[
        Optional[bool], pydantic.Field(alias="recipientSigned")
    ] = True

    document_pending: Annotated[
        Optional[bool], pydantic.Field(alias="documentPending")
    ] = True

    document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="documentCompleted")
    ] = True

    document_deleted: Annotated[
        Optional[bool], pydantic.Field(alias="documentDeleted")
    ] = True

    owner_document_completed: Annotated[
        Optional[bool], pydantic.Field(alias="ownerDocumentCompleted")
    ] = True


class DocumentCreateDocumentTemporaryDocumentMetaTypedDict(TypedDict):
    signing_order: DocumentSigningOrder
    distribution_method: DocumentDistributionMethod
    id: str
    subject: Nullable[str]
    message: Nullable[str]
    timezone: Nullable[str]
    date_format: Nullable[str]
    redirect_url: Nullable[str]
    typed_signature_enabled: bool
    upload_signature_enabled: bool
    draw_signature_enabled: bool
    allow_dictate_next_signer: bool
    language: str
    email_settings: Nullable[DocumentEmailSettingsTypedDict]
    email_id: Nullable[str]
    email_reply_to: Nullable[str]
    password: NotRequired[Nullable[str]]
    document_id: NotRequired[float]


class DocumentCreateDocumentTemporaryDocumentMeta(BaseModel):
    signing_order: Annotated[DocumentSigningOrder, pydantic.Field(alias="signingOrder")]

    distribution_method: Annotated[
        DocumentDistributionMethod, pydantic.Field(alias="distributionMethod")
    ]

    id: str

    subject: Nullable[str]

    message: Nullable[str]

    timezone: Nullable[str]

    date_format: Annotated[Nullable[str], pydantic.Field(alias="dateFormat")]

    redirect_url: Annotated[Nullable[str], pydantic.Field(alias="redirectUrl")]

    typed_signature_enabled: Annotated[
        bool, pydantic.Field(alias="typedSignatureEnabled")
    ]

    upload_signature_enabled: Annotated[
        bool, pydantic.Field(alias="uploadSignatureEnabled")
    ]

    draw_signature_enabled: Annotated[
        bool, pydantic.Field(alias="drawSignatureEnabled")
    ]

    allow_dictate_next_signer: Annotated[
        bool, pydantic.Field(alias="allowDictateNextSigner")
    ]

    language: str

    email_settings: Annotated[
        Nullable[DocumentEmailSettings], pydantic.Field(alias="emailSettings")
    ]

    email_id: Annotated[Nullable[str], pydantic.Field(alias="emailId")]

    email_reply_to: Annotated[Nullable[str], pydantic.Field(alias="emailReplyTo")]

    password: OptionalNullable[str] = None

    document_id: Annotated[Optional[float], pydantic.Field(alias="documentId")] = -1

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["password", "documentId"]
        nullable_fields = [
            "subject",
            "message",
            "timezone",
            "dateFormat",
            "redirectUrl",
            "emailSettings",
            "emailId",
            "emailReplyTo",
            "password",
        ]
        null_default_fields = ["password"]

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryEnvelopeItemTypedDict(TypedDict):
    id: str
    envelope_id: str


class DocumentCreateDocumentTemporaryEnvelopeItem(BaseModel):
    id: str

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]


class DocumentFolderType(str, Enum):
    DOCUMENT = "DOCUMENT"
    TEMPLATE = "TEMPLATE"


class DocumentFolderVisibility(str, Enum):
    EVERYONE = "EVERYONE"
    MANAGER_AND_ABOVE = "MANAGER_AND_ABOVE"
    ADMIN = "ADMIN"


class DocumentCreateDocumentTemporaryFolderTypedDict(TypedDict):
    id: str
    name: str
    type: DocumentFolderType
    visibility: DocumentFolderVisibility
    user_id: float
    team_id: float
    pinned: bool
    parent_id: Nullable[str]
    created_at: str
    updated_at: str


class DocumentCreateDocumentTemporaryFolder(BaseModel):
    id: str

    name: str

    type: DocumentFolderType

    visibility: DocumentFolderVisibility

    user_id: Annotated[float, pydantic.Field(alias="userId")]

    team_id: Annotated[float, pydantic.Field(alias="teamId")]

    pinned: bool

    parent_id: Annotated[Nullable[str], pydantic.Field(alias="parentId")]

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["parentId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentRole(str, Enum):
    CC = "CC"
    SIGNER = "SIGNER"
    VIEWER = "VIEWER"
    APPROVER = "APPROVER"
    ASSISTANT = "ASSISTANT"


class DocumentCreateDocumentTemporaryReadStatus(str, Enum):
    NOT_OPENED = "NOT_OPENED"
    OPENED = "OPENED"


class DocumentCreateDocumentTemporarySigningStatus(str, Enum):
    NOT_SIGNED = "NOT_SIGNED"
    SIGNED = "SIGNED"
    REJECTED = "REJECTED"


class DocumentCreateDocumentTemporarySendStatus(str, Enum):
    NOT_SENT = "NOT_SENT"
    SENT = "SENT"


class DocumentAccessAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"


class DocumentActionAuth(str, Enum):
    ACCOUNT = "ACCOUNT"
    PASSKEY = "PASSKEY"
    TWO_FACTOR_AUTH = "TWO_FACTOR_AUTH"
    PASSWORD = "PASSWORD"
    EXPLICIT_NONE = "EXPLICIT_NONE"


class DocumentCreateDocumentTemporaryRecipientAuthOptionsTypedDict(TypedDict):
    access_auth: List[DocumentAccessAuth]
    action_auth: List[DocumentActionAuth]


class DocumentCreateDocumentTemporaryRecipientAuthOptions(BaseModel):
    access_auth: Annotated[List[DocumentAccessAuth], pydantic.Field(alias="accessAuth")]

    action_auth: Annotated[List[DocumentActionAuth], pydantic.Field(alias="actionAuth")]


class DocumentRecipientTypedDict(TypedDict):
    envelope_id: str
    role: DocumentRole
    read_status: DocumentCreateDocumentTemporaryReadStatus
    signing_status: DocumentCreateDocumentTemporarySigningStatus
    send_status: DocumentCreateDocumentTemporarySendStatus
    id: float
    email: str
    name: str
    token: str
    document_deleted_at: Nullable[str]
    expired: Nullable[str]
    signed_at: Nullable[str]
    auth_options: Nullable[DocumentCreateDocumentTemporaryRecipientAuthOptionsTypedDict]
    signing_order: Nullable[float]
    rejection_reason: Nullable[str]
    document_id: NotRequired[Nullable[float]]
    template_id: NotRequired[Nullable[float]]


class DocumentRecipient(BaseModel):
    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    role: DocumentRole

    read_status: Annotated[
        DocumentCreateDocumentTemporaryReadStatus, pydantic.Field(alias="readStatus")
    ]

    signing_status: Annotated[
        DocumentCreateDocumentTemporarySigningStatus,
        pydantic.Field(alias="signingStatus"),
    ]

    send_status: Annotated[
        DocumentCreateDocumentTemporarySendStatus, pydantic.Field(alias="sendStatus")
    ]

    id: float

    email: str

    name: str

    token: str

    document_deleted_at: Annotated[
        Nullable[str], pydantic.Field(alias="documentDeletedAt")
    ]

    expired: Nullable[str]

    signed_at: Annotated[Nullable[str], pydantic.Field(alias="signedAt")]

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryRecipientAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    signing_order: Annotated[Nullable[float], pydantic.Field(alias="signingOrder")]

    rejection_reason: Annotated[Nullable[str], pydantic.Field(alias="rejectionReason")]

    document_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="documentId")
    ] = UNSET

    template_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="templateId")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["documentId", "templateId"]
        nullable_fields = [
            "documentDeletedAt",
            "expired",
            "signedAt",
            "authOptions",
            "signingOrder",
            "rejectionReason",
            "documentId",
            "templateId",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentFieldType(str, Enum):
    SIGNATURE = "SIGNATURE"
    FREE_SIGNATURE = "FREE_SIGNATURE"
    INITIALS = "INITIALS"
    NAME = "NAME"
    EMAIL = "EMAIL"
    DATE = "DATE"
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DROPDOWN = "DROPDOWN"


class DocumentTypeDropdown(str, Enum):
    DROPDOWN = "dropdown"


class DocumentValue3TypedDict(TypedDict):
    value: str


class DocumentValue3(BaseModel):
    value: str


class FieldMetaDocumentDropdownTypedDict(TypedDict):
    type: DocumentTypeDropdown
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentValue3TypedDict]]
    default_value: NotRequired[str]


class FieldMetaDocumentDropdown(BaseModel):
    type: DocumentTypeDropdown

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentValue3]] = None

    default_value: Annotated[Optional[str], pydantic.Field(alias="defaultValue")] = None


class DocumentTypeCheckbox(str, Enum):
    CHECKBOX = "checkbox"


class DocumentValue2TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentValue2(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentDirection2(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class FieldMetaDocumentCheckboxTypedDict(TypedDict):
    type: DocumentTypeCheckbox
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentValue2TypedDict]]
    validation_rule: NotRequired[str]
    validation_length: NotRequired[float]
    direction: NotRequired[DocumentDirection2]


class FieldMetaDocumentCheckbox(BaseModel):
    type: DocumentTypeCheckbox

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentValue2]] = None

    validation_rule: Annotated[
        Optional[str], pydantic.Field(alias="validationRule")
    ] = None

    validation_length: Annotated[
        Optional[float], pydantic.Field(alias="validationLength")
    ] = None

    direction: Optional[DocumentDirection2] = DocumentDirection2.VERTICAL


class DocumentTypeRadio(str, Enum):
    RADIO = "radio"


class DocumentValue1TypedDict(TypedDict):
    id: float
    checked: bool
    value: str


class DocumentValue1(BaseModel):
    id: float

    checked: bool

    value: str


class DocumentDirection1(str, Enum):
    VERTICAL = "vertical"
    HORIZONTAL = "horizontal"


class FieldMetaDocumentRadioTypedDict(TypedDict):
    type: DocumentTypeRadio
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    values: NotRequired[List[DocumentValue1TypedDict]]
    direction: NotRequired[DocumentDirection1]


class FieldMetaDocumentRadio(BaseModel):
    type: DocumentTypeRadio

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    values: Optional[List[DocumentValue1]] = None

    direction: Optional[DocumentDirection1] = DocumentDirection1.VERTICAL


class DocumentTypeNumber(str, Enum):
    NUMBER = "number"


class DocumentTextAlign6(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentVerticalAlign2(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class FieldMetaDocumentNumberTypedDict(TypedDict):
    type: DocumentTypeNumber
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    number_format: NotRequired[Nullable[str]]
    value: NotRequired[str]
    min_value: NotRequired[Nullable[float]]
    max_value: NotRequired[Nullable[float]]
    text_align: NotRequired[DocumentTextAlign6]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[DocumentVerticalAlign2]]


class FieldMetaDocumentNumber(BaseModel):
    type: DocumentTypeNumber

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    number_format: Annotated[
        OptionalNullable[str], pydantic.Field(alias="numberFormat")
    ] = UNSET

    value: Optional[str] = None

    min_value: Annotated[OptionalNullable[float], pydantic.Field(alias="minValue")] = (
        UNSET
    )

    max_value: Annotated[OptionalNullable[float], pydantic.Field(alias="maxValue")] = (
        UNSET
    )

    text_align: Annotated[
        Optional[DocumentTextAlign6], pydantic.Field(alias="textAlign")
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[DocumentVerticalAlign2], pydantic.Field(alias="verticalAlign")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "numberFormat",
            "value",
            "minValue",
            "maxValue",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = [
            "numberFormat",
            "minValue",
            "maxValue",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypeText(str, Enum):
    TEXT = "text"


class DocumentTextAlign5(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class DocumentVerticalAlign1(str, Enum):
    TOP = "top"
    MIDDLE = "middle"
    BOTTOM = "bottom"


class FieldMetaDocumentTextTypedDict(TypedDict):
    type: DocumentTypeText
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text: NotRequired[str]
    character_limit: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign5]
    line_height: NotRequired[Nullable[float]]
    letter_spacing: NotRequired[Nullable[float]]
    vertical_align: NotRequired[Nullable[DocumentVerticalAlign1]]


class FieldMetaDocumentText(BaseModel):
    type: DocumentTypeText

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text: Optional[str] = None

    character_limit: Annotated[
        Optional[float], pydantic.Field(alias="characterLimit")
    ] = None

    text_align: Annotated[
        Optional[DocumentTextAlign5], pydantic.Field(alias="textAlign")
    ] = None

    line_height: Annotated[
        OptionalNullable[float], pydantic.Field(alias="lineHeight")
    ] = UNSET

    letter_spacing: Annotated[
        OptionalNullable[float], pydantic.Field(alias="letterSpacing")
    ] = UNSET

    vertical_align: Annotated[
        OptionalNullable[DocumentVerticalAlign1], pydantic.Field(alias="verticalAlign")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "label",
            "placeholder",
            "required",
            "readOnly",
            "fontSize",
            "text",
            "characterLimit",
            "textAlign",
            "lineHeight",
            "letterSpacing",
            "verticalAlign",
        ]
        nullable_fields = ["lineHeight", "letterSpacing", "verticalAlign"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentTypeDate(str, Enum):
    DATE = "date"


class DocumentTextAlign4(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentDateTypedDict(TypedDict):
    type: DocumentTypeDate
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign4]


class FieldMetaDocumentDate(BaseModel):
    type: DocumentTypeDate

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentTextAlign4], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeEmail(str, Enum):
    EMAIL = "email"


class DocumentTextAlign3(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentEmailTypedDict(TypedDict):
    type: DocumentTypeEmail
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign3]


class FieldMetaDocumentEmail(BaseModel):
    type: DocumentTypeEmail

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentTextAlign3], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeName(str, Enum):
    NAME = "name"


class DocumentTextAlign2(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentNameTypedDict(TypedDict):
    type: DocumentTypeName
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign2]


class FieldMetaDocumentName(BaseModel):
    type: DocumentTypeName

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentTextAlign2], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeInitials(str, Enum):
    INITIALS = "initials"


class DocumentTextAlign1(str, Enum):
    LEFT = "left"
    CENTER = "center"
    RIGHT = "right"


class FieldMetaDocumentInitialsTypedDict(TypedDict):
    type: DocumentTypeInitials
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]
    text_align: NotRequired[DocumentTextAlign1]


class FieldMetaDocumentInitials(BaseModel):
    type: DocumentTypeInitials

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12

    text_align: Annotated[
        Optional[DocumentTextAlign1], pydantic.Field(alias="textAlign")
    ] = None


class DocumentTypeSignature(str, Enum):
    SIGNATURE = "signature"


class FieldMetaDocumentSignatureTypedDict(TypedDict):
    type: DocumentTypeSignature
    label: NotRequired[str]
    placeholder: NotRequired[str]
    required: NotRequired[bool]
    read_only: NotRequired[bool]
    font_size: NotRequired[float]


class FieldMetaDocumentSignature(BaseModel):
    type: DocumentTypeSignature

    label: Optional[str] = None

    placeholder: Optional[str] = None

    required: Optional[bool] = None

    read_only: Annotated[Optional[bool], pydantic.Field(alias="readOnly")] = None

    font_size: Annotated[Optional[float], pydantic.Field(alias="fontSize")] = 12


DocumentFieldMetaUnionTypedDict = TypeAliasType(
    "DocumentFieldMetaUnionTypedDict",
    Union[
        FieldMetaDocumentSignatureTypedDict,
        FieldMetaDocumentInitialsTypedDict,
        FieldMetaDocumentNameTypedDict,
        FieldMetaDocumentEmailTypedDict,
        FieldMetaDocumentDateTypedDict,
        FieldMetaDocumentRadioTypedDict,
        FieldMetaDocumentDropdownTypedDict,
        FieldMetaDocumentCheckboxTypedDict,
        FieldMetaDocumentTextTypedDict,
        FieldMetaDocumentNumberTypedDict,
    ],
)


DocumentFieldMetaUnion = TypeAliasType(
    "DocumentFieldMetaUnion",
    Union[
        FieldMetaDocumentSignature,
        FieldMetaDocumentInitials,
        FieldMetaDocumentName,
        FieldMetaDocumentEmail,
        FieldMetaDocumentDate,
        FieldMetaDocumentRadio,
        FieldMetaDocumentDropdown,
        FieldMetaDocumentCheckbox,
        FieldMetaDocumentText,
        FieldMetaDocumentNumber,
    ],
)


class DocumentFieldTypedDict(TypedDict):
    envelope_id: str
    envelope_item_id: str
    type: DocumentFieldType
    id: float
    secondary_id: str
    recipient_id: float
    page: float
    position_x: Any
    position_y: Any
    width: Any
    height: Any
    custom_text: str
    inserted: bool
    field_meta: Nullable[DocumentFieldMetaUnionTypedDict]
    document_id: NotRequired[Nullable[float]]
    template_id: NotRequired[Nullable[float]]


class DocumentField(BaseModel):
    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    envelope_item_id: Annotated[str, pydantic.Field(alias="envelopeItemId")]

    type: DocumentFieldType

    id: float

    secondary_id: Annotated[str, pydantic.Field(alias="secondaryId")]

    recipient_id: Annotated[float, pydantic.Field(alias="recipientId")]

    page: float

    position_x: Annotated[Any, pydantic.Field(alias="positionX")]

    position_y: Annotated[Any, pydantic.Field(alias="positionY")]

    width: Any

    height: Any

    custom_text: Annotated[str, pydantic.Field(alias="customText")]

    inserted: bool

    field_meta: Annotated[
        Nullable[DocumentFieldMetaUnion], pydantic.Field(alias="fieldMeta")
    ]

    document_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="documentId")
    ] = UNSET

    template_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="templateId")
    ] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["documentId", "templateId"]
        nullable_fields = ["fieldMeta", "documentId", "templateId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryDocumentTypedDict(TypedDict):
    visibility: DocumentVisibility
    status: DocumentCreateDocumentTemporaryStatus
    source: DocumentCreateDocumentTemporarySource
    id: float
    external_id: Nullable[str]
    user_id: float
    auth_options: Nullable[DocumentCreateDocumentTemporaryAuthOptionsTypedDict]
    form_values: Nullable[Dict[str, DocumentFormValuesTypedDict]]
    title: str
    created_at: str
    updated_at: str
    completed_at: Nullable[str]
    deleted_at: Nullable[str]
    team_id: float
    folder_id: Nullable[str]
    envelope_id: str
    internal_version: float
    document_data: DocumentCreateDocumentTemporaryDocumentDataTypedDict
    document_meta: DocumentCreateDocumentTemporaryDocumentMetaTypedDict
    envelope_items: List[DocumentCreateDocumentTemporaryEnvelopeItemTypedDict]
    folder: Nullable[DocumentCreateDocumentTemporaryFolderTypedDict]
    recipients: List[DocumentRecipientTypedDict]
    fields: List[DocumentFieldTypedDict]
    template_id: NotRequired[Nullable[float]]
    document_data_id: NotRequired[str]


class DocumentCreateDocumentTemporaryDocument(BaseModel):
    visibility: DocumentVisibility

    status: DocumentCreateDocumentTemporaryStatus

    source: DocumentCreateDocumentTemporarySource

    id: float

    external_id: Annotated[Nullable[str], pydantic.Field(alias="externalId")]

    user_id: Annotated[float, pydantic.Field(alias="userId")]

    auth_options: Annotated[
        Nullable[DocumentCreateDocumentTemporaryAuthOptions],
        pydantic.Field(alias="authOptions"),
    ]

    form_values: Annotated[
        Nullable[Dict[str, DocumentFormValues]], pydantic.Field(alias="formValues")
    ]

    title: str

    created_at: Annotated[str, pydantic.Field(alias="createdAt")]

    updated_at: Annotated[str, pydantic.Field(alias="updatedAt")]

    completed_at: Annotated[Nullable[str], pydantic.Field(alias="completedAt")]

    deleted_at: Annotated[Nullable[str], pydantic.Field(alias="deletedAt")]

    team_id: Annotated[float, pydantic.Field(alias="teamId")]

    folder_id: Annotated[Nullable[str], pydantic.Field(alias="folderId")]

    envelope_id: Annotated[str, pydantic.Field(alias="envelopeId")]

    internal_version: Annotated[float, pydantic.Field(alias="internalVersion")]

    document_data: Annotated[
        DocumentCreateDocumentTemporaryDocumentData,
        pydantic.Field(alias="documentData"),
    ]

    document_meta: Annotated[
        DocumentCreateDocumentTemporaryDocumentMeta,
        pydantic.Field(alias="documentMeta"),
    ]

    envelope_items: Annotated[
        List[DocumentCreateDocumentTemporaryEnvelopeItem],
        pydantic.Field(alias="envelopeItems"),
    ]

    folder: Nullable[DocumentCreateDocumentTemporaryFolder]

    recipients: List[DocumentRecipient]

    fields: List[DocumentField]

    template_id: Annotated[
        OptionalNullable[float], pydantic.Field(alias="templateId")
    ] = UNSET

    document_data_id: Annotated[
        Optional[str], pydantic.Field(alias="documentDataId")
    ] = ""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["templateId", "documentDataId"]
        nullable_fields = [
            "externalId",
            "authOptions",
            "formValues",
            "completedAt",
            "deletedAt",
            "folderId",
            "templateId",
            "folder",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class DocumentCreateDocumentTemporaryResponseTypedDict(TypedDict):
    r"""Successful response"""

    document: DocumentCreateDocumentTemporaryDocumentTypedDict
    upload_url: str


class DocumentCreateDocumentTemporaryResponse(BaseModel):
    r"""Successful response"""

    document: DocumentCreateDocumentTemporaryDocument

    upload_url: Annotated[str, pydantic.Field(alias="uploadUrl")]
