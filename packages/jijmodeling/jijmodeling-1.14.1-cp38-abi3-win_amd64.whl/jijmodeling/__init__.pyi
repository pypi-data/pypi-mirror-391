# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import numpy
import numpy.typing
import typing
from . import experimental
from . import range
from enum import Enum

__version__: builtins.str
class AbsOp:
    r"""
    A class for representing the absolute value
    
    The `AbsOp` class is used to represent the absolute value.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    - `operand`: The operand.
    
    Note
    -----
    The `AbsOp` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __neg__(self) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class AddOp:
    r"""
    A class for representing addition
    
    The `AddOp` class is used to represent addition (`+`) of an arbitrary number of operands.
    For example `a + b + c + d` would be one `AddOp` object.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    `terms`: A sequence of operands to be added.
    
    Note
    -----
    The `AddOp` class does not have a constructor. Its intended
    instantiation method is by calling the addition operation on other
    expressions.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class AndOp:
    r"""
    A class for representing logical AND
    
    The `AndOp` class is used to represent logical AND (`&`) of an arbitrary number of operands.
    For example `a & b & c & d` would be one `AndOp` object.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `terms`: A sequence of operands to apply the AND operation.
    
    Note
    -----
    The `AndOp` class does not have a constructor.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class ArrayLength:
    r"""
    A class for referring to the length of an array at a given axis.
    
    The ArrayLength class is to refer to the number of elements of an axis in an array.
    
    This class is not intended to be constructed directly. Instead, we
    recommend using the `len_at` method of `Placeholder`, `Element` or
    `Subscript`.
    
    Attributes
    -----------
    - `array`: A variable with `ndim >= 1`.
    - `axis`: An axis index. A $n$-dimensional variable has $n$ axes. Axis 0 is the array's outermost axis and $n-1$ is the innermost.
    - `description` (`str`, optional): A description of the ArrayLength instance.
    
    Raises
    -------
    `ModelingError`: Raises if `axis` >= `array.ndim`.
    
    Examples
    ---------
    Create a length of axis 0 in a 2-dimensional placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=2)
    >>> N = a.len_at(0, latex="N")
    
    ```
    """
    @property
    def array(self) -> Placeholder | Element | Subscript: ...
    @property
    def axis(self) -> builtins.int: ...
    @property
    def description(self) -> typing.Optional[builtins.str]: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __new__(cls, array:Placeholder | Element | Subscript, axis:builtins.int, *, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> ArrayLength: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...

class BinaryVar:
    r"""
    A class for creating a binary variable
    
    The BinaryVar class is used to create a binary variable.
    
    The index operator (`[]`) of a binary variable with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the binary variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the binary variable. Empty if the variable is not multi-dimensional.
    - `description` (`str`): A description of the binary variable.
    
    Args
    -----
    - `name` (`str`): A name of the binary variable.
    - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
      - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
    - `latex` (`str`, optional): A LaTeX-name of the binary variable to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the binary variable.
    
    Examples
    ---------
    Create a scalar binary variable whose name is "z".
    
    ```python
    >>> import jijmodeling as jm
    >>> z = jm.BinaryVar("z")
    
    ```
    
    Create a 2-dimensional binary variable whose name is "x" and has a 2x2 shape.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.BinaryVar("x", shape=[2, 2])
    
    ```
    
    Create a 1-dimensional binary variable with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.BinaryVar("x", shape=[124])
    >>> x[123]
    BinaryVar(name='x', shape=[NumberLit(value=124)])[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, shape:typing.Optional[typing.Sequence[typing.Any]]=None, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> BinaryVar: ...
    def __getitem__(self, index:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...

class CeilOp:
    r"""
    A class for representing the ceil operator
    
    The `CeilOp` class is used to represent the ceil operator.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    - `operand`: The operand.
    
    Note
    -----
    The `CeilOp` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...

class Constraint:
    r"""
    A class for creating a constraint
    
    The Constraint class is used to create a constraint.
    
    Attributes
    -----------
    - `name` (`str`): A name of the constraint.
    - `sense`: equal sign (`=`) or inequality sign (`>=` or `<=`) included in the expression.
    - `expression`: The (in)equality equation of the constraint.
    - `forall` (`list`): A list that stores forall indices.
    
    Args
    -----
    - `name` (`str`): A name of the constraint.
    - `expression`: The (in)equality equation of the constraint.
    - `forall`: A list that stores forall indices. Defaults to None.
    
    Raises
    -------
    `ModelingError`: Raises if `expression` does not contain any decision variable.
    
    Expression
    -----------
    Create an equality constraint that the sum of $N$ binary variables is equal to one.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N,))
    >>> repr(jm.Constraint("constraint", jm.sum(i, x[i]) == 1))
    'Constraint(name="constraint", expression=sum(i in [0..N), x[i]) == 1)'
    
    ```
    
    Create an inequality constraint with forall.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> j = jm.Element("j", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N, N))
    >>> repr(jm.Constraint("constraint", jm.sum(i, x[i,j]) == 1, forall=j))
    'Constraint(name="constraint", expression=sum(i in [0..N), x[i, j]) == 1, forall=[j])'
    
    ```
    
    Create an inequality constraint with conditional forall.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> j = jm.Element("j", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N, N))
    >>> repr(jm.Constraint("constraint", x[i,j] <= 2, forall=[i, (j, j != i)]))
    'Constraint(name="constraint", expression=x[i, j] <= 2, forall=[i, (j, j != i)])'
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def sense(self) -> ConstraintSense: ...
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    @property
    def forall(self) -> Element | tuple[Element, typing.Optional[typing.Any]] | builtins.list[Element | tuple[Element, typing.Optional[typing.Any]]]: ...
    @property
    def expression(self) -> typing.Any: ...
    def __new__(cls, name:builtins.str, expression:typing.Any, *, forall:typing.Optional[Element | tuple[Element, typing.Optional[typing.Any]] | typing.Sequence[Element | tuple[Element, typing.Optional[typing.Any]]]]=None) -> Constraint: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def is_equality(self) -> builtins.bool:
        r"""
        Returns true if the constraint is an equality constraint.
        
        Returns
        --------
        `bool`: True if the constraint is an equality constraint. Otherwise, False.
        
        Examples
        ---------
        
        ```python
        >>> import jijmodeling as jm
        >>> N = jm.Placeholder("N")
        >>> i = jm.Element("i", belong_to=N)
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> constraint = jm.Constraint("constraint", jm.sum(i, x[i]) == 1)
        >>> assert constraint.is_equality()
        
        ```
        """
    def is_inequality(self) -> builtins.bool:
        r"""
        Returns true if the constraint is an inequality constraint.
        
        Returns
        --------
        `bool`: True if the constraint is an inequality constraint. Otherwise, False.
        
        Examples
        ---------
        
        ```python
        >>> import jijmodeling as jm
        >>> N = jm.Placeholder("N")
        >>> i = jm.Element("i", belong_to=N)
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> constraint = jm.Constraint("constraint", jm.sum(i, x[i]) <= 1)
        >>> assert constraint.is_inequality()
        
        ```
        """

class ContinuousVar:
    r"""
    A class for creating a continuous variable
    
    The ContinuousVar class is used to create a continuous variable.
    The lower and upper bounds of the variable can be specified by:
    - an integer value
    - a float value
    - a scalar expression that does not contains any decision variable
    - a Placeholder object whose dimensionality is equal to that of this variable.
    - a subscripted variable whose dimensionality is equal to that of this variable.
    
    The index operator (`[]`) of a variable with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the continuous variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the integer variable. Empty if the variable is not multi-dimensional.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `description` (`str`): A description of the continuous variable.
    
    Args
    -----
    - `name` (`str`): A name of the continuous variable.
    - `shape` (`list | tuple`): A sequence with the size of each dimension of the continuous variable. Defaults to an empty tuple (a scalar value).
      - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `latex` (`str`, optional): A LaTeX-name of the continuous variable to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the continuous variable.
    
    Raises
    -------
    `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim` is neither `0` nor the same value as `ndim` of the continuous variable.
    
    Examples
    ---------
    Create a scalar continuous variable whose name is "z" and domain is `[-1, 1]`.
    
    ```python
    >>> import jijmodeling as jm
    >>> z = jm.ContinuousVar("z", lower_bound=-1, upper_bound=1)
    
    ```
    
    Create a 2-dimensional continuous variable...
    - whose name is "x".
    - whose domain is [0, 2].
    - where each dimension has length 2 (making this a 2x2 matrix).
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.ContinuousVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
    
    ```
    
    Create a 1-dimensional continuous variable with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.ContinuousVar("x", shape=[124], lower_bound=0, upper_bound=2)
    >>> x[123]
    ContinuousVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def lower_bound(self) -> typing.Any | Placeholder | Subscript: ...
    @property
    def upper_bound(self) -> typing.Any | Placeholder | Subscript: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, shape:typing.Optional[typing.Sequence[typing.Any]]=None, lower_bound:typing.Any | Placeholder | Subscript, upper_bound:typing.Any | Placeholder | Subscript, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> ContinuousVar: ...
    def __getitem__(self, index:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...

class CustomPenaltyTerm:
    r"""
    A class for creating a custom penalty term
    
    The CustomPenaltyTerm class is used to create a custom penalty term.
    
    Attributes
    -----------
    - `name` (`str`): A name of the custom penalty term.
    - `expression`: The expression of the custom penalty term.
    - `forall` (`list`): A list that stores forall indices.
    
    Args
    -----
    - `name` (`str`): A name of the custom penalty term.
    - `expression`: The expression of the custom penalty term.
    - `forall`: A list that stores forall indices. Defaults to None.
    
    Raises
    -------
    `ModelingError`: Raises if `expression` does not contain any decision variable.
    
    Expression
    -----------
    Create a custom penalty term.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N,))
    >>> repr(jm.CustomPenaltyTerm("custom penalty term", (jm.sum(i, x[i]) - 1)**2))  # doctest: +ELLIPSIS
    'CustomPenaltyTerm(name="custom penalty term", expression=((sum(i in [0..N), x[i]) - 1) ** 2))'
    
    ```
    
    Create a custom penalty term with forall.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> j = jm.Element("j", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N, N))
    >>> repr(jm.CustomPenaltyTerm("custom penalty term", (jm.sum(i, x[i,j]) - 1)**2, forall=j))  # doctest: +ELLIPSIS
    'CustomPenaltyTerm(name="custom penalty term", expression=((sum(i in [0..N), x[i, j]) - 1) ** 2), forall=[j])'
    
    ```
    
    Create a custom penalty term with conditional forall.
    
    ```python
    >>> import jijmodeling as jm
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=N)
    >>> j = jm.Element("j", belong_to=N)
    >>> x = jm.BinaryVar("x", shape=(N, N))
    >>> repr(jm.CustomPenaltyTerm("custom penalty term", (x[i,j] - 2)**2, forall=[i, (j, j != i)]))  # doctest: +ELLIPSIS
    'CustomPenaltyTerm(name="custom penalty term", expression=((x[i, j] - 2) ** 2), forall=[i, (j, j != i)])'
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def expression(self) -> typing.Any: ...
    @property
    def forall(self) -> Element | tuple[Element, typing.Optional[typing.Any]] | builtins.list[Element | tuple[Element, typing.Optional[typing.Any]]]: ...
    def __new__(cls, name:builtins.str, expression:typing.Any, *, forall:typing.Optional[Element | tuple[Element, typing.Optional[typing.Any]] | typing.Sequence[Element | tuple[Element, typing.Optional[typing.Any]]]]=None) -> CustomPenaltyTerm: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class DummyIndexedVar:
    r"""
    A class for representing a subscripted variable with dummy indices
    
    The `DummyIndexedVar` class is an intermediate representation to support syntactic sugar of sum/prod with slices.
    
    Note
    -----
    The `DummyIndexedVar` class does not have a constructor.
    """
    def sum(self) -> SumOp:
        r"""
        Take a sum of the decision variable over the elements for which the slice is given and return a SumOp object.
        
        Returns
        --------
        `SumOp`: A SumOp object taken a sum of the decision variable over the elements for which the slice is given.
        
        Note
        -----
        An automatically created dummy index
        - has a name of the form `__dummy_{decision_var.name}_{axis}` where `axis` is the axis of the slice.
        - belongs to a range whose start defaults to 0 and end defaults to the length of the axis.
        - has description of the form `dummy index at {axis} for {decision_var.name}`.
        - has latex string of the form `\\ast_{axis}`.
        
        Examples
        ---------
        Create a SumOp object taken a sum of the 2-dim binary variable over the 0-th elements for which the slice is given.
        
        ```python
        >>> import jijmodeling as jm
        >>> n = jm.Placeholder("n")
        >>> x = jm.BinaryVar("x", shape=(n, n))
        >>> i = jm.Element("__dummy_x_0", belong_to=n)
        >>> j = jm.Element("j", belong_to=n)
        >>> assert jm.is_same(x[:, j].sum(), jm.sum(i, x[i, j]))
        
        ```
        """
    def prod(self) -> ProdOp:
        r"""
        Take a prod of the decision variable over the elements for which the slice is given and return a `ProdOp` object.
        
        Returns
        --------
        `ProdOp`: A ProdOp object taken a prod of the decision variable over the elements for which the slice is given.
        
        Note
        -----
        An automatically created dummy index
        - has a name of the form `__dummy_{decision_var.name}_{axis}` where `axis` is the axis of the slice.
        - belongs to a range whose start defaults to 0 and end defaults to the length of the axis.
        - has description of the form `dummy index at {axis} for {decision_var.name}`.
        - has latex string of the form `\\ast_{axis}`.
        
        Examples
        ---------
        Create a `ProdOp` object taken a prod of the 2-dim binary variable over the 0-th elements for which the slice is given.
        
        ```python
        >>> import jijmodeling as jm
        >>> n = jm.Placeholder("n")
        >>> x = jm.BinaryVar("x", shape=(n, n))
        >>> i = jm.Element("__dummy_x_0", belong_to=n)
        >>> j = jm.Element("j", belong_to=n)
        >>> assert jm.is_same(x[:, j].prod(), jm.prod(i, x[i, j]))
        
        ```
        """

class Element:
    r"""
    A class for creating an element
    
    The `Element` class is used to create an element.
    It is used in the following cases:
    - an index of summation $\displaystyle \sum$ (`SumOp`)
    - an index of product $\displaystyle \prod$ (`ProdOp`)
    - a bound variable of the universal quantifier $\forall$ (`Forall`)
    
    Elements specify a set to which they belong. The set can be:
    1. A half-open range, where the lower bound is included and the upper bound is excluded.
    2. A `Placeholder`, `Element`, or `Subscript` object with `ndim >= 1`.
    
    Ranges are generally specified with tuples as `(start, end)`. For
    convenience, passing a single number or scalar object as the argument is
    interpreted as the `end` of a range starting from zero.
    
    The index operator (`[]`) of an element with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the element.
    - `ndim` (`int`): The number of dimensions of the element. The value is one less than the value of `belong_to.ndim`.
    - `description` (`str`): A description of the element.
    - `belong_to`: A set the element belongs to.
    
    Args
    -----
    - `name` (`str`): A name of the element.
    - `belong_to`: A set the element belongs to.
    - `latex` (`str`, optional): A LaTeX-name of the element to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the element.
    
    Examples
    ---------
    Note that `belong_to` is a positional argument, not a keyword
    argument, and so does not need to be written out. This is done in some
    of these examples for clarity.
    
    Create an element that belongs to a half-open range.
    
    ```python
    >>> import jijmodeling as jm
    >>> i = jm.Element("i", belong_to=(0,10))
    
    ```
    
    If you pass a scalar as the `belong_to` argument, the set that the element belongs to is a range starting at 0 going up to that value.
    
    ```python
    >>> import jijmodeling as jm
    >>> i = jm.Element("i", 10)
    >>> assert jm.is_same(i, jm.Element("i", belong_to=(0,10)))
    
    ```
    
    The applies not just to numbers, but certain scalars, like `Placeholder` (with `ndim == 0`).
    
    ```python
    >>> import jijmodeling as jm
    >>> n = jm.Placeholder("N")
    >>> i = jm.Element("i", n)
    >>> assert jm.is_same(i, jm.Element("i", belong_to=(0,n)))
    
    ```
    
    Create an element that belongs to a 1-dimensional placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> E = jm.Placeholder("E", ndim=1)
    >>> e = jm.Element("e", E)
    
    ```
    
    Create a 1-dimensional element with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=2)
    >>> e = jm.Element("e", a)
    >>> e[123]
    Element(name='e', belong_to=Placeholder(name='a', ndim=2))[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def belong_to(self) -> Range | Placeholder | Element | Subscript: ...
    @property
    def description(self) -> typing.Optional[builtins.str]: ...
    @property
    def shape(self) -> tuple: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __getitem__(self, index:typing.Any) -> Subscript: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __new__(cls, name:builtins.str, belong_to:typing.Any, *, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Element: ...
    def len_at(self, axis:builtins.int, *, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> ArrayLength: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...

class EqualOp:
    r"""
    A class for representing the equal operator
    
    The `EqualOp` class is used to represent the equal operator (`==`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `EqualOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class Evaluation:
    r"""
    A class for evaluation.
    
    The Evaluation class is to represent the result of evaluating a model.
    
    Attributes:
        energy (numpy.ndarray): The value of energy of each sample.
        objective (numpy.ndarray): The value of an objective function of each sample.
        constraint_violations (dict[str, numpy.ndarray]): The constraint violation of each sample.
        constraint_forall (dict[str, numpy.ndarray]): The constraint forall of each sample.
        constraint_values (numpy.ndarray): The constraint value of each sample.
        penalty (dict[str, numpy.ndarray]): The penalty of each sample.
    """
    @property
    def energy(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def objective(self) -> numpy.typing.NDArray[numpy.float64]: ...
    @property
    def constraint_violations(self) -> dict: ...
    @property
    def constraint_forall(self) -> dict: ...
    @property
    def constraint_values(self) -> builtins.list[dict]: ...
    @property
    def penalty(self) -> dict: ...
    @property
    def constraint_expr_values(self) -> builtins.list[builtins.dict[builtins.str, dict]]:
        r"""
        Return the values for the each constraint.
        
        The return value is a list of dictionaries.
        Each dictionary has the keys of the constraint names and the dictionary values.
        The dictionary values have the keys of the forall indices as tuple and the values for the forall indices.
        
        Returns:
            A list of dictionaries.
        """
    @energy.setter
    def energy(self, value: builtins.list[builtins.float]) -> None: ...
    @objective.setter
    def objective(self, value: builtins.list[builtins.float]) -> None: ...
    @constraint_violations.setter
    def constraint_violations(self, value: builtins.dict[builtins.str, builtins.list[builtins.float]]) -> None: ...
    @constraint_forall.setter
    def constraint_forall(self, value: builtins.dict[builtins.str, builtins.list[builtins.list[builtins.int]]]) -> None: ...
    @constraint_values.setter
    def constraint_values(self, value: builtins.list[builtins.dict[builtins.str, builtins.list[builtins.float]]]) -> None: ...
    @penalty.setter
    def penalty(self, value: builtins.dict[builtins.str, builtins.list[builtins.float]]) -> None: ...
    def __new__(cls, energy:typing.Optional[typing.Sequence[builtins.float]]=None, objective:typing.Optional[typing.Sequence[builtins.float]]=None, constraint_violations:typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.float]]]=None, constraint_forall:typing.Optional[typing.Mapping[builtins.str, typing.Sequence[typing.Sequence[builtins.int]]]]=None, constraint_values:typing.Optional[typing.Sequence[typing.Mapping[builtins.str, typing.Sequence[builtins.float]]]]=None, penalty:typing.Optional[typing.Mapping[builtins.str, typing.Sequence[builtins.float]]]=None) -> Evaluation: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:Evaluation, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns:
            dict: A dict whose keys are name of the Evaluation's fields.
        """
    @staticmethod
    def from_dict(dict:dict) -> Evaluation:
        r"""
        Create a Evaluation object from the given dict.
        
        If a key is not the name of the Evaluation fields, the value value is ignored.
        
        Args:
            dict: A dict whose keys are name of the Evaluation fields.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the Evaluation object into a JSON string.
        
        Returns:
            str: A JSON string.
        
        Note:
            A numpy array is converted into a list.
        """
    @staticmethod
    def from_json(json:str) -> Evaluation:
        r"""
        Create a Evaluation object from the JSON string.
        
        Args:
            json (str): A JSON string.
        
        Returns:
            Evaluation: An Evaluation object.
        """
    def to_pandas(self) -> typing.Any:
        r"""
        Convert into a pandas DataFrame.
        
        Returns:
            pandas.DataFrame: A pandas DataFrame.
        """

class FloorOp:
    r"""
    A class for representing the floor operator
    
    The `FloorOp` class is used to represent the floor operator.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    - `operand`: The operand.
    
    Note
    -----
    The `FloorOp` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class GreaterThanEqualOp:
    r"""
    A class for representing the greater than equal operator
    
    The `GreaterThanEqualOp` class is used to represent the greater than equal operator (`>=`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `GreaterThanEqualOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class GreaterThanOp:
    r"""
    A class for representing the greater than operator
    
    The `GreaterThanOp` class is used to represent the greater than operator (`>`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `GreaterThanOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class IntegerVar:
    r"""
    A class for creating an integer variable
    
    The IntegerVar class is used to create an integer variable.
    The lower and upper bounds of the variable can be specified by:
    - an integer value
    - a float value
    - a scalar expression that does not contains any decision variable
    - a Placeholder object whose dimensionality is equal to that of this variable.
    - a subscripted variable whose dimensionality is equal to that of this variable.
    
    The index operator (`[]`) of a variable with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the integer variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the integer variable. Empty if the variable is not multi-dimensional.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `description` (`str`): A description of the integer variable.
    
    Args
    -----
    - `name` (`str): A name of the integer variable.
    - `shape` (`list | tuple`): A sequence with the size of each dimension of the integer variable. Defaults to an empty tuple (a scalar value).
      - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `latex` (`str`, optional): A LaTeX-name of the integer variable to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the integer variable.
    
    Raises
    -------
    `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim`
    is neither `0` nor the same value as `ndim` of the integer variable.
    
    Examples
    ---------
    Create a scalar integer variable whose name is "z" and domain is `[-1, 1]`.
    
    ```python
    >>> import jijmodeling as jm
    >>> z = jm.IntegerVar("z", lower_bound=-1, upper_bound=1)
    
    ```
    
    Create a 2-dimensional integer variable...
    - whose name is "x".
    - whose domain is [0, 2].
    - where each dimension has length 2 (making this a 2x2 matrix).
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.IntegerVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
    
    ```
    
    Create a 1-dimensional integer variable with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.IntegerVar("x", shape=[124], lower_bound=0, upper_bound=2)
    >>> x[123]
    IntegerVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def lower_bound(self) -> typing.Any | Placeholder | Subscript: ...
    @property
    def upper_bound(self) -> typing.Any | Placeholder | Subscript: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, shape:typing.Optional[typing.Sequence[typing.Any]]=None, lower_bound:typing.Any | Placeholder | Subscript, upper_bound:typing.Any | Placeholder | Subscript, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> IntegerVar: ...
    def __getitem__(self, index:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...

class Interpreter:
    r"""
    Interpreter of the JijModeling AST
    
    This class is responsible for
    
    - Creating OMMX instance from the AST.
      - This means this module also has responsible to register decision variable ID for each decision variables in AST.
    - Manage instance data to be substituted into the `Placeholder`.
    
    Examples
    --------
    
    ```python
    >>> import jijmodeling as jm
    >>> import numpy as np
    
    Create a new interpreter with scalar instance data
    >>> interpreter = jm.Interpreter({"a": 1})
    
    Insert instance data after creating the interpreter
    >>> interpreter.insert_instance_data("b", 2) # scalar
    
    Python list and numpy array are supported
    >>> interpreter.insert_instance_data("c", [3, 4])
    >>> interpreter.insert_instance_data("d", [[1, 2], [3, 4]])
    >>> interpreter.insert_instance_data("e", np.array([3, 4]))
    
    JaggedArray, non-uniform multi-dimensional array is also supported
    >>> interpreter.insert_instance_data("f", [[[1, 2]], [[3, 4, 5]], [[6]]])
    >>> interpreter.insert_instance_data("g", jm.JaggedArray([[[1, 2]], [[3, 4, 5]], [[6]]]))
    
    You can get the instance data by using get_instance_data method
    >>> interpreter.get_instance_data("a")
    1.0
    
    Array are normalized to numpy array
    >>> interpreter.get_instance_data("c")
    array([3., 4.])
    >>> interpreter.get_instance_data("e")
    array([3., 4.])
    >>> interpreter.get_instance_data("f")  # doctest: +ELLIPSIS
    <jijmodeling.JaggedArray object at 0x...>
    
    Update instance data and re-evaluate expressions
    >>> a = jm.Placeholder("a")
    >>> x = jm.BinaryVar("x")
    >>> interpreter.eval_expr(a * x)  # Original evaluation with a = 1
    Function(x0)
    >>> interpreter.insert_instance_data("a", 3)  # Update value of 'a'
    >>> interpreter.eval_expr(a * x)  # Re-evaluate with updated value
    Function(3*x0)
    
    ```
    """
    @property
    def num_decision_variables(self) -> builtins.int: ...
    def __new__(cls, instance_data:dict) -> Interpreter: ...
    def insert_instance_data(self, key:builtins.str, value:builtins.float | numpy.typing.NDArray[numpy.float64] | JaggedArray | typing.Sequence[builtins.float] | typing.Sequence[typing.Sequence[builtins.float]] | typing.Sequence[typing.Sequence[typing.Sequence[builtins.float]]] | typing.Sequence[typing.Sequence[typing.Sequence[typing.Sequence[builtins.float]]]]) -> None: ...
    def get_instance_data(self, key:builtins.str) -> builtins.float | numpy.typing.NDArray[numpy.float64] | JaggedArray: ...
    def instance_data(self) -> builtins.dict[builtins.str, builtins.float | numpy.typing.NDArray[numpy.float64] | JaggedArray]: ...
    def __str__(self) -> builtins.str: ...
    def get_decision_variable_by_id(self, id:builtins.int) -> typing.Any: ...
    def get_decision_variable_by_name(self, name:builtins.str, subscript:typing.Optional[typing.Sequence[builtins.int]]=None) -> typing.Any: ...
    def eval_scalar(self, expr:typing.Any) -> builtins.float: ...
    def eval_expr(self, expr:typing.Any) -> typing.Any: ...
    def eval_constraints(self, constraints:Constraint) -> builtins.list[typing.Any]: ...
    def eval_problem(self, problem:Problem, hints:typing.Optional[typing.Sequence[typing.Literal['OneHot', 'SOS1']]]=None) -> typing.Any:
        r"""
        Evaluate the problem and returns `ommx.v1.Instance`.
        
        Args
        ----
        - `problem`: a `jijmodeling.Problem` object to compile.
        - `hints` (optional): a list of constraint hints to be detected during evaluation. When omitted or given `None`, the default constraint hints are used. Pass empty list to disable hint detection entirely.
        
        Returns
        -------
        `instance`: an OMMX v1 instance object.
        """

class InterpreterError(builtins.RuntimeError):
    r"""
    Error while interpreting the model.
    """
    ...

class JaggedArray:
    r"""
    Jagged array, a multi-dimensional array where each element can be an array of different length.
    
    Examples
    --------
    
    ```python
    >>> import jijmodeling as jm
    >>> arr = jm.JaggedArray([[[1, 2], [3, 4, 5]], [[6]]])
    
    # Three dimensional
    >>> assert arr.dim == 3
    
    # __getitem__ works
    >>> assert arr[0, 0, 0] == 1.0
    >>> assert arr[0, 0, 1] == 2.0
    >>> assert arr[0, 1, 0] == 3.0
    >>> assert arr[0, 1, 1] == 4.0
    >>> assert arr[0, 1, 2] == 5.0
    >>> assert arr[1, 0, 0] == 6.0
    
    # out of range
    >>> arr[0, 0, 2]
    Traceback (most recent call last):
     ...
    IndexError: Invalid index
    
    # dimension mismatch
    >>> arr[0, 0]
    Traceback (most recent call last):
     ...
    IndexError: Invalid index
    
    >>> assert arr.size_at([]) == 2  # [[1, 2], [3, 4, 5]] and [[6]]
    >>> assert arr.size_at([0]) == 2  # [1, 2] and [3, 4, 5]
    >>> assert arr.size_at([1]) == 1  # [[6]]
    >>> assert arr.size_at([0, 0]) == 2  # [1, 2]
    >>> assert arr.size_at([0, 1]) == 3  # [3, 4, 5]
    >>> assert arr.size_at([1, 0]) == 1  # [6]
    
    ```
    """
    @property
    def dim(self) -> builtins.int: ...
    def __new__(cls, obj:typing.Any) -> JaggedArray: ...
    def __str__(self) -> builtins.str: ...
    def __eq__(self, other:typing.Any) -> builtins.bool: ...
    def get(self, index:typing.Sequence[builtins.int]) -> builtins.float: ...
    def __getitem__(self, index:typing.Sequence[builtins.int]) -> builtins.float: ...
    def size_at(self, index:typing.Sequence[builtins.int]) -> builtins.int: ...

class LessThanEqualOp:
    r"""
    A class for representing the less than equal operator
    
    The `LessThanEqualOp` class is used to represent the less than equal operator (`<=`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `LessThanEqualOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class LessThanOp:
    r"""
    A class for representing the less than operator
    
    The `LessThanOp` class is used to represent the less than operator (`<`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `LessThanOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class LnOp:
    r"""
    A class for representing the natural logarithm
    
    The `LnOp` class is used to represent the natural logarithm.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    `operand`: The operand.
    
    Note
    -----
    The `LnOp` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...

class Log10Op:
    r"""
    A class for representing the base 10 logarithm
    
    The `Log10Op` class is used to represent the base 10 logarithm.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    - `operand`: The operand.
    
    Note
    -----
    The `Log10Op` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...

class Log2Op:
    r"""
    A class for representing the base 2 logarithm
    
    The `Log2Op` class is used to represent the base 2 logarithm.
    The number of dimensions of the operand is zero.
    
    Attributes
    -----------
    `operand`: The operand.
    
    Note
    -----
    The `Log2Op` class does not have a constructor.
    """
    @property
    def operand(self) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...

class MaxOp:
    r"""
    A class for representing the maximum value.
    
    The MaxOp class is used to represent the minimum value of operands.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `terms`: A sequence of operands.
    
    Note
    -----
    The `MaxOp` class does not have a constructor. Its intended
    instantiation method is by calling the `max` function.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __neg__(self) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class MeasuringTime:
    r"""
    A class for storing time to be measured.
    
    Attributes
    -----------
    - `solve` (`SolvingTime`): Time to solve the problem.
    - `system` (`SystemTime`): Time to measure system time.
    - `total` (`float`, optional): Total time to solve the problem. Defaults to None.
    """
    @property
    def solve(self) -> SolvingTime: ...
    @property
    def system(self) -> SystemTime: ...
    @property
    def total(self) -> typing.Optional[builtins.float]: ...
    @solve.setter
    def solve(self, value: SolvingTime) -> None: ...
    @system.setter
    def system(self, value: SystemTime) -> None: ...
    @total.setter
    def total(self, value: typing.Optional[builtins.float]) -> None: ...
    def __new__(cls, solve:typing.Optional[SolvingTime]=None, system:typing.Optional[SystemTime]=None, total:typing.Optional[builtins.float]=None) -> MeasuringTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:MeasuringTime, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns
        --------
        `dict`: A dict whose keys are name of the MeasuringTime's fields.
        """
    @staticmethod
    def from_dict(dict:dict) -> MeasuringTime:
        r"""
        Create a `MeasuringTime` object from the given dict.
        
        If a key is not the name of the `MeasuringTime` fields, the value value is ignored.
        
        Args
        -----
        `dict` (`dict`): A dict.
        
        Returns
        --------
        A `MeasuringTime` object.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the `MeasuringTime` object into a JSON string.
        
        Returns
        --------
        `str`: A JSON string.
        
        Note
        -----
        A numpy array is serialized into a list.
        """
    @staticmethod
    def from_json(json:str) -> MeasuringTime:
        r"""
        Create a `MeasuringTime` object from the JSON string.
        
        Args
        -----
        `json` (`str`): A JSON string.
        
        Returns
        --------
        `MeasuringTime`: A `MeasuringTime` object.
        """

class MinOp:
    r"""
    A class for representing the minimum value.
    
    The `MinOp` class is used to represent the minimum value of operands.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `terms`: A sequence of operands.
    
    Note
    -----
    The `MinOp` class does not have a constructor. Its intended
    instantiation method is by calling the `min` function.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class ModOp:
    r"""
    A class for representing modulo
    
    The `ModOp` class is used to represent modulo (or remainder) (`%`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `ModOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class ModelingError(builtins.Exception):
    r"""
    Error while creating a model.
    """
    ...

class MulOp:
    r"""
    A class for representing multiplication
    
    The `MulOp` class is used to represent multiplication (`*`) of an arbitrary number of operands.
    For example `a * b * c * d` would be one AddOp object.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    `terms`: A sequence of operands to be multiplied.
    
    Note
    -----
    The `MulOp` class does not have a constructor. Its intended
    instantiation method is by calling the multiplication operation on other
    expressions.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def __neg__(self) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...

class NotEqualOp:
    r"""
    A class for representing the not equal operator
    
    The `NotEqualOp` class is used to represent the not equal operator (`!=`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `left`: The left-hand operand.
    - `right`: The right-hand operand.
    
    Note
    -----
    The `NotEqualOp` class does not have a constructor.
    """
    @property
    def left(self) -> typing.Any: ...
    @property
    def right(self) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class NumberLit:
    r"""
    A class for creating a number literal
    
    The `NumberLit` class is used to create a number literal.
    Its instance is automatically generated by the return value of
    arithmetic or mathematical functions taking a number literal and
    an object defined by `jijmodeling` as arguments.
    
    Attributes
    -----------
    - `value` (`int | float`): A numeric value.
    - `dtype` (`DataType`): A type of the value.
      - `dtype` is `DataType.INTEGER` if the type of the value is integer else `dtype` is `DataType.FLOAT`.
    
    Args
    -----
    - `value` (`int | float`): A numeric value.
    
    Examples
    ---------
    Create a number literal with a integer value `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> v = jm.NumberLit(123)
    >>> assert v.value == 123
    >>> assert v.dtype == jm.DataType.INTEGER
    
    ```
    
    Create a number literal with a float value `1.23`.
    
    ```python
    >>> import jijmodeling as jm
    >>> v = jm.NumberLit(1.23)
    >>> assert v.value == 1.23
    >>> assert v.dtype == jm.DataType.FLOAT
    
    ```
    """
    @property
    def value(self) -> builtins.int | builtins.float: ...
    @property
    def dtype(self) -> DataType: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __new__(cls, value:builtins.int | builtins.float) -> NumberLit: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...

class OrOp:
    r"""
    A class for representing logical OR
    
    The `OrOp` class is used to represent logical OR (`|`) of an arbitrary number of operands.
    For example `a | b | c | d` would be one `OrOp` object.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `terms`: A sequence of operands to apply the OR operation.
    
    Note
    -----
    The `OrOp` class does not have a constructor.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class Placeholder:
    r"""
    A class for creating a placeholder
    
    The Placeholder class is used to create a placeholder.
    It is a symbol to be replaced by a numerical value when you solve an optimization problem.
    
    The index operator (`[]`) of a placeholder with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the placeholder.
    - `ndim` (`int`): The number of dimensions of the placeholder.
    - `shape` (`list` of `Optional[Expression]`, optional): The (partial) shape of the placeholder if given.
    - `dtype` (`DataType`, optional): The data type (`DataType.INT` or `DataType.FLOAT`) of the placeholder.
    - `jagged` (`boolean`, defaut: `False`): `True` if the placeholder will be treated as a jagged array in random data generation. Ignored for scalars.
    - `description` (`str`, optional): A description of the placeholder.
    
    Args
    -----
    - `name` (`str`): A name of the placeholder.
    - `ndim` (`Optional[int]`): The number of dimensions of the placeholder. Defaults to `0`. The `ndim` must be set to a non-negative value and must concide with the length of `shape` if both specified. If `None` is given, you must specify `shape` explicitly and the length of `shape` will be used.
    - `shape` (`list[Optional[Expression]]`, optional): The (partial) shape of the placeholder. Used for random data generation.
    - `dtype` (`DataType`, optional): The data type (`DataType.INT` or `DataType.FLOAT`) of the placeholder. Used for random data generation.
    - `jagged` (`boolean`, defaut: `False`): `True` if the placeholder will be treated as a jagged array in random data generation. Ignored for scalars.
    - `latex` (`str`, optional): A LaTeX-name of the placeholder to be represented in Jupyter notebook.
      It is set to `name` by default.
    - `description` (`str`, optional): A description of the placeholder.
    
    Raises
    -------
    - `TypeError`: Raises if set a float value to `ndim`.
    - `OverflowError`: Raises if set a negative value to `ndim`.
    
    Examples
    ---------
    Create a scalar (or `ndim` is `0`) placeholder whose name is "a".
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    
    ```
    
    Create a 2-dimensional placeholder whose name is "m".
    
    ```python
    >>> import jijmodeling as jm
    >>> m = jm.Placeholder("m", ndim=2)
    
    ```
    
    Create a 1-dimensional placeholder with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=2)
    >>> a[123]
    Placeholder(name='a', ndim=2)[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def dtype(self) -> typing.Optional[DataType]: ...
    @property
    def jagged(self) -> builtins.bool: ...
    @property
    def description(self) -> typing.Optional[builtins.str]: ...
    @property
    def shape(self) -> tuple: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, ndim:typing.Optional[builtins.int]=None, shape:typing.Optional[typing.Sequence[typing.Optional[typing.Any]]]=None, dtype:typing.Optional[DataType]=None, jagged:builtins.bool=False, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> Placeholder: ...
    def len_at(self, axis:builtins.int, *, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> ArrayLength: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __getitem__(self, index:typing.Any) -> Subscript: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class PowOp:
    r"""
    A class for representing the power operator
    
    The ModOp class is used to represent the power operator(`**`).
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `base`: The base operand.
    - `exponent`: The exponent operand.
    
    Note
    -----
    The `PowOp` class does not have a constructor.
    """
    @property
    def base(self) -> typing.Any: ...
    @property
    def exponent(self) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __neg__(self) -> typing.Any: ...

class Problem:
    r"""
    A class for creating an optimization problem
    
    The Problem class is used to create an optimization problem.
    
    Attributes
    -----------
    - `name` (`str`): A name of the optimization problem.
    - `sense`: Sense of the optimization problem.
    - `objective`: The objective function of the optimization problem.
    - `constraints` (`dict`): A dictionary that stores constraints.
      - A key is the name of a constraint and the value is the constraint object.
    - `custom_penalty_terms` (`dict`): A dictionary that stores custom penalty terms.
      - A key is the name of a custom penalty and the value is the custom penalty object.
    
    Args
    -----
    - `name` (`str`): A name of the optimization problem.
    - `sense` (optional): Sense of the optimization problem. Defaults to `ProblemSense.MINIMIZE`.
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def sense(self) -> ProblemSense: ...
    @property
    def objective(self) -> typing.Any: ...
    @property
    def constraints(self) -> builtins.dict[builtins.str, Constraint]: ...
    @property
    def custom_penalty_terms(self) -> builtins.dict[builtins.str, CustomPenaltyTerm]: ...
    @sense.setter
    def sense(self, value: ProblemSense) -> None: ...
    def __new__(cls, name:builtins.str, *, sense:ProblemSense=ProblemSense.MINIMIZE) -> Problem: ...
    def _repr_latex_(self) -> builtins.str: ...
    def used_placeholders(self) -> builtins.list[Placeholder]: ...
    def get_problem_schema(self) -> dict:
        r"""
        Returns the schema of the problem.
        
        Returns
        --------
        - `schema`: The dictionary containing the schema of the problem.
        """
    def generate_random_dataset(self, default:typing.Mapping[builtins.str, builtins.range | tuple[typing.Optional[builtins.int], typing.Optional[builtins.int]] | builtins.int | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.int] | typing.Literal['Unbounded']] | tuple[typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded'], typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded']] | builtins.range | tuple[typing.Optional[builtins.float], typing.Optional[builtins.float]] | builtins.int | builtins.float | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']] | tuple[builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded'], builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']]]={'size': {'start': {'Included': 1}, 'end': {'Included': 5}}, 'value': {'start': {'Included': -1.0}, 'end': {'Included': 1.0}}}, options:typing.Mapping[builtins.str, typing.Mapping[builtins.str, builtins.range | tuple[typing.Optional[builtins.int], typing.Optional[builtins.int]] | builtins.int | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.int] | typing.Literal['Unbounded']] | tuple[typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded'], typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded']] | builtins.range | tuple[typing.Optional[builtins.float], typing.Optional[builtins.float]] | builtins.int | builtins.float | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']] | tuple[builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded'], builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']]]]={}, seed:typing.Optional[builtins.int]=None) -> builtins.dict[builtins.str, builtins.float | numpy.typing.NDArray[numpy.float64] | JaggedArray]:
        r"""
        Generates a dictionary of random `InstanceDataValue` for a given problem.
        To generate `ommx.v1.Instance` object directly, use `InstanceDataValue.generate_random_instance` instead.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" below).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        
        Returns
        --------
        `dict`: The dictionary from the name of placeholders to the generated `InstanceDataValue` objects. To be fed to `Interpreter.eval_problem`.
        
        Range Parameters and Range Syntax
        ----------------------------------
        A range parameter is a dictionary consisting of the following fields:
        - `size` (optional): interval of natural numbers for the size of each array dimension (default: `range(1, 6)`)
        - `value` (optional): interval of real numbers for the value of each array element (default: `range(-1.0, 1.0)` - a uniform distribution on a closed interval $[-1.0, 1.0]$).
        
        Example range parameter config:
        
        ```python
        {"size": range(2, 10), "value": jm.range.value.closed(100.0, 200.0)}
        ```
        
        Intervals are expressed as a range object.
        Currently, the following syntax is supported for range objects:
        
        1. Direct value of type `int` or `float` - it corresponds to a singleton interval $[a, a] = \{a\}$. In random generation context, this just means a constant fixed value.
        2. Use the functions from `jijmodeling.range`, `jijmodeling.range.size`, or `jijmodeling.range.value` modules.
           - Use functions from `jij.modeling.range.size` to specify (non-negative) integer intervals, and `jij.modeling.range.value` for real intervals. `jij.modeling.range` dynamically determines the type of the range based on the input.
           - These three modules provides the following combinators (see the module documents for more details.):
                    - `closed(a, b)`: a closed interval $[a, b]$
                    - `open(a, b)`: an open interval $(a, b)$
                    - `closed_open(a, b)`: an upper half-open interval $[a, b)$
                    - `open_closed(a, b)`: a lower half-open interval $(a, b]$
                    - `greater_than(a)`: an open interval $(a, \infty)$
                    - `at_least(a)`: a closed interval $[a, \infty)$
                    - `less_than(a)`: an open interval $(-\infty, a)$
                    - `at_most(a)`: a closed interval $(-\infty, a]$
        3. Use `range` builtin function: this is equivalent to `jijmodeling.range.value.closed_open(a, b)`.
           - Any python range object with `step = 1` can be used as a size range; otherwise it results in runtime error.
        4. Use a tuple: raw tuple `(a, b)` is equivalent to `jijmodeling.range.closed_open(a, b)` if `a` and `b` are either `int` or `float`.
           - You can also use bound object as a tuple component; in such case, both tuple components must be one of the following:
        
                1. A string `"Unbounded"` means $-\infty$ (in the first component) or $\infty$ (the second).
                2. A dictionary `{"Included": a}` means the endpoint is inclusive.
                3. A dictionary `{"Excluded": a}` means the endpoint is exclusive.
           - Examples:
                    - `(1.2, 4)` is equivalent to `closed_open(1.2, 4)`,
                    - `(-1, {"Included": 1})` is equivalent to `closed(-1, 1)`,
                    - `(-5, {"Excluded": 4})` is equivalent to `closed_open(-5, 4)` and built in function `range(-5, 4)`,
                    - `({"Excluded": 1}, {"Excluded": 2.5})` is equivalent to `open(1, 2.5)`,
                    - `({"Included": -1}, "Unbounded")` is equivalent to `at_least(-1)`.
                    - `(5, "Unbounded")` is **INVALID**; `5` must be bound object.
        5. The range object: A dictionary of form `{"start": lb, "end": ub}`, where both `lb` and `ub` are the bound object described as above.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> inputs = problem.generate_random_dataset(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...          # You can also specify "size" for the range of jagged array dimension size.
        ...     },
        ...     seed=123 # omittable
        ... )
        >>> assert set(inputs.keys()) == {"N", "c"}
        >>> inputs
        {'N': 11.0, 'c': array([ 0.93914459, -0.06511935, -0.7460324 , -0.32443706,  0.99981451,
               -0.24407535,  0.31329469,  0.52206453, -0.1291936 ,  0.30443087,
                0.53125838])}
        
        ```
        """
    def generate_random_instance(self, default:typing.Mapping[builtins.str, builtins.range | tuple[typing.Optional[builtins.int], typing.Optional[builtins.int]] | builtins.int | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.int] | typing.Literal['Unbounded']] | tuple[typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded'], typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded']] | builtins.range | tuple[typing.Optional[builtins.float], typing.Optional[builtins.float]] | builtins.int | builtins.float | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']] | tuple[builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded'], builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']]]={'size': {'start': {'Included': 1}, 'end': {'Included': 5}}, 'value': {'start': {'Included': -1.0}, 'end': {'Included': 1.0}}}, options:typing.Mapping[builtins.str, typing.Mapping[builtins.str, builtins.range | tuple[typing.Optional[builtins.int], typing.Optional[builtins.int]] | builtins.int | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.int] | typing.Literal['Unbounded']] | tuple[typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded'], typing.Mapping[builtins.str, builtins.int] | typing.Literal['Unbounded']] | builtins.range | tuple[typing.Optional[builtins.float], typing.Optional[builtins.float]] | builtins.int | builtins.float | None | builtins.dict[builtins.str, builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']] | tuple[builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded'], builtins.dict[builtins.str, builtins.float] | typing.Literal['Unbounded']]]]={}, seed:typing.Optional[builtins.int]=None, hints:typing.Optional[typing.Sequence[typing.Literal['OneHot', 'SOS1']]]=None) -> typing.Any:
        r"""
        Generates random `ommx.v1.Instance` for a given problem.
        See also `InstanceDataValue.generate_random_dataset`.
        
        Args
        -----
        - `options` (optional): a dictionary of range parameters for each separate placeholders. The key must be the name of the placeholder and the value must be range parameter (as described in "Range Parameters and Range Syntax" section in :func:`~jijmodeling.Problem.generate_random_dataset`).
        - `default` (optional): default range parameters for placeholders which is not specified in `options`.
        - `seed` (optional): seed for random number generation.
        - `hints` (optional): the hints to be detected during compilation see `Interpreter.eval_problem` for more details.
        
        Returns
        --------
        `instance`: The OMMX v1 instance object.
        
        Examples
        ---------
        ```python
        >>> import jijmodeling as jm
        >>> import builtins
        >>> import ommx.v1
        >>> N = jm.Placeholder("N", dtype=jm.DataType.INTEGER)
        >>> c = jm.Placeholder("c", dtype=jm.DataType.FLOAT, shape=(N,))
        >>> x = jm.BinaryVar("x", shape=(N,))
        >>> i = jm.Element("i", belong_to=N)
        
        >>> problem = jm.Problem("problem")
        >>> problem += jm.sum(i, c[i] * x[i])
        
        >>> instance = problem.generate_random_instance(
        ...     options={
        ...         'N': {"value": builtins.range(10, 20)},
        ...         'c': {"value": jm.range.value.closed(-1.0, 1.0)}
        ...     },
        ...     seed=123
        ... )
        >>> assert type(instance) is ommx.v1.Instance
        
        ```
        """
    def __iadd__(self, other:typing.Any) -> Problem: ...

class ProdOp:
    r"""
    A class for representing product
    
    The `ProdOp` class is used to represent product.
    The number of dimensions of the opreand is zero.
    
    Attributes
    -----------
    - `index`: The index of product.
    - `condition`: The condition for the product index.
    - `operand`: The opreand.
    
    Note
    -----
    The `ProdOp` class does not have a constructor.
    """
    @property
    def index(self) -> Element: ...
    @property
    def condition(self) -> typing.Optional[typing.Any]: ...
    @property
    def operand(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __neg__(self) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...

class ProtobufDeserializationError(builtins.Exception):
    r"""
    Failed to decode the buffer to an instance.
    """
    ...

class ProtobufSerializationError(builtins.Exception):
    r"""
    Failed to encode the object to a buffer.
    """
    ...

class Range:
    r"""
    A class representing a half-open interval.
    
    The `Range` class is used to represent a half-open interval `[start, end)`.
    This class does not have a constructor because it should be created by the Element class.
    
    Attributes
    -----------
    - `start`: The lower bound of the range (inclusive).
    - `end`: The upper bound of the range (exclusive).
    
    Note
    -----
    This class does not contain any decision variable.
    """
    @property
    def start(self) -> typing.Any: ...
    @property
    def end(self) -> typing.Any: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class Record:
    r"""
    A class for representing a record.
    
    There are two types of solutions that can be given; dense solutions and sparse solutions.
    A dense solution is a dict whose key is a variable name and the value is a list of numpy.ndarray.
    A sparse solution is a dict whose key is a variable name and the value is a list of tuples with three elements,
    where the first element is a list of indices, the second element is a list of non-zero values, and the third element is a shape of the array.
    The length of the list of solutions must be the same as the length of the list of num_occurrences.
    Each index of the list of solutions corresponds to the same index of the list of non-zero values.
    
    As an example, consider the following solutions:
    
    ```text
    {
        "x": [
            np.array([[0.0, 1.0, 0.0], [2.0, 0.0, 3.0]]),
            np.array([[1.0, 0.0, 0.0], [2.0, 3.0, 4.0]])
        ],
        "y": [
            np.array([0.0, 0.0, 1.0]),
            np.array([0.0, 1.0, 0.0])
        ]
    }
    ```
    
    This is a dense solution. The corresponding sparse solution is as follows:
    
    ```text
    {
        "x": [
            (([0, 1, 1], [1, 0, 2]), [1.0, 2.0, 3.0], (2, 3)),
            (([0, 1, 1, 1], [0, 0, 1, 2]), [1.0, 2.0, 3.0, 4.0], (2, 3))
        ],
        "y": [
            (([2],), [1.0], (3,)),
            (([1],), [1.0], (3,))
        ]
    }
    ```
    
    Attributes
    -----------
    - `solution` (`Union[Dict[str, List[numpy.ndarray]], Dict[str, List[Tuple[List[int], List[float], Tuple[int, ...]]]]]`): A solution.
    - `num_occurrences` (`List[int]`): A list of the number of occurrences in which the solution is observed.
    """
    @property
    def num_occurrences(self) -> builtins.list[builtins.int]: ...
    @property
    def solution(self) -> dict: ...
    @solution.setter
    def solution(self, value: typing.Any) -> None: ...
    @num_occurrences.setter
    def num_occurrences(self, value: builtins.list[builtins.int]) -> None: ...
    def __new__(cls, solution:typing.Any, num_occurrences:typing.Sequence[builtins.int]) -> Record: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:Record, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns
        --------
        `dict`: A dict whose keys are "solution" and "num_occurrences".
        """
    @staticmethod
    def from_dict(dict:dict) -> Record:
        r"""
        Create a Record object from the given dict.
        
        If a key is not one of "solution" or "num_occurrences", the value is ignored.
        
        Args
        -----
        - `dict`: A dict of str to a list of dense solutions or sparse solutions.
        
        Returns
        --------
        A `Record` object.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the `Record` object into a JSON string.
        
        Returns
        --------
        `str`: A JSON string.
        
        Note
        -----
        A numpy array is serialized into a list.
        """
    @staticmethod
    def from_json(json:str) -> Record:
        r"""
        Create a `Record` object from the JSON string.
        
        Args
        -----
        `json` (`str`): A JSON string.
        
        Returns
        --------
        `Record`: A `Record` object.
        """
    def is_dense(self) -> builtins.bool:
        r"""
        Return true if the solution is dense.
        
        Returns
        --------
        `bool`: True if the solution is dense.
        """
    def is_sparse(self) -> builtins.bool:
        r"""
        Return true if the solution is sparse.
        
        Returns
        --------
        `bool`: True if the solution is sparse.
        """
    def to_dense(self) -> Record:
        r"""
        Return a `Record` object whose solution is dense.
        
        If the solution is already dense, the solution is not converted.
        Otherwise, the solution is converted into a dense solution.
        
        Returns
        --------
        `Record`: A Record object whose solution is dense.
        """
    def to_sparse(self) -> Record:
        r"""
        Return a `Record` object whose solution is sparse.
        
        If the solution is already sparse, the solution is not converted.
        Otherwise, the solution is converted into a sparse solution.
        
        Returns
        --------
        `Record`: A `Record` object whose solution is sparse.
        """
    def to_pandas(self) -> typing.Any:
        r"""
        Convert into a pandas DataFrame.
        
        Returns
        -------
        `pandas.DataFrame`: A pandas DataFrame.
        """

class SampleSet:
    r"""
    A class for storing time of jijzept running.
    
    Attributes
    -----------
    - `post_problem_and_instance_data` (`float`, optional): Time to upload problem and instance_data to blob. Defaults to `None`.
    - `request_queue` (`float`, optional): Time to send request to queue. Defaults to `None`.
    - `fetch_problem_and_instance_data` (`float`, optional): Time to fetch problem and `instance_data` from blob. Defaults to `None`.
    - `fetch_result` (`float`, optional): Time to fetch result. Defaults to `None`.
    - `deserialize_solution` (`float`, optional): Time to deserialize json object. Defaults to `None`.
    """
    @property
    def record(self) -> Record: ...
    @property
    def evaluation(self) -> Evaluation: ...
    @property
    def measuring_time(self) -> MeasuringTime: ...
    @property
    def metadata(self) -> dict: ...
    @record.setter
    def record(self, value: Record) -> None: ...
    @evaluation.setter
    def evaluation(self, value: Evaluation) -> None: ...
    @measuring_time.setter
    def measuring_time(self, value: MeasuringTime) -> None: ...
    @metadata.setter
    def metadata(self, value: dict) -> None: ...
    def __new__(cls, record:Record, evaluation:Evaluation, measuring_time:MeasuringTime, metadata:typing.Optional[dict]=None) -> SampleSet: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:SampleSet, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns
        --------
        `dict`: A dict whose keys are name of the `SampleSet`'s fields.
        """
    @staticmethod
    def from_dict(dict:dict) -> SampleSet:
        r"""
        Create a `SampleSet` object from the given dict.
        
        If a key is not the name of the `SampleSet` fields, the value value is ignored.
        
        Args
        -----
        `dict` (`dict`): A dict.
        
        Returns
        --------
        A `SampleSet` object.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the `SampleSet` object into a JSON string.
        
        Returns
        --------
        `str`: A JSON string.
        
        Note
        -----
        A numpy array is converted into a list.
        """
    @staticmethod
    def from_json(json:str) -> SampleSet:
        r"""
        Create a `SampleSet` object from the JSON string.
        
        Args
        -----
        `json` (`str`): A JSON string.
        
        Returns
        --------
        `SampleSet`: A `SampleSet` object.
        """
    def to_pandas(self) -> typing.Any:
        r"""
        Convert into a pandas DataFrame.
        
        Returns
        --------
        `pandas.DataFrame`: A pandas DataFrame.
        """
    def to_dense(self) -> SampleSet:
        r"""
        Return a `SampleSet` whose record is converted into a dense solution format.
        If the record is already a dense solution format, return itself.
        
        Returns
        --------
        `SampleSet`: A `SampleSet` object.
        """
    def feasible(self, rtol:builtins.float=1e-05, atol:builtins.float=1e-08) -> SampleSet:
        r"""
        Return a `SampleSet` with only feasible solutions.
        If there is no feasible solution, the record and evaluation are empty.
        
        Args
        -----
        - `rtol` (`float`): The relative tolerance parameter. Defaults to `1e-5`.
        - `atol` (`float`): The absolute tolerance parameter. Defaults to `1e-8`.
        
        Returns
        --------
        `SampleSet`: A `SampleSet` object with only feasible solutions or empty.
        
        Note
        -----
        The feasible solutions are determined by the following condition:
        $$ |0 - v| \\leq \\mathrm{atol} + \\mathrm{rtol} \\cdot |v| $$
        """
    def infeasible(self, rtol:builtins.float=1e-05, atol:builtins.float=1e-08) -> SampleSet:
        r"""
        Return a `SampleSet` with only infeasible solutions.
        If there is no infeasible solution, the record and evaluation are empty.
        
        Args
        -----
        - `rtol` (`float`): The relative tolerance parameter. Defaults to `1e-5`.
        - `atol` (`float`): The absolute tolerance parameter. Defaults to `1e-8`.
        
        Returns
        --------
        `SampleSet`: A `SampleSet` object with only infeasible solutions or empty.
        
        Note
        -----
        The feasible solutions are determined by the following condition:
        $$ |0 - v| > \\mathrm{atol} + \\mathrm{rtol} \\cdot |v| $$
        """
    def lowest(self, rtol:builtins.float=1e-05, atol:builtins.float=1e-08) -> SampleSet:
        r"""
        Return a `SampleSet` with feasible solutions which has the lowest objective.
        If there is no feasible solution, the record and evaluation are empty.
        
        Args
        -----
        - `rtol` (`float`): The relative tolerance parameter. Defaults to `1e-5`.
        - `atol` (`float`): The absolute tolerance parameter. Defaults to `1e-8`.
        
        Returns
        --------
        `SampleSet`: A `SampleSet` object with feasible solutions or empty.
        
        Note
        -----
        The feasible solutions are determined by the following condition:
        $$ |0 - v| \\leq \\mathrm{atol} + \\mathrm{rtol} \\cdot |v| $$
        """
    def is_dense(self) -> builtins.bool:
        r"""
        Return true if the solution is dense.
        
        Returns
        --------
        `bool`: `True` if the solution is dense.
        """
    def is_sparse(self) -> builtins.bool:
        r"""
        Return true if the solution is sparse.
        
        Returns
        --------
        `bool`: `True` if the solution is sparse.
        """
    def get_backend_calculation_time(self) -> dict:
        r"""
        Return report of the calculation time of the JijZept backends.
        
        Returns
        --------
        `dict`: A dictionary of the calculation time of the JijZept backends.
        """

class SemiContinuousVar:
    r"""
    A class for creating a semi-continuous variable
    
    The SemiContinuousVar class is used to create a semi-continuous variable.
    Either the lower bound or the upper bound is set by the following object:
    - an integer value
    - a float value
    - a scalar expression that does not contains any decision variable
    - a Placeholder object whose dimensionality is equal to that of this variable.
    - a subscripted variable whose dimensionality is equal to that of this variable.
    
    The index operator (`[]`) of a semi-continuous variable with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the semi-continuous variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the semi-continuous variable. Empty if the variable is not multi-dimensional.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `description` (`str`): A description of the semi-continuous variable.
    
    Args
    -----
    - `name` (`str`): A name of the semi-continuous variable.
    - `shape` (`list | tuple`): A sequence with the size of each dimension of the binary variable. Defaults to an empty tuple (a scalar value).
      - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `latex` (`str`, optional): A LaTeX-name of the semi-continuous variable to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the semi-continuous variable.
    
    Raises
    -------
    `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim`
    is neither `0` nor the same value as `ndim` of the semi-continuous variable.
    
    Examples
    ---------
    Create a scalar semi-continuous variable whose name is "z" and domain is `[-1, 1]`.
    
    ```python
    >>> import jijmodeling as jm
    >>> z = jm.SemiContinuousVar("z", lower_bound=-1, upper_bound=1)
    
    ```
    
    Create a 2-dimensional semi-continuous variable...
    - whose name is "x".
    - whose domain is `[0, 2]`.
    - where each dimension has length 2 (making this a 2x2 matrix).
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.SemiContinuousVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
    
    ```
    
    Create a 1-dimensional semi-continuous variable with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.SemiContinuousVar("x", shape=[124], lower_bound=0, upper_bound=2)
    >>> x[123]
    SemiContinuousVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def lower_bound(self) -> typing.Any | Placeholder | Subscript: ...
    @property
    def upper_bound(self) -> typing.Any | Placeholder | Subscript: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __neg__(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, shape:typing.Optional[typing.Sequence[typing.Any]]=None, lower_bound:typing.Any | Placeholder | Subscript, upper_bound:typing.Any | Placeholder | Subscript, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> SemiContinuousVar: ...
    def __getitem__(self, index:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...

class SemiIntegerVar:
    r"""
    A class for creating a semi-integer variable
    
    The `SemiIntegerVar` class is used to create a semi-integer variable.
    The lower and upper bounds of the variable can be specified by:
    - an integer value
    - a float value
    - a scalar expression that does not contains any decision variable
    - a Placeholder object whose dimensionality is equal to that of this variable.
    - a subscripted variable whose dimensionality is equal to that of this variable.
    
    The index operator (`[]`) of a semi-integer variable with `ndim >= 1` returns a `Subscript` object.
    
    Attributes
    -----------
    - `name` (`str`): A name of the semi-integer variable.
    - `shape` (`tuple`): A tuple with the size of each dimension of the integer variable. Empty if the variable is not multi-dimensional.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `description` (`str`): A description of the semi-integer variable.
    
    Args
    -----
    - `name` (`str`): A name of the semi-integer variable.
    - `shape` (`list | tuple`): A sequence with the size of each dimension of the integer variable. Defaults to an empty tuple (a scalar value).
      - Each item in `shape` must be a valid expression evaluating to a non-negative scalar.
    - `lower_bound`: The lower bound of the variable.
    - `upper_bound`: The upper bound of the variable.
    - `latex` (`str`, optional): A LaTeX-name of the semi-integer variable to be represented in Jupyter notebook.
      - It is set to `name` by default.
    - `description` (`str`, optional): A description of the semi-integer variable.
    
    Raises
    -------
    `ModelingError`: Raises if a bound is a `Placeholder` or `Subscript` object whose `ndim` is neither `0`
    nor the same value as `ndim` of the semi-integer variable.
    
    Examples
    ---------
    Create a scalar semi-integer variable whose name is "z" and domain is `[-1, 1]`.
    
    ```python
    >>> import jijmodeling as jm
    >>> z = jm.SemiIntegerVar("z", lower_bound=-1, upper_bound=1)
    
    ```
    
    Create a 2-dimensional semi-integer variable...
    
    - whose name is "x".
    - whose domain is `[0, 2]`.
    - where each dimension has length 2 (making this a 2x2 matrix).
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.SemiIntegerVar("x", shape=[2, 2], lower_bound=0, upper_bound=2)
    
    ```
    
    Create a 1-dimensional semi-integer variable with the index of `123`.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.SemiIntegerVar("x", shape=[124], lower_bound=0, upper_bound=2)
    >>> x[123]
    SemiIntegerVar(name='x', shape=[NumberLit(value=124)], lower_bound=NumberLit(value=0), upper_bound=NumberLit(value=2))[NumberLit(value=123)]
    
    ```
    """
    @property
    def name(self) -> builtins.str: ...
    @property
    def description(self) -> builtins.str: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    @property
    def lower_bound(self) -> typing.Any | Placeholder | Subscript: ...
    @property
    def upper_bound(self) -> typing.Any | Placeholder | Subscript: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __new__(cls, name:builtins.str, *, shape:typing.Optional[typing.Sequence[typing.Any]]=None, lower_bound:typing.Any | Placeholder | Subscript, upper_bound:typing.Any | Placeholder | Subscript, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> SemiIntegerVar: ...
    def __getitem__(self, index:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...

class SolvingTime:
    r"""
    A class for storing time to solve a problem.
    
    Attributes
    -----------
    - `preprocess` (`float`, optional): Time to preprocess the problem. Defaults to None.
    - `solve` (`float`, optional): Time to solve the problem. Defaults to None.
    - `postprocess` (`float`, optional): Time to postprocess the problem. Defaults to None.
    """
    @property
    def preprocess(self) -> typing.Optional[builtins.float]: ...
    @property
    def solve(self) -> typing.Optional[builtins.float]: ...
    @property
    def postprocess(self) -> typing.Optional[builtins.float]: ...
    @preprocess.setter
    def preprocess(self, value: typing.Optional[builtins.float]) -> None: ...
    @solve.setter
    def solve(self, value: typing.Optional[builtins.float]) -> None: ...
    @postprocess.setter
    def postprocess(self, value: typing.Optional[builtins.float]) -> None: ...
    def __new__(cls, preprocess:typing.Optional[builtins.float]=None, solve:typing.Optional[builtins.float]=None, postprocess:typing.Optional[builtins.float]=None) -> SolvingTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:SolvingTime, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns
        --------
        `dict`: A dict with keys "preprocess", "solve", and "postprocess".
        """
    @staticmethod
    def from_dict(dict:dict) -> SolvingTime:
        r"""
        Create a `SolvingTime` object from the given dict.
        
        If a key is not one of "preprocess", "solve", or "postprocess", the value is ignored.
        
        Args
        -----
        `dict` (`dict`): A dict.
        
        Returns
        --------
        A `SolvingTime` object.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the `SolvingTime` object into a JSON string.
        
        Returns
        --------
        `str`: A JSON string.
        
        Note
        -----
        A numpy array is serialized into a list.
        """
    @staticmethod
    def from_json(json:str) -> SolvingTime:
        r"""
        Create a `SolvingTime` object from the JSON string.
        
        Args
        -----
        `json` (`str`): A JSON string.
        
        Returns
        --------
        `SolvingTime`: A `SolvingTime` object.
        """

class Subscript:
    r"""
    A class for representing a subscripted variable
    
    The Subscript class is used to represent a variable with subscriptions.
    
    Attributes
    -----------
    - `variable`: A variable that has subscripts.
    - `subscripts` (`list`): A list of subscripts.
    - `ndim` (`int`): The number of dimensions of the subscripted variable.
    
    Note
    -----
    The Subscript class does not have a constructor.
    """
    @property
    def variable(self) -> typing.Any: ...
    @property
    def subscripts(self) -> builtins.list[typing.Any]: ...
    @property
    def ndim(self) -> builtins.int: ...
    @property
    def shape(self) -> tuple: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def len_at(self, axis:builtins.int, *, latex:typing.Optional[builtins.str]=None, description:typing.Optional[builtins.str]=None) -> ArrayLength: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __getitem__(self, index:typing.Any) -> Subscript: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class SumOp:
    r"""
    A class for representing summation
    
    The `SumOp` class is used to represent summation.
    The number of dimensions of the opreand is zero.
    
    Attributes
    -----------
    - `index`: The index of summation.
    - `condition`: The condition for the summation index.
    - `operand`: The opreand.
    
    Note
    -----
    The `SumOp` class does not have a constructor.
    """
    @property
    def index(self) -> Element: ...
    @property
    def condition(self) -> typing.Optional[typing.Any]: ...
    @property
    def operand(self) -> typing.Any: ...
    def __eq__(self, other:typing.Any) -> typing.Any: ...
    def __ne__(self, other:typing.Any) -> typing.Any: ...
    def __lt__(self, other:typing.Any) -> typing.Any: ...
    def __le__(self, other:typing.Any) -> typing.Any: ...
    def __gt__(self, other:typing.Any) -> typing.Any: ...
    def __ge__(self, other:typing.Any) -> typing.Any: ...
    def __sub__(self, other:typing.Any) -> typing.Any: ...
    def __rsub__(self, other:typing.Any) -> typing.Any: ...
    def __mod__(self, other:typing.Any) -> typing.Any: ...
    def __rmod__(self, other:typing.Any) -> typing.Any: ...
    def __neg__(self) -> typing.Any: ...
    def __mul__(self, other:typing.Any) -> typing.Any: ...
    def __rmul__(self, other:typing.Any) -> typing.Any: ...
    def __pow__(self, exponent:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __rpow__(self, base:typing.Any, modulo:typing.Optional[typing.Any]=None) -> typing.Any: ...
    def __add__(self, other:typing.Any) -> typing.Any: ...
    def __radd__(self, other:typing.Any) -> typing.Any: ...
    def __truediv__(self, other:typing.Any) -> typing.Any: ...
    def __rtruediv__(self, other:typing.Any) -> typing.Any: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class SystemTime:
    r"""
    A class for storing time of jijzept running.
    
    Attributes
    -----------
    - `post_problem_and_instance_data` (`float`, optional): Time to upload problem and instance_data to blob. Defaults to None.
    - `request_queue` (`float`, optional): Time to send request to queue. Defaults to None.
    - `fetch_problem_and_instance_data` (`float`, optional): Time to fetch problme and instance_data from blob. Defaults to None.
    - `fetch_result` (`float`, optional): Time to fetch result. Defaults to None.
    - `deserialize_solution` (`float`, optional): Time to deserialize json object. Defaults to None.
    """
    @property
    def post_problem_and_instance_data(self) -> typing.Optional[builtins.float]: ...
    @property
    def request_queue(self) -> typing.Optional[builtins.float]: ...
    @property
    def fetch_problem_and_instance_data(self) -> typing.Optional[builtins.float]: ...
    @property
    def fetch_result(self) -> typing.Optional[builtins.float]: ...
    @property
    def deserialize_solution(self) -> typing.Optional[builtins.float]: ...
    @post_problem_and_instance_data.setter
    def post_problem_and_instance_data(self, value: typing.Optional[builtins.float]) -> None: ...
    @request_queue.setter
    def request_queue(self, value: typing.Optional[builtins.float]) -> None: ...
    @fetch_problem_and_instance_data.setter
    def fetch_problem_and_instance_data(self, value: typing.Optional[builtins.float]) -> None: ...
    @fetch_result.setter
    def fetch_result(self, value: typing.Optional[builtins.float]) -> None: ...
    @deserialize_solution.setter
    def deserialize_solution(self, value: typing.Optional[builtins.float]) -> None: ...
    def __new__(cls, post_problem_and_instance_data:typing.Optional[builtins.float]=None, request_queue:typing.Optional[builtins.float]=None, fetch_problem_and_instance_data:typing.Optional[builtins.float]=None, fetch_result:typing.Optional[builtins.float]=None, deserialize_solution:typing.Optional[builtins.float]=None) -> SystemTime: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __richcmp__(self, other:SystemTime, op:int) -> builtins.bool: ...
    def to_dict(self) -> dict:
        r"""
        Convert into a dict.
        
        Returns
        --------
        `dict`: A dict whose keys are name of the SystemTime's fields.
        """
    @staticmethod
    def from_dict(dict:dict) -> SystemTime:
        r"""
        Create a `SystemTime` object from the given dict.
        
        If a key is not the name of the `SystemTime` fields, the value value is ignored.
        
        Args
        -----
        `dict` (`dict`): A dict.
        
        Returns
        --------
        A `SystemTime` object.
        """
    def to_json(self) -> builtins.str:
        r"""
        Serialize the `SystemTime` object into a JSON string.
        
        Returns
        --------
        `str`: A JSON string.
        
        Note
        -----
        A numpy array is serialized into a list.
        """
    @staticmethod
    def from_json(json:str) -> SystemTime:
        r"""
        Create a `SystemTime` object from the JSON string.
        
        Args
        -----
        `json` (`str`): A JSON string.
        
        Returns
        --------
        `SystemTime`: A `SystemTime` object.
        """

class XorOp:
    r"""
    A class for representing logical XOR
    
    The `XorOp` class is used to represent logical XOR (`^`) of an arbitrary number of operands.
    For example `a ^ b ^ c ^ d` would be one `XorOp` object.
    The number of dimensions of each operand is zero.
    
    Attributes
    -----------
    - `terms- `: A sequence of operands to apply the XOR operation.
    
    Note
    -----
    The `XorOp` class does not have a constructor.
    """
    @property
    def terms(self) -> builtins.list[typing.Any]: ...
    def set_latex(self, latex:typing.Optional[builtins.str]=None) -> None:
        r"""
        Set the LaTeX representation of the object.
        If the LaTeX representation is not set, the default representation is set.
        
        Args
        -----
        `latex` (`str`, optional): LaTeX representation of the object. Defaults to None.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def _repr_latex_(self) -> builtins.str: ...

class ConstraintSense(Enum):
    r"""
    Equality of a constraint
    """
    EQUAL = ...
    LESS_THAN_EQUAL = ...
    GREATER_THAN_EQUAL = ...

class DataType(Enum):
    FLOAT = ...
    INTEGER = ...

class ProblemSense(Enum):
    r"""
    An optimization sense
    """
    MINIMIZE = ...
    MAXIMIZE = ...

def abs(operand:typing.Any) -> AbsOp:
    r"""
    Create the `AbsOp` object from the expression.
    
    Args
    -----
    `operand`: An operand of the abs operator.
    
    Returns
    --------
    `obj`: The `AbsOp` object whose operand is the input.
    
    Examples
    ---------
    Create the `AbsOp` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.abs(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def ceil(operand:typing.Any) -> CeilOp:
    r"""
    Create the `CeilOp` object from the expression.
    
    Args
    -----
    - `operand`: An operand of the ceil operator.
    
    Returns
    --------
    `obj`: The `CeilOp` object whose operand is the input.
    
    Examples
    ---------
    Create the `CeilOp` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.ceil(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def concatenate(sample_sets:typing.Sequence[SampleSet]) -> SampleSet:
    r"""
    Concatenate some `SampleSet` objects into a single `SampleSet` object.
    
    Args
    -----
    `sample_sets` (`list[SampleSet]`): A list of `SampleSet` objects.
    
    Returns
    --------
    `SampleSet`: A `SampleSet` object which is concatenated from the given `SampleSet` objects.
    
    Note
    -----
    This function will be deprecated in v1.1.0.
    """

def extract_nodes(obj:typing.Any, class_or_tuple:type | typing.Sequence[type]) -> builtins.list[typing.Any]:
    r"""
    Extract all nodes from the given object.
    
    Args
    -----
    - `obj`: An expression defined by JijModeling's module, or a `Problem`, `Constraint`, `CustomPenaltyTerm`, or a list of forall object.
    - `class_or_tuple`: A type or tuple of types of nodes to be extracted.
    
    Returns
    --------
    `list`: A list of nodes whose type is `type`.
    
    Examples
    ---------
    Extract all placeholders from the given expression.
    
    ```python
    >>> from itertools import zip_longest
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> b = jm.Placeholder("b")
    >>> expr = jm.Placeholder("a") + jm.Placeholder("b")
    >>> for actual, expect in zip_longest(jm.extract_nodes(expr, jm.Placeholder), [a, b]):
    >>>     assert jm.is_same(actual, expect)
    
    ```
    
    Extract all BinaryVar objects and Placeholder objects from the given expression.
    
    ```python
    >>> from itertools import zip_longest
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> b = jm.Placeholder("b")
    >>> x = jm.BinaryVar("x")
    >>> y = jm.ContinuousVar("y", lower_bound=0, upper_bound=1)
    >>> expr = a * x + b * y + 123
    >>> actual = jm.extract_nodes(expr, (jm.BinaryVar, jm.Placeholder))
    >>> expect = [a, x, b, y]
    >>> for actual, expect in zip_longest(actual, expect):
    >>>     assert jm.is_same(actual, expect)
    
    ```
    """

def extract_variables(obj:typing.Any) -> builtins.list[typing.Any]:
    r"""
    Extract all variables from the given object without duplication.
    
    This function returns a list of variables present within the given object.
    The variables are stored in the list according to their visit order in a depth-first traversal of the tree.
    Even if the same variable appears more than twice in the expression tree, the variable is only stored in the list upon its first appearance.
    Consequently, the list returned by this function contains only the unique variables present in the expression.
    
    Args
    -----
    `obj`: An expression defined by JijModeling's module, or a `Problem`, `Constraint`, `CustomPenaltyTerm`, or a list of forall object.
    
    Returns
    --------
    `list`: A list of variables, which are `Placeholder`, `Element`, `ArrayLength`, `BinaryVar`, `IntegerVar`, `ContinuousVar`, `SemiIntegerVar`, or `SemiContinuousVar`.
    
    Examples
    ---------
    Extract all variables from a problem without duplication.
    
    ```python
    >>> n = jm.Placeholder("n")
    >>> i = jm.Element("i", belong_to=n)
    >>> x = jm.BinaryVar("x", shape=[10])
    >>> y = jm.IntegerVar("y", shape=[10], lower_bound=0, upper_bound=1)
    >>> z = jm.ContinuousVar("z", shape=[10], lower_bound=0, upper_bound=1)
    >>> problem = jm.Problem("problem")
    >>> problem += jm.sum(i, x[i])
    >>> problem += jm.Constraint("constraint", y[i] == 1, forall=i)
    >>> problem += jm.CustomPenaltyTerm("penalty", z[i], forall=i)
    >>> actual = jm.extract_variables(problem)
    >>> expect = [i, n, x, y, z]
    >>> assert len(actual) == len(expect)
    >>> for actual_node, expect_node in zip(actual, expect):
    >>>     assert jm.is_same(actual_node, expect_node)
    
    ```
    """

def floor(operand:typing.Any) -> FloorOp:
    r"""
    Create the `FloorOp` object from the expression.
    
    Args
    -----
    - `operand`: An operand of the floor operator.
    
    Returns
    --------
    `obj`: The `FloorOp` object whose operand is the input.
    
    Examples
    ---------
    Create the `FloorOp` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.floor(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def from_protobuf(buf:bytes) -> typing.Any: ...

def is_dynamic_degree(expr:typing.Any) -> builtins.bool:
    r"""
    Return true if degree of the expression is not determined statically.
    
    Args
    -----
    `expr`: A math expression to be checked.
    
    Returns
    --------
    `bool`: True if degree of the expression is determined dynamically.
    
    Examples
    ---------
    Check if the degree of the following expression is determined dynamically.
    
    ```python
    >>> a = jm.Placeholder("a", ndim=1)
    >>> i = jm.Element("i", belong_to=a)
    >>> x = jm.BinaryVar("x", shape=(a.len_at(0),))
    >>> # The number of multiplication is not determined until the value of a is given.
    >>> expr = jm.prod(i, x[i])
    >>> assert jm.is_dynamic_degree(expr)
    
    ```
    """

def is_higher_order(expr:typing.Any) -> builtins.bool:
    r"""
    Return true if the degree of the given expression is higher than 2.
    
    Args
    -----
    `expr`: A math expression to be checked.
    
    Returns
    --------
    `bool`: True if the degree of the given expression is higher than 2.
    """

def is_linear(expr:typing.Any) -> builtins.bool:
    r"""
    Return true if the given expression is linear.
    
    Args
    -----
    `expr`: A math expression to be checked.
    
    Returns
    --------
    `bool`: True if the given expression is linear.
    """

def is_quadratic(expr:typing.Any) -> builtins.bool:
    r"""
    Return true if the given expression is quadratic.
    
    Args
    -----
    `expr`: A math expression to be checked.
    
    Returns
    --------
    `bool`: True if the given expression is quadratic.
    """

def is_same(src:typing.Any, dst:typing.Any) -> builtins.bool:
    r"""
    Return `true` if `src` and `dst` are the same object defined by Jijmodeling.
    
    Args
    -----
    - `src`: An object defined by Jijmodeling module, or an iterable of Jijmodeling objects.
    - `dst`: An object defined by Jijmodeling module, or an iterable of Jijmodeling objects.
    
    Returns
    --------
    `bool`: `true` if `src` and `dst` is the same object. Otherwise `false`.
    
    Examples
    ---------
    Check if the two placeholders are the same.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("name")
    >>> b = jm.Placeholder("name")
    >>> assert jm.is_same(a, b)
    >>> c = jm.Placeholder("name", ndim=2)
    >>> assert not jm.is_same(a, c) # the value of `ndim` is different
    ```
    
    Raises
    -------
    `TypeError`: Raises if
    - `src` and `dst` are of different types which are not iterable
    - called on a type not defined by Jijmodeling (e.g. `str`)
    
    Note
    -----
    This function does not check the following attributes:
    - `description`
    - `latex`
    
    For example,
    
    ```python
    >>> import jijmodeling as jm
    >>> src = jm.Placeholder("placeholder", latex="src")
    >>> dst = jm.Placeholder("placeholder", latex="dst")
    >>> assert jm.is_same(src, dst)
    ```
    
    this code works without any exception.
    """

def ln(operand:typing.Any) -> LnOp:
    r"""
    Create the `LnOp` object from the expression.
    
    Args
    -----
    `operand`: An operand of the natural logarithm.
    
    Returns
    --------
    `obj`: The `LnOp` object whose operand is the input.
    
    Examples
    ---------
    Create the `LnOp` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.ln(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def log10(operand:typing.Any) -> Log10Op:
    r"""
    Create the `Log10Op` object from the expression.
    
    Args
    -----
    - `operand`: An operand of the log10 operator.
    
    Returns
    --------
    `obj`: The `Log10Op` object whose operand is the input.
    
    Examples
    ---------
    Create the `Log10Op` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.log10(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def log2(operand:typing.Any) -> Log2Op:
    r"""
    Create the `Log2Op` object from the expression.
    
    Args
    -----
    - `operand`: An operand of the log2 operator.
    
    Returns
    --------
    `obj`: The `Log2Op` object whose operand is the input.
    
    Examples
    ---------
    Create the `Log2Op` object whose operand is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> jm.log2(a)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def max(*operands) -> MaxOp:
    r"""
    Create the `MaxOp` object from the expression.
    
    Args
    -----
    - `operands`: A sequence of operands.
    
    Returns
    --------
    `obj`: The `MaxOp` object whose operands are the inputs.
    
    Examples
    ---------
    Create the `MaxOp` object whose operands are three placeholders.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> b = jm.Placeholder("b")
    >>> c = jm.Placeholder("c")
    >>> jm.max(a, b, c)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def min(*operands) -> MinOp:
    r"""
    Create the `MinOp` object from the expression.
    
    Args
    -----
    - `operands`: A sequence of operands.
    
    Returns
    --------
    `obj`: The `MinOp` object whose operands are the inputs.
    
    Examples
    ---------
    Create the `MinOp` object whose operands are three placeholders.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a")
    >>> b = jm.Placeholder("b")
    >>> c = jm.Placeholder("c")
    >>> jm.min(a, b, c)
    
    ```
    
    Raises
    -------
    `ModelingError`: Raises if the input contains a decision variable.
    """

def prod(index:typing.Any, operand:typing.Any) -> ProdOp:
    r"""
    Create the `ProdOp` object.
    
    Args
    -----
    - `index`: An index of product.
    - `operand`: The operand of product.
    
    Returns
    --------
    `obj`: The `ProdOp` object.
    
    Examples
    ---------
    Create product of an indexed placeholder $a_{i}$ from $i=0$ to $N-1$.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=1)
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=(0, N))
    >>> jm.prod(i, a[i])
    
    ```
    
    Create product of an indexed binary variable $x_{e}$ over all elements $e$ in the set $E$.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.BinaryVar("x", ndim=1)
    >>> E = jm.Placeholder("E", ndim=1)
    >>> e = jm.Element("e", belong_to=E)
    >>> jm.prod(e, x[e])
    
    ```
    
    By passing a tuple containing two elements to the index of product, a conditional index can be constructed.
    The left element of the tuple should be an instance of the `Element` class,
    while the right element should be the conditional expression for that index.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=1)
    >>> i = jm.Element("i", belong_to=(0, 10))
    >>> jm.prod((i, i != 2), a[i])
    
    ```
    
    This code creates product of an indexed placeholder $a_{i}$ from $i=0$ to $9$ subject to the condition $i\neq2$.
    """

def replace(target:typing.Any, replacer:typing.Any) -> typing.Any:
    r"""
    Replace expression nodes with the result of calling the replacer function.
    
    This function can be used either with individual expressions or `Problem` instances. In
    both cases, this function returns a new object without modifying the original.
    
    When used with a single expression, walks down the expression tree, applying the replacer
    function to each node on the expression. When something is not replaced (i.e. the replacer
    returns the original node), we walk down the expression tree to apply the replacer to child
    nodes.
    
    When used with a `Problem` object, this is equivalent to creating a new `Problem` defined by
    calling this function on each expression within the original, that is, the objective function,
    as well as each constraint and each custom penalty term, including "forall" fields.
    
    Args
    -----
    - `target`: An expression or Problem to apply replacement.
    - `replacer`: A callable object that takes an expression node and returns a new expression node.
    
    Examples
    ---------
    Replace all placeholders in an expression with a binary variable.
    
    ```python
    >>> import jijmodeling as jm
    >>> ph = jm.Placeholder("placeholder")
    >>> var = jm.BinaryVar("x")
    >>> expr = var + ph + 1
    >>> replaced = jm.replace(ph, lambda x: var if isinstance(x, jm.Placeholder) else x)
    >>> assert jm.is_same(replaced, var + var + 1)
    
    ```
    
    Replace a subscripted variable with a binary variable if it is a placeholder.
    
    ```python
    >>> import jijmodeling as jm
    >>> ph = jm.Placeholder("ph", ndim=2)
    >>> x = jm.BinaryVar("x", shape=(1000, 1000))
    >>> elt = jm.Element("elt", belong_to=ph)
    >>> expr = ph[123, 456] + elt[123]
    >>> replacer = (
    >>>     lambda node: x[node.subscripts]
    >>>     if isinstance(node, jm.Subscript) and isinstance(node.variable, jm.Placeholder)
    >>>     else node
    >>> )
    >>> replaced = jm.replace(expr, replacer)
    >>> assert jm.is_same(replaced, x[123, 456] + elt[123])
    
    ```
    
    Replace all instances of a variable in a problem with a different variable
    
    ```py
    >>> import jijmodeling as jm
    >>> x = jm.BinaryVar("x")
    >>> problem = jm.Problem("p")
    >>> problem += x / 2
    >>> problem += jm.Constraint("c1", x + 3 <= 10)
    >>>
    >>> y = jm.IntegerVar("y", lower_bound=0, upper_bound=10)
    >>> replacer = lambda node: y if jm.is_same(node, x) else node
    >>> new_problem = jm.replace(problem, replacer)
    >>> # no x present in new problem:
    >>> vars = jm.extract_variables(new_problem)
    >>> assert not any(jm.is_same(x, v) for v in vars)
    ```
    
    Raises
    -------
    `TypeError`: Raises if `target` is neither an expression nor an instance of `Problem`, or if `replacer` is not callable.
    
    Note
    -----
    The replacer must satisfy the following conditions:
    
    - The replacer must be a callable object.
    - The number of arguments of the replacer must be one.
    - The replacer must take an expression node as the argument.
    - The replacer must return an expression node.
    """

def sum(index:typing.Any, operand:typing.Any) -> SumOp:
    r"""
    Create the `SumOp` object.
    
    Args
    -----
    - `index`: An index of summation.
    - `operand`: The operand of summation.
    
    Returns
    --------
    `obj`: The `SumOp` object.
    
    Examples
    ---------
    Create summation of an indexed placeholder $a_{i}$ from $i=0$ to $N-1$.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=1)
    >>> N = jm.Placeholder("N")
    >>> i = jm.Element("i", belong_to=(0, N))
    >>> jm.sum(i, a[i])
    
    ```
    
    Create summation of an indexed binary variable $x_{e}$ over all elements $e$ in the set $E$.
    
    ```python
    >>> import jijmodeling as jm
    >>> x = jm.BinaryVar("x", ndim=1)
    >>> E = jm.Placeholder("E", ndim=1)
    >>> e = jm.Element("e", belong_to=E)
    >>> jm.sum(e, x[e])
    
    ```
    
    By passing a tuple containing two elements to the index of summation, a conditional index can be constructed.
    The left element of the tuple should be an instance of the `Element` class, while the right element should be the conditional expression for that index.
    
    ```python
    >>> import jijmodeling as jm
    >>> a = jm.Placeholder("a", ndim=1)
    >>> i = jm.Element("i", belong_to=(0, 10))
    >>> jm.sum((i, i != 2), a[i])
    
    ```
    
    This code creates summation of an indexed placeholder $a_{i}$ from $i=0$ to $9$ subject to the condition $i\neq2$.
    """

def to_protobuf(obj:Problem | Constraint | CustomPenaltyTerm | typing.Any | typing.Any) -> bytes: ...

