/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_ELEMENTALTENSORTOVECTORPASS
#define GEN_PASS_DECL_LOWERXTILEENTRYPASS
#define GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#define GEN_PASS_DECL_REWRITEDYNAMICVECTOREXTRACTPASS
#define GEN_PASS_DECL_SHLOTOVECTORPASS
#define GEN_PASS_DECL_TENSOROPSTOVECTORPASS
#define GEN_PASS_DECL_XTILETOVECTORPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ElementalTensorToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ELEMENTALTENSORTOVECTORPASS
#undef GEN_PASS_DECL_ELEMENTALTENSORTOVECTORPASS
#endif // GEN_PASS_DECL_ELEMENTALTENSORTOVECTORPASS
#ifdef GEN_PASS_DEF_ELEMENTALTENSORTOVECTORPASS
namespace impl {

template <typename DerivedT>
class ElementalTensorToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ElementalTensorToVectorPassBase;

  ElementalTensorToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ElementalTensorToVectorPassBase(const ElementalTensorToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ElementalTensorToVectorPassBase& operator=(const ElementalTensorToVectorPassBase &) = delete;
  ElementalTensorToVectorPassBase(ElementalTensorToVectorPassBase &&) = delete;
  ElementalTensorToVectorPassBase& operator=(ElementalTensorToVectorPassBase &&) = delete;
  ~ElementalTensorToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-elemental-tensor-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-elemental-tensor-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering arith & math ops with tensor types to vector types)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ElementalTensorToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "ElementalTensorToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ElementalTensorToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ELEMENTALTENSORTOVECTORPASS
#endif // GEN_PASS_DEF_ELEMENTALTENSORTOVECTORPASS

//===----------------------------------------------------------------------===//
// LowerXTileEntryPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERXTILEENTRYPASS
#undef GEN_PASS_DECL_LOWERXTILEENTRYPASS
#endif // GEN_PASS_DECL_LOWERXTILEENTRYPASS
#ifdef GEN_PASS_DEF_LOWERXTILEENTRYPASS
namespace impl {

template <typename DerivedT>
class LowerXTileEntryPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerXTileEntryPassBase;

  LowerXTileEntryPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXTileEntryPassBase(const LowerXTileEntryPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerXTileEntryPassBase& operator=(const LowerXTileEntryPassBase &) = delete;
  LowerXTileEntryPassBase(LowerXTileEntryPassBase &&) = delete;
  LowerXTileEntryPassBase& operator=(LowerXTileEntryPassBase &&) = delete;
  ~LowerXTileEntryPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-lower-xtile-entry");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-lower-xtile-entry"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers the entry function into the form required by the CPU runtime)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXTileEntryPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXTileEntryPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<xla::cpu::XlaCpuDialect>();
    registry.insert<xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXTileEntryPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERXTILEENTRYPASS
#endif // GEN_PASS_DEF_LOWERXTILEENTRYPASS

//===----------------------------------------------------------------------===//
// MemrefCopyToLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass();
#undef GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#endif // GEN_PASS_DECL_MEMREFCOPYTOLOOPSPASS
#ifdef GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class MemrefCopyToLoopsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MemrefCopyToLoopsPassBase;

  MemrefCopyToLoopsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemrefCopyToLoopsPassBase(const MemrefCopyToLoopsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  MemrefCopyToLoopsPassBase& operator=(const MemrefCopyToLoopsPassBase &) = delete;
  MemrefCopyToLoopsPassBase(MemrefCopyToLoopsPassBase &&) = delete;
  MemrefCopyToLoopsPassBase& operator=(MemrefCopyToLoopsPassBase &&) = delete;
  ~MemrefCopyToLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-memref-copy-to-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-memref-copy-to-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite mmeref.copy to loops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemrefCopyToLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "MemrefCopyToLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::scf::SCFDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemrefCopyToLoopsPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createMemrefCopyToLoopsPass() {
  return impl::createMemrefCopyToLoopsPass();
}
#undef GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS
#endif // GEN_PASS_DEF_MEMREFCOPYTOLOOPSPASS

//===----------------------------------------------------------------------===//
// RewriteDynamicVectorExtractPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEDYNAMICVECTOREXTRACTPASS
#undef GEN_PASS_DECL_REWRITEDYNAMICVECTOREXTRACTPASS
#endif // GEN_PASS_DECL_REWRITEDYNAMICVECTOREXTRACTPASS
#ifdef GEN_PASS_DEF_REWRITEDYNAMICVECTOREXTRACTPASS
namespace impl {

template <typename DerivedT>
class RewriteDynamicVectorExtractPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RewriteDynamicVectorExtractPassBase;

  RewriteDynamicVectorExtractPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteDynamicVectorExtractPassBase(const RewriteDynamicVectorExtractPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RewriteDynamicVectorExtractPassBase& operator=(const RewriteDynamicVectorExtractPassBase &) = delete;
  RewriteDynamicVectorExtractPassBase(RewriteDynamicVectorExtractPassBase &&) = delete;
  RewriteDynamicVectorExtractPassBase& operator=(RewriteDynamicVectorExtractPassBase &&) = delete;
  ~RewriteDynamicVectorExtractPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-rewrite-dynamic-vector-extract");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-rewrite-dynamic-vector-extract"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite vector.extracts with dynamic indices.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteDynamicVectorExtractPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteDynamicVectorExtractPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::vector::VectorDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteDynamicVectorExtractPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEDYNAMICVECTOREXTRACTPASS
#endif // GEN_PASS_DEF_REWRITEDYNAMICVECTOREXTRACTPASS

//===----------------------------------------------------------------------===//
// ShloToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SHLOTOVECTORPASS
#undef GEN_PASS_DECL_SHLOTOVECTORPASS
#endif // GEN_PASS_DECL_SHLOTOVECTORPASS
#ifdef GEN_PASS_DEF_SHLOTOVECTORPASS
namespace impl {

template <typename DerivedT>
class ShloToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ShloToVectorPassBase;

  ShloToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShloToVectorPassBase(const ShloToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ShloToVectorPassBase& operator=(const ShloToVectorPassBase &) = delete;
  ShloToVectorPassBase(ShloToVectorPassBase &&) = delete;
  ShloToVectorPassBase& operator=(ShloToVectorPassBase &&) = delete;
  ~ShloToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-shlo-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-shlo-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering satble hlo ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShloToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "ShloToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::memref::MemRefDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShloToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SHLOTOVECTORPASS
#endif // GEN_PASS_DEF_SHLOTOVECTORPASS

//===----------------------------------------------------------------------===//
// TensorOpsToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSOROPSTOVECTORPASS
#undef GEN_PASS_DECL_TENSOROPSTOVECTORPASS
#endif // GEN_PASS_DECL_TENSOROPSTOVECTORPASS
#ifdef GEN_PASS_DEF_TENSOROPSTOVECTORPASS
namespace impl {

template <typename DerivedT>
class TensorOpsToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TensorOpsToVectorPassBase;

  TensorOpsToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorOpsToVectorPassBase(const TensorOpsToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TensorOpsToVectorPassBase& operator=(const TensorOpsToVectorPassBase &) = delete;
  TensorOpsToVectorPassBase(TensorOpsToVectorPassBase &&) = delete;
  TensorOpsToVectorPassBase& operator=(TensorOpsToVectorPassBase &&) = delete;
  ~TensorOpsToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-tensor-ops-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-tensor-ops-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering tensor dialect ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorOpsToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "TensorOpsToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorOpsToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSOROPSTOVECTORPASS
#endif // GEN_PASS_DEF_TENSOROPSTOVECTORPASS

//===----------------------------------------------------------------------===//
// XTileToVectorPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_XTILETOVECTORPASS
#undef GEN_PASS_DECL_XTILETOVECTORPASS
#endif // GEN_PASS_DECL_XTILETOVECTORPASS
#ifdef GEN_PASS_DEF_XTILETOVECTORPASS
namespace impl {

template <typename DerivedT>
class XTileToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = XTileToVectorPassBase;

  XTileToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XTileToVectorPassBase(const XTileToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  XTileToVectorPassBase& operator=(const XTileToVectorPassBase &) = delete;
  XTileToVectorPassBase(XTileToVectorPassBase &&) = delete;
  XTileToVectorPassBase& operator=(XTileToVectorPassBase &&) = delete;
  ~XTileToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-xtile-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-xtile-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering xtile ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XTileToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "XTileToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XTileToVectorPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_XTILETOVECTORPASS
#endif // GEN_PASS_DEF_XTILETOVECTORPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ElementalTensorToVectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerElementalTensorToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateElementalTensorToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerElementalTensorToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateElementalTensorToVectorPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerXTileEntryPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerXTileEntryPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXTileEntryPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerXTileEntryPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXTileEntryPass();
  });
}

//===----------------------------------------------------------------------===//
// MemrefCopyToLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerMemrefCopyToLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemrefCopyToLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMemrefCopyToLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createMemrefCopyToLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteDynamicVectorExtractPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteDynamicVectorExtractPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRewriteDynamicVectorExtractPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteDynamicVectorExtractPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRewriteDynamicVectorExtractPass();
  });
}

//===----------------------------------------------------------------------===//
// ShloToVectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerShloToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateShloToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerShloToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateShloToVectorPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorOpsToVectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorOpsToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorOpsToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorOpsToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorOpsToVectorPass();
  });
}

//===----------------------------------------------------------------------===//
// XTileToVectorPass Registration
//===----------------------------------------------------------------------===//

inline void registerXTileToVectorPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateXTileToVectorPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerXTileToVectorPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateXTileToVectorPass();
  });
}

//===----------------------------------------------------------------------===//
// XTileCpuTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerXTileCpuTransformsPasses() {
  registerElementalTensorToVectorPass();
  registerLowerXTileEntryPass();
  registerMemrefCopyToLoopsPass();
  registerRewriteDynamicVectorExtractPass();
  registerShloToVectorPass();
  registerTensorOpsToVectorPass();
  registerXTileToVectorPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ElementalTensorToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ElementalTensorToVectorPassBase;

  ElementalTensorToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ElementalTensorToVectorPassBase(const ElementalTensorToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ElementalTensorToVectorPassBase& operator=(const ElementalTensorToVectorPassBase &) = delete;
  ElementalTensorToVectorPassBase(ElementalTensorToVectorPassBase &&) = delete;
  ElementalTensorToVectorPassBase& operator=(ElementalTensorToVectorPassBase &&) = delete;
  ~ElementalTensorToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-elemental-tensor-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-elemental-tensor-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering arith & math ops with tensor types to vector types)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ElementalTensorToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "ElementalTensorToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ElementalTensorToVectorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerXTileEntryPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerXTileEntryPassBase;

  LowerXTileEntryPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXTileEntryPassBase(const LowerXTileEntryPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerXTileEntryPassBase& operator=(const LowerXTileEntryPassBase &) = delete;
  LowerXTileEntryPassBase(LowerXTileEntryPassBase &&) = delete;
  LowerXTileEntryPassBase& operator=(LowerXTileEntryPassBase &&) = delete;
  ~LowerXTileEntryPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-lower-xtile-entry");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-lower-xtile-entry"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers the entry function into the form required by the CPU runtime)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXTileEntryPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXTileEntryPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<xla::cpu::XlaCpuDialect>();
    registry.insert<xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXTileEntryPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MemrefCopyToLoopsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MemrefCopyToLoopsPassBase;

  MemrefCopyToLoopsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MemrefCopyToLoopsPassBase(const MemrefCopyToLoopsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  MemrefCopyToLoopsPassBase& operator=(const MemrefCopyToLoopsPassBase &) = delete;
  MemrefCopyToLoopsPassBase(MemrefCopyToLoopsPassBase &&) = delete;
  MemrefCopyToLoopsPassBase& operator=(MemrefCopyToLoopsPassBase &&) = delete;
  ~MemrefCopyToLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-memref-copy-to-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-memref-copy-to-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite mmeref.copy to loops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MemrefCopyToLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "MemrefCopyToLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::scf::SCFDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MemrefCopyToLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteDynamicVectorExtractPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RewriteDynamicVectorExtractPassBase;

  RewriteDynamicVectorExtractPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteDynamicVectorExtractPassBase(const RewriteDynamicVectorExtractPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RewriteDynamicVectorExtractPassBase& operator=(const RewriteDynamicVectorExtractPassBase &) = delete;
  RewriteDynamicVectorExtractPassBase(RewriteDynamicVectorExtractPassBase &&) = delete;
  RewriteDynamicVectorExtractPassBase& operator=(RewriteDynamicVectorExtractPassBase &&) = delete;
  ~RewriteDynamicVectorExtractPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-rewrite-dynamic-vector-extract");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-rewrite-dynamic-vector-extract"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite vector.extracts with dynamic indices.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteDynamicVectorExtractPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteDynamicVectorExtractPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::vector::VectorDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteDynamicVectorExtractPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ShloToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ShloToVectorPassBase;

  ShloToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ShloToVectorPassBase(const ShloToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ShloToVectorPassBase& operator=(const ShloToVectorPassBase &) = delete;
  ShloToVectorPassBase(ShloToVectorPassBase &&) = delete;
  ShloToVectorPassBase& operator=(ShloToVectorPassBase &&) = delete;
  ~ShloToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-shlo-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-shlo-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering satble hlo ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ShloToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "ShloToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::memref::MemRefDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::stablehlo::StablehloDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ShloToVectorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorOpsToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TensorOpsToVectorPassBase;

  TensorOpsToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorOpsToVectorPassBase(const TensorOpsToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TensorOpsToVectorPassBase& operator=(const TensorOpsToVectorPassBase &) = delete;
  TensorOpsToVectorPassBase(TensorOpsToVectorPassBase &&) = delete;
  TensorOpsToVectorPassBase& operator=(TensorOpsToVectorPassBase &&) = delete;
  ~TensorOpsToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-tensor-ops-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-tensor-ops-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering tensor dialect ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorOpsToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "TensorOpsToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorOpsToVectorPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class XTileToVectorPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = XTileToVectorPassBase;

  XTileToVectorPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  XTileToVectorPassBase(const XTileToVectorPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  XTileToVectorPassBase& operator=(const XTileToVectorPassBase &) = delete;
  XTileToVectorPassBase(XTileToVectorPassBase &&) = delete;
  XTileToVectorPassBase& operator=(XTileToVectorPassBase &&) = delete;
  ~XTileToVectorPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xtile-cpu-xtile-to-vector");
  }
  ::llvm::StringRef getArgument() const override { return "xtile-cpu-xtile-to-vector"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowering xtile ops to vector ops)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("XTileToVectorPass");
  }
  ::llvm::StringRef getName() const override { return "XTileToVectorPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(XTileToVectorPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
