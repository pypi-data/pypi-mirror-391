from faster_eth_abi.encoding import (
    BaseEncoder as BaseEncoder,
    TupleEncoder as TupleEncoder,
)
from faster_eth_abi.exceptions import ValueOutOfBounds as ValueOutOfBounds
from typing import Any, Callable, Sequence, TypeVar

T = TypeVar("T")

def validate_tuple(self, value: Sequence[Any]) -> None: ...
def encode_tuple(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_all_dynamic(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic1(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic2(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic3(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic4(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic5(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic6(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic7(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic8(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic9(self, values: Sequence[Any]) -> bytes: ...
def encode_tuple_no_dynamic10(self, values: Sequence[Any]) -> bytes: ...

encode_tuple_no_dynamic_funcs: dict[int, Callable[[TupleEncoder, Sequence[Any]], bytes]]

def encode_fixed(
    value: Any,
    encode_fn: Callable[[Any], bytes],
    is_big_endian: bool,
    data_byte_size: int,
) -> bytes: ...
def encode_signed(
    value: T, encode_fn: Callable[[T], bytes], data_byte_size: int
) -> bytes: ...
def encode_elements(item_encoder: BaseEncoder, value: Sequence[Any]) -> bytes: ...
def encode_elements_dynamic(
    item_encoder: BaseEncoder, value: Sequence[Any]
) -> bytes: ...
def encode_uint_256(i: int) -> bytes: ...
def int_to_big_endian(value: int) -> bytes: ...
