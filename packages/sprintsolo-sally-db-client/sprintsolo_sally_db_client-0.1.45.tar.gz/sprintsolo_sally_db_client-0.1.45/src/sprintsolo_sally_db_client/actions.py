# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE clerkId = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'clerkId': 'ggciceaie',
                'email': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'clerkId': 'cadfabfehe',
                    'email': 'dgiiaaijj',
                },
                {
                    # data to create a User record
                    'clerkId': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firstName field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the lastName field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'clerkId': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
                'update': {
                    'clerkId': 'bfaiacjjfc',
                    'email': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'profileImageUrl': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'phoneNumber': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by version values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['version'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserGmailTokenActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserGmailToken]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserGmailToken.prisma().query_raw(
            'SELECT * FROM UserGmailToken WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserGmailToken
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserGmailToken.prisma().query_first(
            'SELECT * FROM UserGmailToken WHERE userId = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserGmailTokenCreateInput,
        include: Optional[types.UserGmailTokenInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserGmailToken record.

        Parameters
        ----------
        data
            UserGmailToken record data
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The created UserGmailToken record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserGmailToken record from just the required fields
        usergmailtoken = await UserGmailToken.prisma().create(
            data={
                # data to create a UserGmailToken record
                'userId': 'bgeecijdgg',
                'email': 'bdiicjafbj',
                'accessToken': 'bgehebiafc',
                'scope': 'bghffegacj',
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserGmailTokenCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserGmailToken records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserGmailToken record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserGmailToken.prisma().create_many(
            data=[
                {
                    # data to create a UserGmailToken record
                    'userId': 'bhghchehcc',
                    'email': 'dcgchcbbf',
                    'accessToken': 'bdedcabahc',
                    'scope': 'ghfhiafcb',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a UserGmailToken record
                    'userId': 'heejgedji',
                    'email': 'bjgjgibgbf',
                    'accessToken': 'bbbgbhfjge',
                    'scope': 'igbehcbab',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserGmailTokenWhereUniqueInput,
        include: Optional[types.UserGmailTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserGmailToken record.

        Parameters
        ----------
        where
            UserGmailToken filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The deleted UserGmailToken record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergmailtoken = await UserGmailToken.prisma().delete(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserGmailTokenWhereUniqueInput,
        include: Optional[types.UserGmailTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserGmailToken record.

        Parameters
        ----------
        where
            UserGmailToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The found UserGmailToken record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergmailtoken = await UserGmailToken.prisma().find_unique(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserGmailTokenWhereUniqueInput,
        include: Optional[types.UserGmailTokenInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserGmailToken record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserGmailToken filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The found UserGmailToken record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergmailtoken = await UserGmailToken.prisma().find_unique_or_raise(
            where={
                'id': 'caaaedabfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
        include: Optional[types.UserGmailTokenInclude] = None,
        order: Optional[Union[types.UserGmailTokenOrderByInput, List[types.UserGmailTokenOrderByInput]]] = None,
        distinct: Optional[List[types.UserGmailTokenScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserGmailToken records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserGmailToken records returned
        skip
            Ignore the first N results
        where
            UserGmailToken filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGmailToken model
        order
            Order the returned UserGmailToken records by any field
        distinct
            Filter UserGmailToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserGmailToken]
            The list of all UserGmailToken records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserGmailToken records
        usergmailtokens = await UserGmailToken.prisma().find_many(take=10)

        # find the first 5 UserGmailToken records ordered by the email field
        usergmailtokens = await UserGmailToken.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
        include: Optional[types.UserGmailTokenInclude] = None,
        order: Optional[Union[types.UserGmailTokenOrderByInput, List[types.UserGmailTokenOrderByInput]]] = None,
        distinct: Optional[List[types.UserGmailTokenScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserGmailToken record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserGmailToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGmailToken model
        order
            Order the returned UserGmailToken records by any field
        distinct
            Filter UserGmailToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserGmailToken
            The first UserGmailToken record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserGmailToken record ordered by the accessToken field
        usergmailtoken = await UserGmailToken.prisma().find_first(
            skip=1,
            order={
                'accessToken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
        include: Optional[types.UserGmailTokenInclude] = None,
        order: Optional[Union[types.UserGmailTokenOrderByInput, List[types.UserGmailTokenOrderByInput]]] = None,
        distinct: Optional[List[types.UserGmailTokenScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserGmailToken record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserGmailToken filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserGmailToken model
        order
            Order the returned UserGmailToken records by any field
        distinct
            Filter UserGmailToken records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserGmailToken
            The first UserGmailToken record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserGmailToken record ordered by the refreshToken field
        usergmailtoken = await UserGmailToken.prisma().find_first_or_raise(
            skip=1,
            order={
                'refreshToken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserGmailTokenUpdateInput,
        where: types.UserGmailTokenWhereUniqueInput,
        include: Optional[types.UserGmailTokenInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserGmailToken record.

        Parameters
        ----------
        data
            UserGmailToken record data specifying what to update
        where
            UserGmailToken filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The updated UserGmailToken record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        usergmailtoken = await UserGmailToken.prisma().update(
            where={
                'id': 'bigibebcib',
            },
            data={
                # data to update the UserGmailToken record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserGmailTokenWhereUniqueInput,
        data: types.UserGmailTokenUpsertInput,
        include: Optional[types.UserGmailTokenInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserGmailToken filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserGmailToken model

        Returns
        -------
        prisma.models.UserGmailToken
            The created or updated UserGmailToken record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        usergmailtoken = await UserGmailToken.prisma().upsert(
            where={
                'id': 'bigaiehgcc',
            },
            data={
                'create': {
                    'id': 'bigaiehgcc',
                    'userId': 'heejgedji',
                    'email': 'bjgjgibgbf',
                    'accessToken': 'bbbgbhfjge',
                    'scope': 'igbehcbab',
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'heejgedji',
                    'email': 'bjgjgibgbf',
                    'accessToken': 'bbbgbhfjge',
                    'scope': 'igbehcbab',
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserGmailTokenUpdateManyMutationInput,
        where: types.UserGmailTokenWhereInput,
    ) -> int:
        """Update multiple UserGmailToken records

        Parameters
        ----------
        data
            UserGmailToken data to update the selected UserGmailToken records to
        where
            Filter to select the UserGmailToken records to update

        Returns
        -------
        int
            The total number of UserGmailToken records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserGmailToken records
        total = await UserGmailToken.prisma().update_many(
            data={
                'tokenType': 'beeifcbebf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserGmailToken records present in the database

        Parameters
        ----------
        select
            Select the UserGmailToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserGmailToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserGmailTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserGmailToken.prisma().count()

        # results: prisma.types.UserGmailTokenCountAggregateOutput
        results = await UserGmailToken.prisma().count(
            select={
                '_all': True,
                'scope': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserGmailTokenCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
    ) -> types.UserGmailTokenCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserGmailTokenCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserGmailTokenWhereInput] = None,
        cursor: Optional[types.UserGmailTokenWhereUniqueInput] = None,
    ) -> Union[int, types.UserGmailTokenCountAggregateOutput]:
        """Count the number of UserGmailToken records present in the database

        Parameters
        ----------
        select
            Select the UserGmailToken fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserGmailToken filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserGmailTokenCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserGmailToken.prisma().count()

        # results: prisma.types.UserGmailTokenCountAggregateOutput
        results = await UserGmailToken.prisma().count(
            select={
                '_all': True,
                'expiresAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserGmailTokenCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserGmailTokenWhereInput] = None
    ) -> int:
        """Delete multiple UserGmailToken records.

        Parameters
        ----------
        where
            Optional UserGmailToken filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserGmailToken records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserGmailToken records
        total = await UserGmailToken.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserGmailTokenScalarFieldKeys'],
        *,
        where: Optional['types.UserGmailTokenWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserGmailTokenAvgAggregateInput'] = None,
        sum: Optional['types.UserGmailTokenSumAggregateInput'] = None,
        min: Optional['types.UserGmailTokenMinAggregateInput'] = None,
        max: Optional['types.UserGmailTokenMaxAggregateInput'] = None,
        having: Optional['types.UserGmailTokenScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserGmailTokenCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserGmailTokenScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserGmailTokenScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGmailTokenGroupByOutput']:
        """Group UserGmailToken records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserGmailToken fields to group records by
        where
            UserGmailToken filter to select records
        take
            Limit the maximum number of UserGmailToken records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGmailTokenGroupByOutput]
            A list of dictionaries representing the UserGmailToken record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserGmailToken records by isActive values
        # and count how many records are in each group
        results = await UserGmailToken.prisma().group_by(
            ['isActive'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Company]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Company.prisma().query_raw(
            'SELECT * FROM Company WHERE id = $1',
            'bgcigfahea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Company
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Company.prisma().query_first(
            'SELECT * FROM Company WHERE name = $1',
            'bcejgaggif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CompanyCreateInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new Company record.

        Parameters
        ----------
        data
            Company record data
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created Company record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Company record from just the required fields
        company = await Company.prisma().create(
            data={
                # data to create a Company record
                'name': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Company records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Company record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Company.prisma().create_many(
            data=[
                {
                    # data to create a Company record
                    'name': 'hgdhbjhhj',
                },
                {
                    # data to create a Company record
                    'name': 'ecjjjfbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Company record.

        Parameters
        ----------
        where
            Company filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The deleted Company record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().delete(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Company record.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Company record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Company filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The found Company record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().find_unique_or_raise(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Company records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N results
        where
            Company filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Company]
            The list of all Company records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Company records
        companys = await Company.prisma().find_many(take=10)

        # find the first 5 Company records ordered by the domain field
        companys = await Company.prisma().find_many(
            take=5,
            order={
                'domain': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Company record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the industry field
        company = await Company.prisma().find_first(
            skip=1,
            order={
                'industry': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
        include: Optional[types.CompanyInclude] = None,
        order: Optional[Union[types.CompanyOrderByInput, List[types.CompanyOrderByInput]]] = None,
        distinct: Optional[List[types.CompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Company record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Company filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Company model
        order
            Order the returned Company records by any field
        distinct
            Filter Company records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Company
            The first Company record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Company record ordered by the address field
        company = await Company.prisma().find_first_or_raise(
            skip=1,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CompanyUpdateInput,
        where: types.CompanyWhereUniqueInput,
        include: Optional[types.CompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Company record.

        Parameters
        ----------
        data
            Company record data specifying what to update
        where
            Company filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The updated Company record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        company = await Company.prisma().update(
            where={
                'id': 'cbachdgfce',
            },
            data={
                # data to update the Company record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CompanyWhereUniqueInput,
        data: types.CompanyUpsertInput,
        include: Optional[types.CompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Company filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Company model

        Returns
        -------
        prisma.models.Company
            The created or updated Company record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        company = await Company.prisma().upsert(
            where={
                'id': 'chbfcacbd',
            },
            data={
                'create': {
                    'id': 'chbfcacbd',
                    'name': 'ecjjjfbae',
                },
                'update': {
                    'name': 'ecjjjfbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CompanyUpdateManyMutationInput,
        where: types.CompanyWhereInput,
    ) -> int:
        """Update multiple Company records

        Parameters
        ----------
        data
            Company data to update the selected Company records to
        where
            Filter to select the Company records to update

        Returns
        -------
        int
            The total number of Company records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Company records
        total = await Company.prisma().update_many(
            data={
                'website': 'efggddide'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> types.CompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CompanyWhereInput] = None,
        cursor: Optional[types.CompanyWhereUniqueInput] = None,
    ) -> Union[int, types.CompanyCountAggregateOutput]:
        """Count the number of Company records present in the database

        Parameters
        ----------
        select
            Select the Company fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Company filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Company.prisma().count()

        # results: prisma.types.CompanyCountAggregateOutput
        results = await Company.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CompanyWhereInput] = None
    ) -> int:
        """Delete multiple Company records.

        Parameters
        ----------
        where
            Optional Company filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Company records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Company records
        total = await Company.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CompanyScalarFieldKeys'],
        *,
        where: Optional['types.CompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CompanyAvgAggregateInput'] = None,
        sum: Optional['types.CompanySumAggregateInput'] = None,
        min: Optional['types.CompanyMinAggregateInput'] = None,
        max: Optional['types.CompanyMaxAggregateInput'] = None,
        having: Optional['types.CompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CompanyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CompanyGroupByOutput']:
        """Group Company records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Company fields to group records by
        where
            Company filter to select records
        take
            Limit the maximum number of Company records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CompanyGroupByOutput]
            A list of dictionaries representing the Company record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Company records by updatedAt values
        # and count how many records are in each group
        results = await Company.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationCompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrganizationCompany]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrganizationCompany.prisma().query_raw(
            'SELECT * FROM OrganizationCompany WHERE id = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrganizationCompany
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrganizationCompany.prisma().query_first(
            'SELECT * FROM OrganizationCompany WHERE organizationId = $1',
            'bfidgijfjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationCompanyCreateInput,
        include: Optional[types.OrganizationCompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrganizationCompany record.

        Parameters
        ----------
        data
            OrganizationCompany record data
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The created OrganizationCompany record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrganizationCompany record from just the required fields
        organizationcompany = await OrganizationCompany.prisma().create(
            data={
                # data to create a OrganizationCompany record
                'organizationId': 'ihieecagf',
                'companyId': 'bghfciaafe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationCompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrganizationCompany records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrganizationCompany record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrganizationCompany.prisma().create_many(
            data=[
                {
                    # data to create a OrganizationCompany record
                    'organizationId': 'bgchfhgceh',
                    'companyId': 'cafeiaccbc',
                },
                {
                    # data to create a OrganizationCompany record
                    'organizationId': 'gaddfhfh',
                    'companyId': 'gieegcbeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationCompanyWhereUniqueInput,
        include: Optional[types.OrganizationCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrganizationCompany record.

        Parameters
        ----------
        where
            OrganizationCompany filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The deleted OrganizationCompany record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationcompany = await OrganizationCompany.prisma().delete(
            where={
                'id': 'bgcffadich',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationCompanyWhereUniqueInput,
        include: Optional[types.OrganizationCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrganizationCompany record.

        Parameters
        ----------
        where
            OrganizationCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The found OrganizationCompany record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationcompany = await OrganizationCompany.prisma().find_unique(
            where={
                'id': 'fcbichhci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationCompanyWhereUniqueInput,
        include: Optional[types.OrganizationCompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrganizationCompany record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrganizationCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The found OrganizationCompany record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationcompany = await OrganizationCompany.prisma().find_unique_or_raise(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
        include: Optional[types.OrganizationCompanyInclude] = None,
        order: Optional[Union[types.OrganizationCompanyOrderByInput, List[types.OrganizationCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationCompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrganizationCompany records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrganizationCompany records returned
        skip
            Ignore the first N results
        where
            OrganizationCompany filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model
        order
            Order the returned OrganizationCompany records by any field
        distinct
            Filter OrganizationCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrganizationCompany]
            The list of all OrganizationCompany records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrganizationCompany records
        organizationcompanys = await OrganizationCompany.prisma().find_many(take=10)

        # find the first 5 OrganizationCompany records ordered by the companyId field
        organizationcompanys = await OrganizationCompany.prisma().find_many(
            take=5,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
        include: Optional[types.OrganizationCompanyInclude] = None,
        order: Optional[Union[types.OrganizationCompanyOrderByInput, List[types.OrganizationCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationCompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrganizationCompany record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model
        order
            Order the returned OrganizationCompany records by any field
        distinct
            Filter OrganizationCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationCompany
            The first OrganizationCompany record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationCompany record ordered by the note field
        organizationcompany = await OrganizationCompany.prisma().find_first(
            skip=1,
            order={
                'note': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
        include: Optional[types.OrganizationCompanyInclude] = None,
        order: Optional[Union[types.OrganizationCompanyOrderByInput, List[types.OrganizationCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationCompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrganizationCompany record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model
        order
            Order the returned OrganizationCompany records by any field
        distinct
            Filter OrganizationCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationCompany
            The first OrganizationCompany record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationCompany record ordered by the createdAt field
        organizationcompany = await OrganizationCompany.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationCompanyUpdateInput,
        where: types.OrganizationCompanyWhereUniqueInput,
        include: Optional[types.OrganizationCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrganizationCompany record.

        Parameters
        ----------
        data
            OrganizationCompany record data specifying what to update
        where
            OrganizationCompany filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The updated OrganizationCompany record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organizationcompany = await OrganizationCompany.prisma().update(
            where={
                'id': 'jdcfdcgc',
            },
            data={
                # data to update the OrganizationCompany record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationCompanyWhereUniqueInput,
        data: types.OrganizationCompanyUpsertInput,
        include: Optional[types.OrganizationCompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrganizationCompany filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrganizationCompany model

        Returns
        -------
        prisma.models.OrganizationCompany
            The created or updated OrganizationCompany record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationcompany = await OrganizationCompany.prisma().upsert(
            where={
                'id': 'cafdaehjid',
            },
            data={
                'create': {
                    'id': 'cafdaehjid',
                    'organizationId': 'gaddfhfh',
                    'companyId': 'gieegcbeg',
                },
                'update': {
                    'organizationId': 'gaddfhfh',
                    'companyId': 'gieegcbeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationCompanyUpdateManyMutationInput,
        where: types.OrganizationCompanyWhereInput,
    ) -> int:
        """Update multiple OrganizationCompany records

        Parameters
        ----------
        data
            OrganizationCompany data to update the selected OrganizationCompany records to
        where
            Filter to select the OrganizationCompany records to update

        Returns
        -------
        int
            The total number of OrganizationCompany records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrganizationCompany records
        total = await OrganizationCompany.prisma().update_many(
            data={
                'id': 'gifdddbia'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrganizationCompany records present in the database

        Parameters
        ----------
        select
            Select the OrganizationCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationCompany.prisma().count()

        # results: prisma.types.OrganizationCompanyCountAggregateOutput
        results = await OrganizationCompany.prisma().count(
            select={
                '_all': True,
                'organizationId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationCompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
    ) -> types.OrganizationCompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationCompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationCompanyWhereInput] = None,
        cursor: Optional[types.OrganizationCompanyWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationCompanyCountAggregateOutput]:
        """Count the number of OrganizationCompany records present in the database

        Parameters
        ----------
        select
            Select the OrganizationCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationCompany.prisma().count()

        # results: prisma.types.OrganizationCompanyCountAggregateOutput
        results = await OrganizationCompany.prisma().count(
            select={
                '_all': True,
                'companyId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationCompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationCompanyWhereInput] = None
    ) -> int:
        """Delete multiple OrganizationCompany records.

        Parameters
        ----------
        where
            Optional OrganizationCompany filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrganizationCompany records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrganizationCompany records
        total = await OrganizationCompany.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationCompanyScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationCompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationCompanyAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationCompanySumAggregateInput'] = None,
        min: Optional['types.OrganizationCompanyMinAggregateInput'] = None,
        max: Optional['types.OrganizationCompanyMaxAggregateInput'] = None,
        having: Optional['types.OrganizationCompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationCompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationCompanyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationCompanyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationCompanyGroupByOutput']:
        """Group OrganizationCompany records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrganizationCompany fields to group records by
        where
            OrganizationCompany filter to select records
        take
            Limit the maximum number of OrganizationCompany records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationCompanyGroupByOutput]
            A list of dictionaries representing the OrganizationCompany record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrganizationCompany records by note values
        # and count how many records are in each group
        results = await OrganizationCompany.prisma().group_by(
            ['note'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContactActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Contact]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Contact.prisma().query_raw(
            'SELECT * FROM Contact WHERE id = $1',
            'bchehecef',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Contact
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Contact.prisma().query_first(
            'SELECT * FROM Contact WHERE organizationId = $1',
            'jeijcbhfe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContactCreateInput,
        include: Optional[types.ContactInclude] = None
    ) -> _PrismaModelT:
        """Create a new Contact record.

        Parameters
        ----------
        data
            Contact record data
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The created Contact record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Contact record from just the required fields
        contact = await Contact.prisma().create(
            data={
                # data to create a Contact record
                'organizationId': 'bjgejjabff',
                'name': 'bcciijbibg',
                'email': 'cffcachfd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContactCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Contact records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Contact record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Contact.prisma().create_many(
            data=[
                {
                    # data to create a Contact record
                    'organizationId': 'bccdfhdigc',
                    'name': 'febcgjbfj',
                    'email': 'bageiegghg',
                },
                {
                    # data to create a Contact record
                    'organizationId': 'faidicegb',
                    'name': 'bacecgfhbe',
                    'email': 'ihcahiead',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Contact record.

        Parameters
        ----------
        where
            Contact filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The deleted Contact record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = await Contact.prisma().delete(
            where={
                'id': 'biheheiajg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Contact record.

        Parameters
        ----------
        where
            Contact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The found Contact record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = await Contact.prisma().find_unique(
            where={
                'id': 'jbgijghgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Contact record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Contact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The found Contact record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = await Contact.prisma().find_unique_or_raise(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
        include: Optional[types.ContactInclude] = None,
        order: Optional[Union[types.ContactOrderByInput, List[types.ContactOrderByInput]]] = None,
        distinct: Optional[List[types.ContactScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Contact records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Contact records returned
        skip
            Ignore the first N results
        where
            Contact filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contact model
        order
            Order the returned Contact records by any field
        distinct
            Filter Contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Contact]
            The list of all Contact records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Contact records
        contacts = await Contact.prisma().find_many(take=10)

        # find the first 5 Contact records ordered by the companyId field
        contacts = await Contact.prisma().find_many(
            take=5,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
        include: Optional[types.ContactInclude] = None,
        order: Optional[Union[types.ContactOrderByInput, List[types.ContactOrderByInput]]] = None,
        distinct: Optional[List[types.ContactScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Contact record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contact model
        order
            Order the returned Contact records by any field
        distinct
            Filter Contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contact
            The first Contact record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contact record ordered by the name field
        contact = await Contact.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
        include: Optional[types.ContactInclude] = None,
        order: Optional[Union[types.ContactOrderByInput, List[types.ContactOrderByInput]]] = None,
        distinct: Optional[List[types.ContactScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Contact record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Contact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Contact model
        order
            Order the returned Contact records by any field
        distinct
            Filter Contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Contact
            The first Contact record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Contact record ordered by the email field
        contact = await Contact.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContactUpdateInput,
        where: types.ContactWhereUniqueInput,
        include: Optional[types.ContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Contact record.

        Parameters
        ----------
        data
            Contact record data specifying what to update
        where
            Contact filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The updated Contact record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contact = await Contact.prisma().update(
            where={
                'id': 'icadbcehj',
            },
            data={
                # data to update the Contact record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContactWhereUniqueInput,
        data: types.ContactUpsertInput,
        include: Optional[types.ContactInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Contact filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Contact model

        Returns
        -------
        prisma.models.Contact
            The created or updated Contact record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = await Contact.prisma().upsert(
            where={
                'id': 'jchciaee',
            },
            data={
                'create': {
                    'id': 'jchciaee',
                    'organizationId': 'faidicegb',
                    'name': 'bacecgfhbe',
                    'email': 'ihcahiead',
                },
                'update': {
                    'organizationId': 'faidicegb',
                    'name': 'bacecgfhbe',
                    'email': 'ihcahiead',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContactUpdateManyMutationInput,
        where: types.ContactWhereInput,
    ) -> int:
        """Update multiple Contact records

        Parameters
        ----------
        data
            Contact data to update the selected Contact records to
        where
            Filter to select the Contact records to update

        Returns
        -------
        int
            The total number of Contact records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Contact records
        total = await Contact.prisma().update_many(
            data={
                'phone': 'deeificjd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Contact records present in the database

        Parameters
        ----------
        select
            Select the Contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contact.prisma().count()

        # results: prisma.types.ContactCountAggregateOutput
        results = await Contact.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContactCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> types.ContactCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContactCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContactWhereInput] = None,
        cursor: Optional[types.ContactWhereUniqueInput] = None,
    ) -> Union[int, types.ContactCountAggregateOutput]:
        """Count the number of Contact records present in the database

        Parameters
        ----------
        select
            Select the Contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Contact.prisma().count()

        # results: prisma.types.ContactCountAggregateOutput
        results = await Contact.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContactCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContactWhereInput] = None
    ) -> int:
        """Delete multiple Contact records.

        Parameters
        ----------
        where
            Optional Contact filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Contact records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Contact records
        total = await Contact.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContactScalarFieldKeys'],
        *,
        where: Optional['types.ContactWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContactAvgAggregateInput'] = None,
        sum: Optional['types.ContactSumAggregateInput'] = None,
        min: Optional['types.ContactMinAggregateInput'] = None,
        max: Optional['types.ContactMaxAggregateInput'] = None,
        having: Optional['types.ContactScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContactCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContactScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContactScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContactGroupByOutput']:
        """Group Contact records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Contact fields to group records by
        where
            Contact filter to select records
        take
            Limit the maximum number of Contact records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContactGroupByOutput]
            A list of dictionaries representing the Contact record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Contact records by source values
        # and count how many records are in each group
        results = await Contact.prisma().group_by(
            ['source'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserEmailPreferencesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserEmailPreferences]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserEmailPreferences.prisma().query_raw(
            'SELECT * FROM UserEmailPreferences WHERE id = $1',
            'bbcbhebbda',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserEmailPreferences
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserEmailPreferences.prisma().query_first(
            'SELECT * FROM UserEmailPreferences WHERE userId = $1',
            'bejfijgcfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserEmailPreferencesCreateInput,
        include: Optional[types.UserEmailPreferencesInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserEmailPreferences record.

        Parameters
        ----------
        data
            UserEmailPreferences record data
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The created UserEmailPreferences record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserEmailPreferences record from just the required fields
        useremailpreferences = await UserEmailPreferences.prisma().create(
            data={
                # data to create a UserEmailPreferences record
                'userId': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserEmailPreferencesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserEmailPreferences records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserEmailPreferences record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserEmailPreferences.prisma().create_many(
            data=[
                {
                    # data to create a UserEmailPreferences record
                    'userId': 'igaibbfgj',
                },
                {
                    # data to create a UserEmailPreferences record
                    'userId': 'bggajdcbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserEmailPreferencesWhereUniqueInput,
        include: Optional[types.UserEmailPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserEmailPreferences record.

        Parameters
        ----------
        where
            UserEmailPreferences filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The deleted UserEmailPreferences record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useremailpreferences = await UserEmailPreferences.prisma().delete(
            where={
                'id': 'fcfhgbjed',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserEmailPreferencesWhereUniqueInput,
        include: Optional[types.UserEmailPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserEmailPreferences record.

        Parameters
        ----------
        where
            UserEmailPreferences filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The found UserEmailPreferences record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useremailpreferences = await UserEmailPreferences.prisma().find_unique(
            where={
                'id': 'hdgcajhjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserEmailPreferencesWhereUniqueInput,
        include: Optional[types.UserEmailPreferencesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserEmailPreferences record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserEmailPreferences filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The found UserEmailPreferences record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useremailpreferences = await UserEmailPreferences.prisma().find_unique_or_raise(
            where={
                'id': 'ejdjahicb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserEmailPreferencesInclude] = None,
        order: Optional[Union[types.UserEmailPreferencesOrderByInput, List[types.UserEmailPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserEmailPreferencesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserEmailPreferences records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserEmailPreferences records returned
        skip
            Ignore the first N results
        where
            UserEmailPreferences filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model
        order
            Order the returned UserEmailPreferences records by any field
        distinct
            Filter UserEmailPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserEmailPreferences]
            The list of all UserEmailPreferences records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserEmailPreferences records
        useremailpreferences = await UserEmailPreferences.prisma().find_many(take=10)

        # find the first 5 UserEmailPreferences records ordered by the autoSyncEnabled field
        useremailpreferences = await UserEmailPreferences.prisma().find_many(
            take=5,
            order={
                'autoSyncEnabled': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserEmailPreferencesInclude] = None,
        order: Optional[Union[types.UserEmailPreferencesOrderByInput, List[types.UserEmailPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserEmailPreferencesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserEmailPreferences record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserEmailPreferences filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model
        order
            Order the returned UserEmailPreferences records by any field
        distinct
            Filter UserEmailPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserEmailPreferences
            The first UserEmailPreferences record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserEmailPreferences record ordered by the syncFrequencyMinutes field
        useremailpreferences = await UserEmailPreferences.prisma().find_first(
            skip=1,
            order={
                'syncFrequencyMinutes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserEmailPreferencesInclude] = None,
        order: Optional[Union[types.UserEmailPreferencesOrderByInput, List[types.UserEmailPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserEmailPreferencesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserEmailPreferences record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserEmailPreferences filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model
        order
            Order the returned UserEmailPreferences records by any field
        distinct
            Filter UserEmailPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserEmailPreferences
            The first UserEmailPreferences record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserEmailPreferences record ordered by the maxEmailsPerSync field
        useremailpreferences = await UserEmailPreferences.prisma().find_first_or_raise(
            skip=1,
            order={
                'maxEmailsPerSync': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserEmailPreferencesUpdateInput,
        where: types.UserEmailPreferencesWhereUniqueInput,
        include: Optional[types.UserEmailPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserEmailPreferences record.

        Parameters
        ----------
        data
            UserEmailPreferences record data specifying what to update
        where
            UserEmailPreferences filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The updated UserEmailPreferences record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        useremailpreferences = await UserEmailPreferences.prisma().update(
            where={
                'id': 'gdjgigfgc',
            },
            data={
                # data to update the UserEmailPreferences record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserEmailPreferencesWhereUniqueInput,
        data: types.UserEmailPreferencesUpsertInput,
        include: Optional[types.UserEmailPreferencesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserEmailPreferences filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserEmailPreferences model

        Returns
        -------
        prisma.models.UserEmailPreferences
            The created or updated UserEmailPreferences record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useremailpreferences = await UserEmailPreferences.prisma().upsert(
            where={
                'id': 'gfeaahdeh',
            },
            data={
                'create': {
                    'id': 'gfeaahdeh',
                    'userId': 'bggajdcbbi',
                },
                'update': {
                    'userId': 'bggajdcbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserEmailPreferencesUpdateManyMutationInput,
        where: types.UserEmailPreferencesWhereInput,
    ) -> int:
        """Update multiple UserEmailPreferences records

        Parameters
        ----------
        data
            UserEmailPreferences data to update the selected UserEmailPreferences records to
        where
            Filter to select the UserEmailPreferences records to update

        Returns
        -------
        int
            The total number of UserEmailPreferences records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserEmailPreferences records
        total = await UserEmailPreferences.prisma().update_many(
            data={
                'enableSmartSearch': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserEmailPreferences records present in the database

        Parameters
        ----------
        select
            Select the UserEmailPreferences fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserEmailPreferences filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserEmailPreferencesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserEmailPreferences.prisma().count()

        # results: prisma.types.UserEmailPreferencesCountAggregateOutput
        results = await UserEmailPreferences.prisma().count(
            select={
                '_all': True,
                'lastHistoryId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserEmailPreferencesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
    ) -> types.UserEmailPreferencesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserEmailPreferencesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserEmailPreferencesWhereInput] = None,
        cursor: Optional[types.UserEmailPreferencesWhereUniqueInput] = None,
    ) -> Union[int, types.UserEmailPreferencesCountAggregateOutput]:
        """Count the number of UserEmailPreferences records present in the database

        Parameters
        ----------
        select
            Select the UserEmailPreferences fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserEmailPreferences filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserEmailPreferencesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserEmailPreferences.prisma().count()

        # results: prisma.types.UserEmailPreferencesCountAggregateOutput
        results = await UserEmailPreferences.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserEmailPreferencesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserEmailPreferencesWhereInput] = None
    ) -> int:
        """Delete multiple UserEmailPreferences records.

        Parameters
        ----------
        where
            Optional UserEmailPreferences filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserEmailPreferences records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserEmailPreferences records
        total = await UserEmailPreferences.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserEmailPreferencesScalarFieldKeys'],
        *,
        where: Optional['types.UserEmailPreferencesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserEmailPreferencesAvgAggregateInput'] = None,
        sum: Optional['types.UserEmailPreferencesSumAggregateInput'] = None,
        min: Optional['types.UserEmailPreferencesMinAggregateInput'] = None,
        max: Optional['types.UserEmailPreferencesMaxAggregateInput'] = None,
        having: Optional['types.UserEmailPreferencesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserEmailPreferencesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserEmailPreferencesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserEmailPreferencesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserEmailPreferencesGroupByOutput']:
        """Group UserEmailPreferences records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserEmailPreferences fields to group records by
        where
            UserEmailPreferences filter to select records
        take
            Limit the maximum number of UserEmailPreferences records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserEmailPreferencesGroupByOutput]
            A list of dictionaries representing the UserEmailPreferences record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserEmailPreferences records by updatedAt values
        # and count how many records are in each group
        results = await UserEmailPreferences.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailThreadActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailThread]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailThread.prisma().query_raw(
            'SELECT * FROM EmailThread WHERE id = $1',
            'hihegjif',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailThread
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailThread.prisma().query_first(
            'SELECT * FROM EmailThread WHERE userId = $1',
            'bdjidcidac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailThreadCreateInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailThread record.

        Parameters
        ----------
        data
            EmailThread record data
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The created EmailThread record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailThread record from just the required fields
        emailthread = await EmailThread.prisma().create(
            data={
                # data to create a EmailThread record
                'userId': 'ifgaaagff',
                'organizationId': 'befcddgjce',
                'gmailThreadId': 'bfhdbjjgfd',
                'subject': 'cabdjadaji',
                'lastMessageAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailThreadCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailThread records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailThread record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailThread.prisma().create_many(
            data=[
                {
                    # data to create a EmailThread record
                    'userId': 'faajgfadf',
                    'organizationId': 'biaagcedjc',
                    'gmailThreadId': 'cahhaghecf',
                    'subject': 'bghcbbcidi',
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a EmailThread record
                    'userId': 'jcgghhgdj',
                    'organizationId': 'beehgcebbg',
                    'gmailThreadId': 'bhdiaidiaf',
                    'subject': 'deajegcfi',
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailThread record.

        Parameters
        ----------
        where
            EmailThread filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The deleted EmailThread record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().delete(
            where={
                'id': 'gabahhhjf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailThread record.

        Parameters
        ----------
        where
            EmailThread filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The found EmailThread record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().find_unique(
            where={
                'id': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailThread record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailThread filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The found EmailThread record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().find_unique_or_raise(
            where={
                'id': 'bifficggej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailThread records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailThread records returned
        skip
            Ignore the first N results
        where
            EmailThread filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailThread]
            The list of all EmailThread records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailThread records
        emailthreads = await EmailThread.prisma().find_many(take=10)

        # find the first 5 EmailThread records ordered by the organizationId field
        emailthreads = await EmailThread.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailThread record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailThread filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailThread
            The first EmailThread record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailThread record ordered by the gmailThreadId field
        emailthread = await EmailThread.prisma().find_first(
            skip=1,
            order={
                'gmailThreadId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
        include: Optional[types.EmailThreadInclude] = None,
        order: Optional[Union[types.EmailThreadOrderByInput, List[types.EmailThreadOrderByInput]]] = None,
        distinct: Optional[List[types.EmailThreadScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailThread record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailThread filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailThread model
        order
            Order the returned EmailThread records by any field
        distinct
            Filter EmailThread records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailThread
            The first EmailThread record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailThread record ordered by the subject field
        emailthread = await EmailThread.prisma().find_first_or_raise(
            skip=1,
            order={
                'subject': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailThreadUpdateInput,
        where: types.EmailThreadWhereUniqueInput,
        include: Optional[types.EmailThreadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailThread record.

        Parameters
        ----------
        data
            EmailThread record data specifying what to update
        where
            EmailThread filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The updated EmailThread record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().update(
            where={
                'id': 'bgbbaajbic',
            },
            data={
                # data to update the EmailThread record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailThreadWhereUniqueInput,
        data: types.EmailThreadUpsertInput,
        include: Optional[types.EmailThreadInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailThread filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailThread model

        Returns
        -------
        prisma.models.EmailThread
            The created or updated EmailThread record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailthread = await EmailThread.prisma().upsert(
            where={
                'id': 'eegghdhjb',
            },
            data={
                'create': {
                    'id': 'eegghdhjb',
                    'userId': 'jcgghhgdj',
                    'organizationId': 'beehgcebbg',
                    'gmailThreadId': 'bhdiaidiaf',
                    'subject': 'deajegcfi',
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'jcgghhgdj',
                    'organizationId': 'beehgcebbg',
                    'gmailThreadId': 'bhdiaidiaf',
                    'subject': 'deajegcfi',
                    'lastMessageAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailThreadUpdateManyMutationInput,
        where: types.EmailThreadWhereInput,
    ) -> int:
        """Update multiple EmailThread records

        Parameters
        ----------
        data
            EmailThread data to update the selected EmailThread records to
        where
            Filter to select the EmailThread records to update

        Returns
        -------
        int
            The total number of EmailThread records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailThread records
        total = await EmailThread.prisma().update_many(
            data={
                'participants': ['daafgidjg']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailThread records present in the database

        Parameters
        ----------
        select
            Select the EmailThread fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailThread filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailThreadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailThread.prisma().count()

        # results: prisma.types.EmailThreadCountAggregateOutput
        results = await EmailThread.prisma().count(
            select={
                '_all': True,
                'lastMessageAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailThreadCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> types.EmailThreadCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailThreadCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailThreadWhereInput] = None,
        cursor: Optional[types.EmailThreadWhereUniqueInput] = None,
    ) -> Union[int, types.EmailThreadCountAggregateOutput]:
        """Count the number of EmailThread records present in the database

        Parameters
        ----------
        select
            Select the EmailThread fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailThread filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailThreadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailThread.prisma().count()

        # results: prisma.types.EmailThreadCountAggregateOutput
        results = await EmailThread.prisma().count(
            select={
                '_all': True,
                'messageCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailThreadCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailThreadWhereInput] = None
    ) -> int:
        """Delete multiple EmailThread records.

        Parameters
        ----------
        where
            Optional EmailThread filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailThread records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailThread records
        total = await EmailThread.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailThreadScalarFieldKeys'],
        *,
        where: Optional['types.EmailThreadWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailThreadAvgAggregateInput'] = None,
        sum: Optional['types.EmailThreadSumAggregateInput'] = None,
        min: Optional['types.EmailThreadMinAggregateInput'] = None,
        max: Optional['types.EmailThreadMaxAggregateInput'] = None,
        having: Optional['types.EmailThreadScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailThreadCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailThreadScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailThreadScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailThreadGroupByOutput']:
        """Group EmailThread records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailThread fields to group records by
        where
            EmailThread filter to select records
        take
            Limit the maximum number of EmailThread records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailThreadGroupByOutput]
            A list of dictionaries representing the EmailThread record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailThread records by isRead values
        # and count how many records are in each group
        results = await EmailThread.prisma().group_by(
            ['isRead'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Email]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Email.prisma().query_raw(
            'SELECT * FROM Email WHERE id = $1',
            'gdcgcgagj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Email
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Email.prisma().query_first(
            'SELECT * FROM Email WHERE userId = $1',
            'bhceabbgja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailCreateInput,
        include: Optional[types.EmailInclude] = None
    ) -> _PrismaModelT:
        """Create a new Email record.

        Parameters
        ----------
        data
            Email record data
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The created Email record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Email record from just the required fields
        email = await Email.prisma().create(
            data={
                # data to create a Email record
                'userId': 'ehabfhegh',
                'organizationId': 'bcajcajjbc',
                'threadId': 'bfdgheeegf',
                'gmailMessageId': 'ececbijji',
                'sender': 'cbcfgdcdhf',
                'subject': 'fdgjfbhia',
                'sentAt': datetime.datetime.utcnow(),
                'receivedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Email records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Email record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Email.prisma().create_many(
            data=[
                {
                    # data to create a Email record
                    'userId': 'jcehcdchh',
                    'organizationId': 'bgcbjdhjcc',
                    'threadId': 'bieiidcabj',
                    'gmailMessageId': 'bjcbfcieaa',
                    'sender': 'cbaaechiej',
                    'subject': 'iejbeaaeg',
                    'sentAt': datetime.datetime.utcnow(),
                    'receivedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Email record
                    'userId': 'jcibfcbhf',
                    'organizationId': 'chdadcaga',
                    'threadId': 'jicieifbh',
                    'gmailMessageId': 'fbahdheji',
                    'sender': 'cbbheiicgh',
                    'subject': 'beabjeejdg',
                    'sentAt': datetime.datetime.utcnow(),
                    'receivedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailWhereUniqueInput,
        include: Optional[types.EmailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Email record.

        Parameters
        ----------
        where
            Email filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The deleted Email record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        email = await Email.prisma().delete(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailWhereUniqueInput,
        include: Optional[types.EmailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Email record.

        Parameters
        ----------
        where
            Email filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The found Email record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        email = await Email.prisma().find_unique(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailWhereUniqueInput,
        include: Optional[types.EmailInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Email record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Email filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The found Email record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        email = await Email.prisma().find_unique_or_raise(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
        include: Optional[types.EmailInclude] = None,
        order: Optional[Union[types.EmailOrderByInput, List[types.EmailOrderByInput]]] = None,
        distinct: Optional[List[types.EmailScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Email records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Email records returned
        skip
            Ignore the first N results
        where
            Email filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Email model
        order
            Order the returned Email records by any field
        distinct
            Filter Email records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Email]
            The list of all Email records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Email records
        emails = await Email.prisma().find_many(take=10)

        # find the first 5 Email records ordered by the organizationId field
        emails = await Email.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
        include: Optional[types.EmailInclude] = None,
        order: Optional[Union[types.EmailOrderByInput, List[types.EmailOrderByInput]]] = None,
        distinct: Optional[List[types.EmailScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Email record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Email filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Email model
        order
            Order the returned Email records by any field
        distinct
            Filter Email records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Email
            The first Email record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Email record ordered by the threadId field
        email = await Email.prisma().find_first(
            skip=1,
            order={
                'threadId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
        include: Optional[types.EmailInclude] = None,
        order: Optional[Union[types.EmailOrderByInput, List[types.EmailOrderByInput]]] = None,
        distinct: Optional[List[types.EmailScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Email record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Email filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Email model
        order
            Order the returned Email records by any field
        distinct
            Filter Email records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Email
            The first Email record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Email record ordered by the gmailMessageId field
        email = await Email.prisma().find_first_or_raise(
            skip=1,
            order={
                'gmailMessageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailUpdateInput,
        where: types.EmailWhereUniqueInput,
        include: Optional[types.EmailInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Email record.

        Parameters
        ----------
        data
            Email record data specifying what to update
        where
            Email filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The updated Email record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        email = await Email.prisma().update(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                # data to update the Email record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailWhereUniqueInput,
        data: types.EmailUpsertInput,
        include: Optional[types.EmailInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Email filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Email model

        Returns
        -------
        prisma.models.Email
            The created or updated Email record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        email = await Email.prisma().upsert(
            where={
                'id': 'bgjcgchib',
            },
            data={
                'create': {
                    'id': 'bgjcgchib',
                    'userId': 'jcibfcbhf',
                    'organizationId': 'chdadcaga',
                    'threadId': 'jicieifbh',
                    'gmailMessageId': 'fbahdheji',
                    'sender': 'cbbheiicgh',
                    'subject': 'beabjeejdg',
                    'sentAt': datetime.datetime.utcnow(),
                    'receivedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'jcibfcbhf',
                    'organizationId': 'chdadcaga',
                    'threadId': 'jicieifbh',
                    'gmailMessageId': 'fbahdheji',
                    'sender': 'cbbheiicgh',
                    'subject': 'beabjeejdg',
                    'sentAt': datetime.datetime.utcnow(),
                    'receivedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailUpdateManyMutationInput,
        where: types.EmailWhereInput,
    ) -> int:
        """Update multiple Email records

        Parameters
        ----------
        data
            Email data to update the selected Email records to
        where
            Filter to select the Email records to update

        Returns
        -------
        int
            The total number of Email records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Email records
        total = await Email.prisma().update_many(
            data={
                'messageId': 'bacdaibgfa'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Email records present in the database

        Parameters
        ----------
        select
            Select the Email fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Email filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Email.prisma().count()

        # results: prisma.types.EmailCountAggregateOutput
        results = await Email.prisma().count(
            select={
                '_all': True,
                'inReplyTo': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
    ) -> types.EmailCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailWhereInput] = None,
        cursor: Optional[types.EmailWhereUniqueInput] = None,
    ) -> Union[int, types.EmailCountAggregateOutput]:
        """Count the number of Email records present in the database

        Parameters
        ----------
        select
            Select the Email fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Email filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Email.prisma().count()

        # results: prisma.types.EmailCountAggregateOutput
        results = await Email.prisma().count(
            select={
                '_all': True,
                'references': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailWhereInput] = None
    ) -> int:
        """Delete multiple Email records.

        Parameters
        ----------
        where
            Optional Email filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Email records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Email records
        total = await Email.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailScalarFieldKeys'],
        *,
        where: Optional['types.EmailWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailAvgAggregateInput'] = None,
        sum: Optional['types.EmailSumAggregateInput'] = None,
        min: Optional['types.EmailMinAggregateInput'] = None,
        max: Optional['types.EmailMaxAggregateInput'] = None,
        having: Optional['types.EmailScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailGroupByOutput']:
        """Group Email records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Email fields to group records by
        where
            Email filter to select records
        take
            Limit the maximum number of Email records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailGroupByOutput]
            A list of dictionaries representing the Email record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Email records by sender values
        # and count how many records are in each group
        results = await Email.prisma().group_by(
            ['sender'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailContentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailContent]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailContent.prisma().query_raw(
            'SELECT * FROM EmailContent WHERE id = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailContent
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailContent.prisma().query_first(
            'SELECT * FROM EmailContent WHERE emailId = $1',
            'fchheijjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailContentCreateInput,
        include: Optional[types.EmailContentInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailContent record.

        Parameters
        ----------
        data
            EmailContent record data
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The created EmailContent record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailContent record from just the required fields
        emailcontent = await EmailContent.prisma().create(
            data={
                # data to create a EmailContent record
                'emailId': 'cacjdfhejh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailContentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailContent records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailContent record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailContent.prisma().create_many(
            data=[
                {
                    # data to create a EmailContent record
                    'emailId': 'bdbifjhbbi',
                },
                {
                    # data to create a EmailContent record
                    'emailId': 'cbccbbcdfb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailContentWhereUniqueInput,
        include: Optional[types.EmailContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailContent record.

        Parameters
        ----------
        where
            EmailContent filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The deleted EmailContent record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcontent = await EmailContent.prisma().delete(
            where={
                'id': 'bacejedaca',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailContentWhereUniqueInput,
        include: Optional[types.EmailContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailContent record.

        Parameters
        ----------
        where
            EmailContent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The found EmailContent record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcontent = await EmailContent.prisma().find_unique(
            where={
                'id': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailContentWhereUniqueInput,
        include: Optional[types.EmailContentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailContent record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailContent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The found EmailContent record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcontent = await EmailContent.prisma().find_unique_or_raise(
            where={
                'id': 'bfjibceaec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
        include: Optional[types.EmailContentInclude] = None,
        order: Optional[Union[types.EmailContentOrderByInput, List[types.EmailContentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailContentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailContent records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailContent records returned
        skip
            Ignore the first N results
        where
            EmailContent filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailContent model
        order
            Order the returned EmailContent records by any field
        distinct
            Filter EmailContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailContent]
            The list of all EmailContent records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailContent records
        emailcontents = await EmailContent.prisma().find_many(take=10)

        # find the first 5 EmailContent records ordered by the textBody field
        emailcontents = await EmailContent.prisma().find_many(
            take=5,
            order={
                'textBody': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
        include: Optional[types.EmailContentInclude] = None,
        order: Optional[Union[types.EmailContentOrderByInput, List[types.EmailContentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailContentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailContent record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailContent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailContent model
        order
            Order the returned EmailContent records by any field
        distinct
            Filter EmailContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailContent
            The first EmailContent record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailContent record ordered by the htmlBody field
        emailcontent = await EmailContent.prisma().find_first(
            skip=1,
            order={
                'htmlBody': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
        include: Optional[types.EmailContentInclude] = None,
        order: Optional[Union[types.EmailContentOrderByInput, List[types.EmailContentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailContentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailContent record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailContent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailContent model
        order
            Order the returned EmailContent records by any field
        distinct
            Filter EmailContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailContent
            The first EmailContent record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailContent record ordered by the createdAt field
        emailcontent = await EmailContent.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailContentUpdateInput,
        where: types.EmailContentWhereUniqueInput,
        include: Optional[types.EmailContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailContent record.

        Parameters
        ----------
        data
            EmailContent record data specifying what to update
        where
            EmailContent filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The updated EmailContent record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailcontent = await EmailContent.prisma().update(
            where={
                'id': 'ibhgcdbgd',
            },
            data={
                # data to update the EmailContent record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailContentWhereUniqueInput,
        data: types.EmailContentUpsertInput,
        include: Optional[types.EmailContentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailContent filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailContent model

        Returns
        -------
        prisma.models.EmailContent
            The created or updated EmailContent record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcontent = await EmailContent.prisma().upsert(
            where={
                'id': 'badaffhddg',
            },
            data={
                'create': {
                    'id': 'badaffhddg',
                    'emailId': 'cbccbbcdfb',
                },
                'update': {
                    'emailId': 'cbccbbcdfb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailContentUpdateManyMutationInput,
        where: types.EmailContentWhereInput,
    ) -> int:
        """Update multiple EmailContent records

        Parameters
        ----------
        data
            EmailContent data to update the selected EmailContent records to
        where
            Filter to select the EmailContent records to update

        Returns
        -------
        int
            The total number of EmailContent records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailContent records
        total = await EmailContent.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailContent records present in the database

        Parameters
        ----------
        select
            Select the EmailContent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailContent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailContentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailContent.prisma().count()

        # results: prisma.types.EmailContentCountAggregateOutput
        results = await EmailContent.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailContentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
    ) -> types.EmailContentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailContentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailContentWhereInput] = None,
        cursor: Optional[types.EmailContentWhereUniqueInput] = None,
    ) -> Union[int, types.EmailContentCountAggregateOutput]:
        """Count the number of EmailContent records present in the database

        Parameters
        ----------
        select
            Select the EmailContent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailContent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailContentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailContent.prisma().count()

        # results: prisma.types.EmailContentCountAggregateOutput
        results = await EmailContent.prisma().count(
            select={
                '_all': True,
                'emailId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailContentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailContentWhereInput] = None
    ) -> int:
        """Delete multiple EmailContent records.

        Parameters
        ----------
        where
            Optional EmailContent filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailContent records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailContent records
        total = await EmailContent.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailContentScalarFieldKeys'],
        *,
        where: Optional['types.EmailContentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailContentAvgAggregateInput'] = None,
        sum: Optional['types.EmailContentSumAggregateInput'] = None,
        min: Optional['types.EmailContentMinAggregateInput'] = None,
        max: Optional['types.EmailContentMaxAggregateInput'] = None,
        having: Optional['types.EmailContentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailContentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailContentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailContentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailContentGroupByOutput']:
        """Group EmailContent records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailContent fields to group records by
        where
            EmailContent filter to select records
        take
            Limit the maximum number of EmailContent records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailContentGroupByOutput]
            A list of dictionaries representing the EmailContent record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailContent records by textBody values
        # and count how many records are in each group
        results = await EmailContent.prisma().group_by(
            ['textBody'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailAttachmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailAttachment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailAttachment.prisma().query_raw(
            'SELECT * FROM EmailAttachment WHERE id = $1',
            'bbdbfcfihd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailAttachment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailAttachment.prisma().query_first(
            'SELECT * FROM EmailAttachment WHERE emailId = $1',
            'cbagggbji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailAttachmentCreateInput,
        include: Optional[types.EmailAttachmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailAttachment record.

        Parameters
        ----------
        data
            EmailAttachment record data
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The created EmailAttachment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailAttachment record from just the required fields
        emailattachment = await EmailAttachment.prisma().create(
            data={
                # data to create a EmailAttachment record
                'emailId': 'bchgafhjed',
                'gmailAttachmentId': 'heffgjdei',
                'filename': 'dahihgbeb',
                'mimeType': 'bgheaejbcc',
                'size': 1526854643,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailAttachmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailAttachment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailAttachment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailAttachment.prisma().create_many(
            data=[
                {
                    # data to create a EmailAttachment record
                    'emailId': 'jfiahhbae',
                    'gmailAttachmentId': 'bfbdafajcb',
                    'filename': 'caeghehde',
                    'mimeType': 'caghgfbggd',
                    'size': 1183911900,
                },
                {
                    # data to create a EmailAttachment record
                    'emailId': 'bfijhaejdd',
                    'gmailAttachmentId': 'bcedehfiji',
                    'filename': 'bdgjicijhb',
                    'mimeType': 'bghifjdeia',
                    'size': 403521121,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailAttachmentWhereUniqueInput,
        include: Optional[types.EmailAttachmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailAttachment record.

        Parameters
        ----------
        where
            EmailAttachment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The deleted EmailAttachment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailattachment = await EmailAttachment.prisma().delete(
            where={
                'id': 'geihgahba',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailAttachmentWhereUniqueInput,
        include: Optional[types.EmailAttachmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailAttachment record.

        Parameters
        ----------
        where
            EmailAttachment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The found EmailAttachment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailattachment = await EmailAttachment.prisma().find_unique(
            where={
                'id': 'gahdcdhbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailAttachmentWhereUniqueInput,
        include: Optional[types.EmailAttachmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailAttachment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailAttachment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The found EmailAttachment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailattachment = await EmailAttachment.prisma().find_unique_or_raise(
            where={
                'id': 'begiijahea',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
        include: Optional[types.EmailAttachmentInclude] = None,
        order: Optional[Union[types.EmailAttachmentOrderByInput, List[types.EmailAttachmentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailAttachmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailAttachment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailAttachment records returned
        skip
            Ignore the first N results
        where
            EmailAttachment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailAttachment model
        order
            Order the returned EmailAttachment records by any field
        distinct
            Filter EmailAttachment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailAttachment]
            The list of all EmailAttachment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailAttachment records
        emailattachments = await EmailAttachment.prisma().find_many(take=10)

        # find the first 5 EmailAttachment records ordered by the gmailAttachmentId field
        emailattachments = await EmailAttachment.prisma().find_many(
            take=5,
            order={
                'gmailAttachmentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
        include: Optional[types.EmailAttachmentInclude] = None,
        order: Optional[Union[types.EmailAttachmentOrderByInput, List[types.EmailAttachmentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailAttachmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailAttachment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailAttachment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailAttachment model
        order
            Order the returned EmailAttachment records by any field
        distinct
            Filter EmailAttachment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailAttachment
            The first EmailAttachment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailAttachment record ordered by the filename field
        emailattachment = await EmailAttachment.prisma().find_first(
            skip=1,
            order={
                'filename': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
        include: Optional[types.EmailAttachmentInclude] = None,
        order: Optional[Union[types.EmailAttachmentOrderByInput, List[types.EmailAttachmentOrderByInput]]] = None,
        distinct: Optional[List[types.EmailAttachmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailAttachment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailAttachment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailAttachment model
        order
            Order the returned EmailAttachment records by any field
        distinct
            Filter EmailAttachment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailAttachment
            The first EmailAttachment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailAttachment record ordered by the mimeType field
        emailattachment = await EmailAttachment.prisma().find_first_or_raise(
            skip=1,
            order={
                'mimeType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailAttachmentUpdateInput,
        where: types.EmailAttachmentWhereUniqueInput,
        include: Optional[types.EmailAttachmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailAttachment record.

        Parameters
        ----------
        data
            EmailAttachment record data specifying what to update
        where
            EmailAttachment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The updated EmailAttachment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailattachment = await EmailAttachment.prisma().update(
            where={
                'id': 'gcjadjaaf',
            },
            data={
                # data to update the EmailAttachment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailAttachmentWhereUniqueInput,
        data: types.EmailAttachmentUpsertInput,
        include: Optional[types.EmailAttachmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailAttachment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailAttachment model

        Returns
        -------
        prisma.models.EmailAttachment
            The created or updated EmailAttachment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailattachment = await EmailAttachment.prisma().upsert(
            where={
                'id': 'bcbebgiaic',
            },
            data={
                'create': {
                    'id': 'bcbebgiaic',
                    'emailId': 'bfijhaejdd',
                    'gmailAttachmentId': 'bcedehfiji',
                    'filename': 'bdgjicijhb',
                    'mimeType': 'bghifjdeia',
                    'size': 403521121,
                },
                'update': {
                    'emailId': 'bfijhaejdd',
                    'gmailAttachmentId': 'bcedehfiji',
                    'filename': 'bdgjicijhb',
                    'mimeType': 'bghifjdeia',
                    'size': 403521121,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailAttachmentUpdateManyMutationInput,
        where: types.EmailAttachmentWhereInput,
    ) -> int:
        """Update multiple EmailAttachment records

        Parameters
        ----------
        data
            EmailAttachment data to update the selected EmailAttachment records to
        where
            Filter to select the EmailAttachment records to update

        Returns
        -------
        int
            The total number of EmailAttachment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailAttachment records
        total = await EmailAttachment.prisma().update_many(
            data={
                'size': 898613219
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailAttachment records present in the database

        Parameters
        ----------
        select
            Select the EmailAttachment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailAttachment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailAttachmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailAttachment.prisma().count()

        # results: prisma.types.EmailAttachmentCountAggregateOutput
        results = await EmailAttachment.prisma().count(
            select={
                '_all': True,
                'openaiFileId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailAttachmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
    ) -> types.EmailAttachmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailAttachmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailAttachmentWhereInput] = None,
        cursor: Optional[types.EmailAttachmentWhereUniqueInput] = None,
    ) -> Union[int, types.EmailAttachmentCountAggregateOutput]:
        """Count the number of EmailAttachment records present in the database

        Parameters
        ----------
        select
            Select the EmailAttachment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailAttachment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailAttachmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailAttachment.prisma().count()

        # results: prisma.types.EmailAttachmentCountAggregateOutput
        results = await EmailAttachment.prisma().count(
            select={
                '_all': True,
                'openaiFileExpiresAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailAttachmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailAttachmentWhereInput] = None
    ) -> int:
        """Delete multiple EmailAttachment records.

        Parameters
        ----------
        where
            Optional EmailAttachment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailAttachment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailAttachment records
        total = await EmailAttachment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailAttachmentScalarFieldKeys'],
        *,
        where: Optional['types.EmailAttachmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailAttachmentAvgAggregateInput'] = None,
        sum: Optional['types.EmailAttachmentSumAggregateInput'] = None,
        min: Optional['types.EmailAttachmentMinAggregateInput'] = None,
        max: Optional['types.EmailAttachmentMaxAggregateInput'] = None,
        having: Optional['types.EmailAttachmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailAttachmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailAttachmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailAttachmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailAttachmentGroupByOutput']:
        """Group EmailAttachment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailAttachment fields to group records by
        where
            EmailAttachment filter to select records
        take
            Limit the maximum number of EmailAttachment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailAttachmentGroupByOutput]
            A list of dictionaries representing the EmailAttachment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailAttachment records by createdAt values
        # and count how many records are in each group
        results = await EmailAttachment.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailTaskActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailTask]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailTask.prisma().query_raw(
            'SELECT * FROM EmailTask WHERE id = $1',
            'gfidhicai',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailTask
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailTask.prisma().query_first(
            'SELECT * FROM EmailTask WHERE emailId = $1',
            'jfegcaafh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailTaskCreateInput,
        include: Optional[types.EmailTaskInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailTask record.

        Parameters
        ----------
        data
            EmailTask record data
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The created EmailTask record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailTask record from just the required fields
        emailtask = await EmailTask.prisma().create(
            data={
                # data to create a EmailTask record
                'emailId': 'bcbeiajjfa',
                'taskId': 'baehicaajf',
                'assignedBy': 'bdachdeiga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailTaskCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailTask records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailTask record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailTask.prisma().create_many(
            data=[
                {
                    # data to create a EmailTask record
                    'emailId': 'ijdafccef',
                    'taskId': 'ciaaiddag',
                    'assignedBy': 'fejggijff',
                },
                {
                    # data to create a EmailTask record
                    'emailId': 'hghjaaai',
                    'taskId': 'cajicjjdef',
                    'assignedBy': 'cefjaadec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailTaskWhereUniqueInput,
        include: Optional[types.EmailTaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailTask record.

        Parameters
        ----------
        where
            EmailTask filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The deleted EmailTask record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtask = await EmailTask.prisma().delete(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailTaskWhereUniqueInput,
        include: Optional[types.EmailTaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailTask record.

        Parameters
        ----------
        where
            EmailTask filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The found EmailTask record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtask = await EmailTask.prisma().find_unique(
            where={
                'id': 'bdiiiabbii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailTaskWhereUniqueInput,
        include: Optional[types.EmailTaskInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailTask record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailTask filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The found EmailTask record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtask = await EmailTask.prisma().find_unique_or_raise(
            where={
                'id': 'hfcfhhadh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
        include: Optional[types.EmailTaskInclude] = None,
        order: Optional[Union[types.EmailTaskOrderByInput, List[types.EmailTaskOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTaskScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailTask records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailTask records returned
        skip
            Ignore the first N results
        where
            EmailTask filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTask model
        order
            Order the returned EmailTask records by any field
        distinct
            Filter EmailTask records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailTask]
            The list of all EmailTask records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailTask records
        emailtasks = await EmailTask.prisma().find_many(take=10)

        # find the first 5 EmailTask records ordered by the taskId field
        emailtasks = await EmailTask.prisma().find_many(
            take=5,
            order={
                'taskId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
        include: Optional[types.EmailTaskInclude] = None,
        order: Optional[Union[types.EmailTaskOrderByInput, List[types.EmailTaskOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTaskScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailTask record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailTask filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTask model
        order
            Order the returned EmailTask records by any field
        distinct
            Filter EmailTask records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailTask
            The first EmailTask record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailTask record ordered by the assignedAt field
        emailtask = await EmailTask.prisma().find_first(
            skip=1,
            order={
                'assignedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
        include: Optional[types.EmailTaskInclude] = None,
        order: Optional[Union[types.EmailTaskOrderByInput, List[types.EmailTaskOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTaskScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailTask record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailTask filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTask model
        order
            Order the returned EmailTask records by any field
        distinct
            Filter EmailTask records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailTask
            The first EmailTask record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailTask record ordered by the assignedBy field
        emailtask = await EmailTask.prisma().find_first_or_raise(
            skip=1,
            order={
                'assignedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailTaskUpdateInput,
        where: types.EmailTaskWhereUniqueInput,
        include: Optional[types.EmailTaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailTask record.

        Parameters
        ----------
        data
            EmailTask record data specifying what to update
        where
            EmailTask filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The updated EmailTask record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailtask = await EmailTask.prisma().update(
            where={
                'id': 'bbihggdcji',
            },
            data={
                # data to update the EmailTask record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailTaskWhereUniqueInput,
        data: types.EmailTaskUpsertInput,
        include: Optional[types.EmailTaskInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailTask filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailTask model

        Returns
        -------
        prisma.models.EmailTask
            The created or updated EmailTask record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtask = await EmailTask.prisma().upsert(
            where={
                'id': 'hgjgibdgd',
            },
            data={
                'create': {
                    'id': 'hgjgibdgd',
                    'emailId': 'hghjaaai',
                    'taskId': 'cajicjjdef',
                    'assignedBy': 'cefjaadec',
                },
                'update': {
                    'emailId': 'hghjaaai',
                    'taskId': 'cajicjjdef',
                    'assignedBy': 'cefjaadec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailTaskUpdateManyMutationInput,
        where: types.EmailTaskWhereInput,
    ) -> int:
        """Update multiple EmailTask records

        Parameters
        ----------
        data
            EmailTask data to update the selected EmailTask records to
        where
            Filter to select the EmailTask records to update

        Returns
        -------
        int
            The total number of EmailTask records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailTask records
        total = await EmailTask.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailTask records present in the database

        Parameters
        ----------
        select
            Select the EmailTask fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailTask filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailTaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailTask.prisma().count()

        # results: prisma.types.EmailTaskCountAggregateOutput
        results = await EmailTask.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailTaskCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
    ) -> types.EmailTaskCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailTaskCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTaskWhereInput] = None,
        cursor: Optional[types.EmailTaskWhereUniqueInput] = None,
    ) -> Union[int, types.EmailTaskCountAggregateOutput]:
        """Count the number of EmailTask records present in the database

        Parameters
        ----------
        select
            Select the EmailTask fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailTask filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailTaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailTask.prisma().count()

        # results: prisma.types.EmailTaskCountAggregateOutput
        results = await EmailTask.prisma().count(
            select={
                '_all': True,
                'emailId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailTaskCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailTaskWhereInput] = None
    ) -> int:
        """Delete multiple EmailTask records.

        Parameters
        ----------
        where
            Optional EmailTask filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailTask records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailTask records
        total = await EmailTask.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailTaskScalarFieldKeys'],
        *,
        where: Optional['types.EmailTaskWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailTaskAvgAggregateInput'] = None,
        sum: Optional['types.EmailTaskSumAggregateInput'] = None,
        min: Optional['types.EmailTaskMinAggregateInput'] = None,
        max: Optional['types.EmailTaskMaxAggregateInput'] = None,
        having: Optional['types.EmailTaskScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailTaskCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailTaskScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailTaskScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailTaskGroupByOutput']:
        """Group EmailTask records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailTask fields to group records by
        where
            EmailTask filter to select records
        take
            Limit the maximum number of EmailTask records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailTaskGroupByOutput]
            A list of dictionaries representing the EmailTask record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailTask records by taskId values
        # and count how many records are in each group
        results = await EmailTask.prisma().group_by(
            ['taskId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailProjectActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailProject]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailProject.prisma().query_raw(
            'SELECT * FROM EmailProject WHERE id = $1',
            'bcbecjfice',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailProject
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailProject.prisma().query_first(
            'SELECT * FROM EmailProject WHERE emailId = $1',
            'bacbebhjjd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailProjectCreateInput,
        include: Optional[types.EmailProjectInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailProject record.

        Parameters
        ----------
        data
            EmailProject record data
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The created EmailProject record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailProject record from just the required fields
        emailproject = await EmailProject.prisma().create(
            data={
                # data to create a EmailProject record
                'emailId': 'dfbfaddhe',
                'projectId': 'bdcbbieibf',
                'assignedBy': 'dgjhdcggi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailProjectCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailProject records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailProject record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailProject.prisma().create_many(
            data=[
                {
                    # data to create a EmailProject record
                    'emailId': 'bbjbcdfabd',
                    'projectId': 'gchfgbcec',
                    'assignedBy': 'bihcjfcjah',
                },
                {
                    # data to create a EmailProject record
                    'emailId': 'bhjdcicaii',
                    'projectId': 'bibedjhcej',
                    'assignedBy': 'bjcdajabfa',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailProjectWhereUniqueInput,
        include: Optional[types.EmailProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailProject record.

        Parameters
        ----------
        where
            EmailProject filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The deleted EmailProject record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailproject = await EmailProject.prisma().delete(
            where={
                'id': 'bchhceeeff',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailProjectWhereUniqueInput,
        include: Optional[types.EmailProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailProject record.

        Parameters
        ----------
        where
            EmailProject filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The found EmailProject record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailproject = await EmailProject.prisma().find_unique(
            where={
                'id': 'bbgaifhdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailProjectWhereUniqueInput,
        include: Optional[types.EmailProjectInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailProject record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailProject filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The found EmailProject record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailproject = await EmailProject.prisma().find_unique_or_raise(
            where={
                'id': 'dgbcdaegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
        include: Optional[types.EmailProjectInclude] = None,
        order: Optional[Union[types.EmailProjectOrderByInput, List[types.EmailProjectOrderByInput]]] = None,
        distinct: Optional[List[types.EmailProjectScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailProject records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailProject records returned
        skip
            Ignore the first N results
        where
            EmailProject filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailProject model
        order
            Order the returned EmailProject records by any field
        distinct
            Filter EmailProject records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailProject]
            The list of all EmailProject records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailProject records
        emailprojects = await EmailProject.prisma().find_many(take=10)

        # find the first 5 EmailProject records ordered by the projectId field
        emailprojects = await EmailProject.prisma().find_many(
            take=5,
            order={
                'projectId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
        include: Optional[types.EmailProjectInclude] = None,
        order: Optional[Union[types.EmailProjectOrderByInput, List[types.EmailProjectOrderByInput]]] = None,
        distinct: Optional[List[types.EmailProjectScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailProject record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailProject filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailProject model
        order
            Order the returned EmailProject records by any field
        distinct
            Filter EmailProject records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailProject
            The first EmailProject record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailProject record ordered by the assignedAt field
        emailproject = await EmailProject.prisma().find_first(
            skip=1,
            order={
                'assignedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
        include: Optional[types.EmailProjectInclude] = None,
        order: Optional[Union[types.EmailProjectOrderByInput, List[types.EmailProjectOrderByInput]]] = None,
        distinct: Optional[List[types.EmailProjectScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailProject record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailProject filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailProject model
        order
            Order the returned EmailProject records by any field
        distinct
            Filter EmailProject records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailProject
            The first EmailProject record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailProject record ordered by the assignedBy field
        emailproject = await EmailProject.prisma().find_first_or_raise(
            skip=1,
            order={
                'assignedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailProjectUpdateInput,
        where: types.EmailProjectWhereUniqueInput,
        include: Optional[types.EmailProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailProject record.

        Parameters
        ----------
        data
            EmailProject record data specifying what to update
        where
            EmailProject filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The updated EmailProject record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailproject = await EmailProject.prisma().update(
            where={
                'id': 'beagfbbjig',
            },
            data={
                # data to update the EmailProject record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailProjectWhereUniqueInput,
        data: types.EmailProjectUpsertInput,
        include: Optional[types.EmailProjectInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailProject filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailProject model

        Returns
        -------
        prisma.models.EmailProject
            The created or updated EmailProject record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailproject = await EmailProject.prisma().upsert(
            where={
                'id': 'beicihhijb',
            },
            data={
                'create': {
                    'id': 'beicihhijb',
                    'emailId': 'bhjdcicaii',
                    'projectId': 'bibedjhcej',
                    'assignedBy': 'bjcdajabfa',
                },
                'update': {
                    'emailId': 'bhjdcicaii',
                    'projectId': 'bibedjhcej',
                    'assignedBy': 'bjcdajabfa',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailProjectUpdateManyMutationInput,
        where: types.EmailProjectWhereInput,
    ) -> int:
        """Update multiple EmailProject records

        Parameters
        ----------
        data
            EmailProject data to update the selected EmailProject records to
        where
            Filter to select the EmailProject records to update

        Returns
        -------
        int
            The total number of EmailProject records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailProject records
        total = await EmailProject.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailProject records present in the database

        Parameters
        ----------
        select
            Select the EmailProject fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailProject filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailProject.prisma().count()

        # results: prisma.types.EmailProjectCountAggregateOutput
        results = await EmailProject.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailProjectCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
    ) -> types.EmailProjectCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailProjectCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailProjectWhereInput] = None,
        cursor: Optional[types.EmailProjectWhereUniqueInput] = None,
    ) -> Union[int, types.EmailProjectCountAggregateOutput]:
        """Count the number of EmailProject records present in the database

        Parameters
        ----------
        select
            Select the EmailProject fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailProject filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailProject.prisma().count()

        # results: prisma.types.EmailProjectCountAggregateOutput
        results = await EmailProject.prisma().count(
            select={
                '_all': True,
                'emailId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailProjectCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailProjectWhereInput] = None
    ) -> int:
        """Delete multiple EmailProject records.

        Parameters
        ----------
        where
            Optional EmailProject filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailProject records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailProject records
        total = await EmailProject.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailProjectScalarFieldKeys'],
        *,
        where: Optional['types.EmailProjectWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailProjectAvgAggregateInput'] = None,
        sum: Optional['types.EmailProjectSumAggregateInput'] = None,
        min: Optional['types.EmailProjectMinAggregateInput'] = None,
        max: Optional['types.EmailProjectMaxAggregateInput'] = None,
        having: Optional['types.EmailProjectScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailProjectCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailProjectScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailProjectScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailProjectGroupByOutput']:
        """Group EmailProject records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailProject fields to group records by
        where
            EmailProject filter to select records
        take
            Limit the maximum number of EmailProject records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailProjectGroupByOutput]
            A list of dictionaries representing the EmailProject record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailProject records by projectId values
        # and count how many records are in each group
        results = await EmailProject.prisma().group_by(
            ['projectId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailApprovalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailApproval]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailApproval.prisma().query_raw(
            'SELECT * FROM EmailApproval WHERE id = $1',
            'fgggcdcjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailApproval
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailApproval.prisma().query_first(
            'SELECT * FROM EmailApproval WHERE emailId = $1',
            'ccjbbjigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailApprovalCreateInput,
        include: Optional[types.EmailApprovalInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailApproval record.

        Parameters
        ----------
        data
            EmailApproval record data
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The created EmailApproval record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailApproval record from just the required fields
        emailapproval = await EmailApproval.prisma().create(
            data={
                # data to create a EmailApproval record
                'emailId': 'bhfaabbaha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailApprovalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailApproval records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailApproval record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailApproval.prisma().create_many(
            data=[
                {
                    # data to create a EmailApproval record
                    'emailId': 'ebajedhhf',
                },
                {
                    # data to create a EmailApproval record
                    'emailId': 'jajacedge',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailApprovalWhereUniqueInput,
        include: Optional[types.EmailApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailApproval record.

        Parameters
        ----------
        where
            EmailApproval filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The deleted EmailApproval record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailapproval = await EmailApproval.prisma().delete(
            where={
                'id': 'hffgbabgf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailApprovalWhereUniqueInput,
        include: Optional[types.EmailApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailApproval record.

        Parameters
        ----------
        where
            EmailApproval filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The found EmailApproval record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailapproval = await EmailApproval.prisma().find_unique(
            where={
                'id': 'biacbiieja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailApprovalWhereUniqueInput,
        include: Optional[types.EmailApprovalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailApproval record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailApproval filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The found EmailApproval record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailapproval = await EmailApproval.prisma().find_unique_or_raise(
            where={
                'id': 'cjejbgbff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
        include: Optional[types.EmailApprovalInclude] = None,
        order: Optional[Union[types.EmailApprovalOrderByInput, List[types.EmailApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.EmailApprovalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailApproval records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailApproval records returned
        skip
            Ignore the first N results
        where
            EmailApproval filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailApproval model
        order
            Order the returned EmailApproval records by any field
        distinct
            Filter EmailApproval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailApproval]
            The list of all EmailApproval records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailApproval records
        emailapprovals = await EmailApproval.prisma().find_many(take=10)

        # find the first 5 EmailApproval records ordered by the status field
        emailapprovals = await EmailApproval.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
        include: Optional[types.EmailApprovalInclude] = None,
        order: Optional[Union[types.EmailApprovalOrderByInput, List[types.EmailApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.EmailApprovalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailApproval record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailApproval filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailApproval model
        order
            Order the returned EmailApproval records by any field
        distinct
            Filter EmailApproval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailApproval
            The first EmailApproval record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailApproval record ordered by the classifiedBy field
        emailapproval = await EmailApproval.prisma().find_first(
            skip=1,
            order={
                'classifiedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
        include: Optional[types.EmailApprovalInclude] = None,
        order: Optional[Union[types.EmailApprovalOrderByInput, List[types.EmailApprovalOrderByInput]]] = None,
        distinct: Optional[List[types.EmailApprovalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailApproval record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailApproval filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailApproval model
        order
            Order the returned EmailApproval records by any field
        distinct
            Filter EmailApproval records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailApproval
            The first EmailApproval record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailApproval record ordered by the classifiedAt field
        emailapproval = await EmailApproval.prisma().find_first_or_raise(
            skip=1,
            order={
                'classifiedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailApprovalUpdateInput,
        where: types.EmailApprovalWhereUniqueInput,
        include: Optional[types.EmailApprovalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailApproval record.

        Parameters
        ----------
        data
            EmailApproval record data specifying what to update
        where
            EmailApproval filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The updated EmailApproval record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailapproval = await EmailApproval.prisma().update(
            where={
                'id': 'fgeahddae',
            },
            data={
                # data to update the EmailApproval record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailApprovalWhereUniqueInput,
        data: types.EmailApprovalUpsertInput,
        include: Optional[types.EmailApprovalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailApproval filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailApproval model

        Returns
        -------
        prisma.models.EmailApproval
            The created or updated EmailApproval record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailapproval = await EmailApproval.prisma().upsert(
            where={
                'id': 'diageigcf',
            },
            data={
                'create': {
                    'id': 'diageigcf',
                    'emailId': 'jajacedge',
                },
                'update': {
                    'emailId': 'jajacedge',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailApprovalUpdateManyMutationInput,
        where: types.EmailApprovalWhereInput,
    ) -> int:
        """Update multiple EmailApproval records

        Parameters
        ----------
        data
            EmailApproval data to update the selected EmailApproval records to
        where
            Filter to select the EmailApproval records to update

        Returns
        -------
        int
            The total number of EmailApproval records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailApproval records
        total = await EmailApproval.prisma().update_many(
            data={
                'comment': 'badagbgeha'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailApproval records present in the database

        Parameters
        ----------
        select
            Select the EmailApproval fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailApproval filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailApprovalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailApproval.prisma().count()

        # results: prisma.types.EmailApprovalCountAggregateOutput
        results = await EmailApproval.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailApprovalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
    ) -> types.EmailApprovalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailApprovalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailApprovalWhereInput] = None,
        cursor: Optional[types.EmailApprovalWhereUniqueInput] = None,
    ) -> Union[int, types.EmailApprovalCountAggregateOutput]:
        """Count the number of EmailApproval records present in the database

        Parameters
        ----------
        select
            Select the EmailApproval fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailApproval filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailApprovalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailApproval.prisma().count()

        # results: prisma.types.EmailApprovalCountAggregateOutput
        results = await EmailApproval.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailApprovalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailApprovalWhereInput] = None
    ) -> int:
        """Delete multiple EmailApproval records.

        Parameters
        ----------
        where
            Optional EmailApproval filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailApproval records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailApproval records
        total = await EmailApproval.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailApprovalScalarFieldKeys'],
        *,
        where: Optional['types.EmailApprovalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailApprovalAvgAggregateInput'] = None,
        sum: Optional['types.EmailApprovalSumAggregateInput'] = None,
        min: Optional['types.EmailApprovalMinAggregateInput'] = None,
        max: Optional['types.EmailApprovalMaxAggregateInput'] = None,
        having: Optional['types.EmailApprovalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailApprovalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailApprovalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailApprovalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailApprovalGroupByOutput']:
        """Group EmailApproval records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailApproval fields to group records by
        where
            EmailApproval filter to select records
        take
            Limit the maximum number of EmailApproval records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailApprovalGroupByOutput]
            A list of dictionaries representing the EmailApproval record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailApproval records by id values
        # and count how many records are in each group
        results = await EmailApproval.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectProposalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectProposal]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectProposal.prisma().query_raw(
            'SELECT * FROM ProjectProposal WHERE id = $1',
            'ibgebbjch',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectProposal
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectProposal.prisma().query_first(
            'SELECT * FROM ProjectProposal WHERE organizationId = $1',
            'baieajjiee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectProposalCreateInput,
        include: Optional[types.ProjectProposalInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectProposal record.

        Parameters
        ----------
        data
            ProjectProposal record data
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The created ProjectProposal record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectProposal record from just the required fields
        projectproposal = await ProjectProposal.prisma().create(
            data={
                # data to create a ProjectProposal record
                'organizationId': 'bahjhaccfd',
                'proposedName': 'hffhfabhi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectProposalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectProposal records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectProposal record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectProposal.prisma().create_many(
            data=[
                {
                    # data to create a ProjectProposal record
                    'organizationId': 'bbcigiadhb',
                    'proposedName': 'cfjagbbae',
                },
                {
                    # data to create a ProjectProposal record
                    'organizationId': 'bbbfhdidef',
                    'proposedName': 'bdadhibhec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectProposalWhereUniqueInput,
        include: Optional[types.ProjectProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectProposal record.

        Parameters
        ----------
        where
            ProjectProposal filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The deleted ProjectProposal record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectproposal = await ProjectProposal.prisma().delete(
            where={
                'id': 'bfhdjaiejf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectProposalWhereUniqueInput,
        include: Optional[types.ProjectProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectProposal record.

        Parameters
        ----------
        where
            ProjectProposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The found ProjectProposal record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectproposal = await ProjectProposal.prisma().find_unique(
            where={
                'id': 'bbjfijjadg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectProposalWhereUniqueInput,
        include: Optional[types.ProjectProposalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectProposal record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectProposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The found ProjectProposal record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectproposal = await ProjectProposal.prisma().find_unique_or_raise(
            where={
                'id': 'hdjacbehh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
        include: Optional[types.ProjectProposalInclude] = None,
        order: Optional[Union[types.ProjectProposalOrderByInput, List[types.ProjectProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectProposalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectProposal records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectProposal records returned
        skip
            Ignore the first N results
        where
            ProjectProposal filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectProposal model
        order
            Order the returned ProjectProposal records by any field
        distinct
            Filter ProjectProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectProposal]
            The list of all ProjectProposal records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectProposal records
        projectproposals = await ProjectProposal.prisma().find_many(take=10)

        # find the first 5 ProjectProposal records ordered by the proposedName field
        projectproposals = await ProjectProposal.prisma().find_many(
            take=5,
            order={
                'proposedName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
        include: Optional[types.ProjectProposalInclude] = None,
        order: Optional[Union[types.ProjectProposalOrderByInput, List[types.ProjectProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectProposalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectProposal record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectProposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectProposal model
        order
            Order the returned ProjectProposal records by any field
        distinct
            Filter ProjectProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectProposal
            The first ProjectProposal record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectProposal record ordered by the proposedDescription field
        projectproposal = await ProjectProposal.prisma().find_first(
            skip=1,
            order={
                'proposedDescription': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
        include: Optional[types.ProjectProposalInclude] = None,
        order: Optional[Union[types.ProjectProposalOrderByInput, List[types.ProjectProposalOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectProposalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectProposal record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectProposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectProposal model
        order
            Order the returned ProjectProposal records by any field
        distinct
            Filter ProjectProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectProposal
            The first ProjectProposal record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectProposal record ordered by the proposedTasks field
        projectproposal = await ProjectProposal.prisma().find_first_or_raise(
            skip=1,
            order={
                'proposedTasks': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectProposalUpdateInput,
        where: types.ProjectProposalWhereUniqueInput,
        include: Optional[types.ProjectProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectProposal record.

        Parameters
        ----------
        data
            ProjectProposal record data specifying what to update
        where
            ProjectProposal filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The updated ProjectProposal record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectproposal = await ProjectProposal.prisma().update(
            where={
                'id': 'bhcccbeaba',
            },
            data={
                # data to update the ProjectProposal record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectProposalWhereUniqueInput,
        data: types.ProjectProposalUpsertInput,
        include: Optional[types.ProjectProposalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectProposal filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectProposal model

        Returns
        -------
        prisma.models.ProjectProposal
            The created or updated ProjectProposal record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectproposal = await ProjectProposal.prisma().upsert(
            where={
                'id': 'bcgjbdgjdj',
            },
            data={
                'create': {
                    'id': 'bcgjbdgjdj',
                    'organizationId': 'bbbfhdidef',
                    'proposedName': 'bdadhibhec',
                },
                'update': {
                    'organizationId': 'bbbfhdidef',
                    'proposedName': 'bdadhibhec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectProposalUpdateManyMutationInput,
        where: types.ProjectProposalWhereInput,
    ) -> int:
        """Update multiple ProjectProposal records

        Parameters
        ----------
        data
            ProjectProposal data to update the selected ProjectProposal records to
        where
            Filter to select the ProjectProposal records to update

        Returns
        -------
        int
            The total number of ProjectProposal records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectProposal records
        total = await ProjectProposal.prisma().update_many(
            data={
                'createdProjectId': 'fhdbhifae'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectProposal records present in the database

        Parameters
        ----------
        select
            Select the ProjectProposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectProposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectProposal.prisma().count()

        # results: prisma.types.ProjectProposalCountAggregateOutput
        results = await ProjectProposal.prisma().count(
            select={
                '_all': True,
                'createdTaskIds': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectProposalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
    ) -> types.ProjectProposalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectProposalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectProposalWhereInput] = None,
        cursor: Optional[types.ProjectProposalWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectProposalCountAggregateOutput]:
        """Count the number of ProjectProposal records present in the database

        Parameters
        ----------
        select
            Select the ProjectProposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectProposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectProposal.prisma().count()

        # results: prisma.types.ProjectProposalCountAggregateOutput
        results = await ProjectProposal.prisma().count(
            select={
                '_all': True,
                'resolvedAs': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectProposalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectProposalWhereInput] = None
    ) -> int:
        """Delete multiple ProjectProposal records.

        Parameters
        ----------
        where
            Optional ProjectProposal filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectProposal records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectProposal records
        total = await ProjectProposal.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectProposalScalarFieldKeys'],
        *,
        where: Optional['types.ProjectProposalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectProposalAvgAggregateInput'] = None,
        sum: Optional['types.ProjectProposalSumAggregateInput'] = None,
        min: Optional['types.ProjectProposalMinAggregateInput'] = None,
        max: Optional['types.ProjectProposalMaxAggregateInput'] = None,
        having: Optional['types.ProjectProposalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectProposalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectProposalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectProposalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectProposalGroupByOutput']:
        """Group ProjectProposal records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectProposal fields to group records by
        where
            ProjectProposal filter to select records
        take
            Limit the maximum number of ProjectProposal records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectProposalGroupByOutput]
            A list of dictionaries representing the ProjectProposal record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectProposal records by createdAt values
        # and count how many records are in each group
        results = await ProjectProposal.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TaskProposalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TaskProposal]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TaskProposal.prisma().query_raw(
            'SELECT * FROM TaskProposal WHERE id = $1',
            'beeacgfcej',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TaskProposal
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TaskProposal.prisma().query_first(
            'SELECT * FROM TaskProposal WHERE organizationId = $1',
            'bbifhdiicc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TaskProposalCreateInput,
        include: Optional[types.TaskProposalInclude] = None
    ) -> _PrismaModelT:
        """Create a new TaskProposal record.

        Parameters
        ----------
        data
            TaskProposal record data
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The created TaskProposal record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TaskProposal record from just the required fields
        taskproposal = await TaskProposal.prisma().create(
            data={
                # data to create a TaskProposal record
                'organizationId': 'bgjeccejad',
                'proposedTaskName': 'bjagdgabbg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TaskProposalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TaskProposal records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TaskProposal record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TaskProposal.prisma().create_many(
            data=[
                {
                    # data to create a TaskProposal record
                    'organizationId': 'bjbbcffdij',
                    'proposedTaskName': 'begcgchdi',
                },
                {
                    # data to create a TaskProposal record
                    'organizationId': 'bhbjceagbb',
                    'proposedTaskName': 'bjeifffjdg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TaskProposalWhereUniqueInput,
        include: Optional[types.TaskProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TaskProposal record.

        Parameters
        ----------
        where
            TaskProposal filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The deleted TaskProposal record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taskproposal = await TaskProposal.prisma().delete(
            where={
                'id': 'bdidcfdfjd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TaskProposalWhereUniqueInput,
        include: Optional[types.TaskProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TaskProposal record.

        Parameters
        ----------
        where
            TaskProposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The found TaskProposal record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taskproposal = await TaskProposal.prisma().find_unique(
            where={
                'id': 'dfeggejja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TaskProposalWhereUniqueInput,
        include: Optional[types.TaskProposalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TaskProposal record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TaskProposal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The found TaskProposal record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taskproposal = await TaskProposal.prisma().find_unique_or_raise(
            where={
                'id': 'gehbgghbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
        include: Optional[types.TaskProposalInclude] = None,
        order: Optional[Union[types.TaskProposalOrderByInput, List[types.TaskProposalOrderByInput]]] = None,
        distinct: Optional[List[types.TaskProposalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TaskProposal records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TaskProposal records returned
        skip
            Ignore the first N results
        where
            TaskProposal filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaskProposal model
        order
            Order the returned TaskProposal records by any field
        distinct
            Filter TaskProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TaskProposal]
            The list of all TaskProposal records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TaskProposal records
        taskproposals = await TaskProposal.prisma().find_many(take=10)

        # find the first 5 TaskProposal records ordered by the projectId field
        taskproposals = await TaskProposal.prisma().find_many(
            take=5,
            order={
                'projectId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
        include: Optional[types.TaskProposalInclude] = None,
        order: Optional[Union[types.TaskProposalOrderByInput, List[types.TaskProposalOrderByInput]]] = None,
        distinct: Optional[List[types.TaskProposalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TaskProposal record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TaskProposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaskProposal model
        order
            Order the returned TaskProposal records by any field
        distinct
            Filter TaskProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TaskProposal
            The first TaskProposal record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TaskProposal record ordered by the proposedTaskName field
        taskproposal = await TaskProposal.prisma().find_first(
            skip=1,
            order={
                'proposedTaskName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
        include: Optional[types.TaskProposalInclude] = None,
        order: Optional[Union[types.TaskProposalOrderByInput, List[types.TaskProposalOrderByInput]]] = None,
        distinct: Optional[List[types.TaskProposalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TaskProposal record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TaskProposal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TaskProposal model
        order
            Order the returned TaskProposal records by any field
        distinct
            Filter TaskProposal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TaskProposal
            The first TaskProposal record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TaskProposal record ordered by the proposedDescription field
        taskproposal = await TaskProposal.prisma().find_first_or_raise(
            skip=1,
            order={
                'proposedDescription': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TaskProposalUpdateInput,
        where: types.TaskProposalWhereUniqueInput,
        include: Optional[types.TaskProposalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TaskProposal record.

        Parameters
        ----------
        data
            TaskProposal record data specifying what to update
        where
            TaskProposal filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The updated TaskProposal record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        taskproposal = await TaskProposal.prisma().update(
            where={
                'id': 'dfhaijeie',
            },
            data={
                # data to update the TaskProposal record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TaskProposalWhereUniqueInput,
        data: types.TaskProposalUpsertInput,
        include: Optional[types.TaskProposalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TaskProposal filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TaskProposal model

        Returns
        -------
        prisma.models.TaskProposal
            The created or updated TaskProposal record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        taskproposal = await TaskProposal.prisma().upsert(
            where={
                'id': 'gbcdjgicb',
            },
            data={
                'create': {
                    'id': 'gbcdjgicb',
                    'organizationId': 'bhbjceagbb',
                    'proposedTaskName': 'bjeifffjdg',
                },
                'update': {
                    'organizationId': 'bhbjceagbb',
                    'proposedTaskName': 'bjeifffjdg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TaskProposalUpdateManyMutationInput,
        where: types.TaskProposalWhereInput,
    ) -> int:
        """Update multiple TaskProposal records

        Parameters
        ----------
        data
            TaskProposal data to update the selected TaskProposal records to
        where
            Filter to select the TaskProposal records to update

        Returns
        -------
        int
            The total number of TaskProposal records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TaskProposal records
        total = await TaskProposal.prisma().update_many(
            data={
                'proposedAssignee': Json({'biaibdagac': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TaskProposal records present in the database

        Parameters
        ----------
        select
            Select the TaskProposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TaskProposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaskProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TaskProposal.prisma().count()

        # results: prisma.types.TaskProposalCountAggregateOutput
        results = await TaskProposal.prisma().count(
            select={
                '_all': True,
                'proposedDueDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TaskProposalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
    ) -> types.TaskProposalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TaskProposalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskProposalWhereInput] = None,
        cursor: Optional[types.TaskProposalWhereUniqueInput] = None,
    ) -> Union[int, types.TaskProposalCountAggregateOutput]:
        """Count the number of TaskProposal records present in the database

        Parameters
        ----------
        select
            Select the TaskProposal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TaskProposal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaskProposalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TaskProposal.prisma().count()

        # results: prisma.types.TaskProposalCountAggregateOutput
        results = await TaskProposal.prisma().count(
            select={
                '_all': True,
                'createdTaskId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TaskProposalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TaskProposalWhereInput] = None
    ) -> int:
        """Delete multiple TaskProposal records.

        Parameters
        ----------
        where
            Optional TaskProposal filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TaskProposal records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TaskProposal records
        total = await TaskProposal.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TaskProposalScalarFieldKeys'],
        *,
        where: Optional['types.TaskProposalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TaskProposalAvgAggregateInput'] = None,
        sum: Optional['types.TaskProposalSumAggregateInput'] = None,
        min: Optional['types.TaskProposalMinAggregateInput'] = None,
        max: Optional['types.TaskProposalMaxAggregateInput'] = None,
        having: Optional['types.TaskProposalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TaskProposalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TaskProposalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TaskProposalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TaskProposalGroupByOutput']:
        """Group TaskProposal records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TaskProposal fields to group records by
        where
            TaskProposal filter to select records
        take
            Limit the maximum number of TaskProposal records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TaskProposalGroupByOutput]
            A list of dictionaries representing the TaskProposal record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TaskProposal records by resolvedAs values
        # and count how many records are in each group
        results = await TaskProposal.prisma().group_by(
            ['resolvedAs'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailClassificationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailClassification]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailClassification.prisma().query_raw(
            'SELECT * FROM EmailClassification WHERE id = $1',
            'bbfbheibcd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailClassification
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailClassification.prisma().query_first(
            'SELECT * FROM EmailClassification WHERE emailId = $1',
            'hiagajie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailClassificationCreateInput,
        include: Optional[types.EmailClassificationInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailClassification record.

        Parameters
        ----------
        data
            EmailClassification record data
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The created EmailClassification record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailClassification record from just the required fields
        emailclassification = await EmailClassification.prisma().create(
            data={
                # data to create a EmailClassification record
                'emailId': 'eeejidbif',
                'classificationType': enums.ClassificationType.EXISTING,
                'confidence': 45610742.76908,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailClassificationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailClassification records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailClassification record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailClassification.prisma().create_many(
            data=[
                {
                    # data to create a EmailClassification record
                    'emailId': 'bddefjjabc',
                    'classificationType': enums.ClassificationType.EXISTING,
                    'confidence': 1116761037.117260,
                },
                {
                    # data to create a EmailClassification record
                    'emailId': 'ddaabegbb',
                    'classificationType': enums.ClassificationType.EXISTING,
                    'confidence': 1768156112.7162,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailClassificationWhereUniqueInput,
        include: Optional[types.EmailClassificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailClassification record.

        Parameters
        ----------
        where
            EmailClassification filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The deleted EmailClassification record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailclassification = await EmailClassification.prisma().delete(
            where={
                'id': 'ffhgghde',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailClassificationWhereUniqueInput,
        include: Optional[types.EmailClassificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailClassification record.

        Parameters
        ----------
        where
            EmailClassification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The found EmailClassification record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailclassification = await EmailClassification.prisma().find_unique(
            where={
                'id': 'ibcadcejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailClassificationWhereUniqueInput,
        include: Optional[types.EmailClassificationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailClassification record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailClassification filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The found EmailClassification record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailclassification = await EmailClassification.prisma().find_unique_or_raise(
            where={
                'id': 'bdcdfgccdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
        include: Optional[types.EmailClassificationInclude] = None,
        order: Optional[Union[types.EmailClassificationOrderByInput, List[types.EmailClassificationOrderByInput]]] = None,
        distinct: Optional[List[types.EmailClassificationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailClassification records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailClassification records returned
        skip
            Ignore the first N results
        where
            EmailClassification filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailClassification model
        order
            Order the returned EmailClassification records by any field
        distinct
            Filter EmailClassification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailClassification]
            The list of all EmailClassification records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailClassification records
        emailclassifications = await EmailClassification.prisma().find_many(take=10)

        # find the first 5 EmailClassification records ordered by the classificationType field
        emailclassifications = await EmailClassification.prisma().find_many(
            take=5,
            order={
                'classificationType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
        include: Optional[types.EmailClassificationInclude] = None,
        order: Optional[Union[types.EmailClassificationOrderByInput, List[types.EmailClassificationOrderByInput]]] = None,
        distinct: Optional[List[types.EmailClassificationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailClassification record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailClassification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailClassification model
        order
            Order the returned EmailClassification records by any field
        distinct
            Filter EmailClassification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailClassification
            The first EmailClassification record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailClassification record ordered by the suggestedProjectId field
        emailclassification = await EmailClassification.prisma().find_first(
            skip=1,
            order={
                'suggestedProjectId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
        include: Optional[types.EmailClassificationInclude] = None,
        order: Optional[Union[types.EmailClassificationOrderByInput, List[types.EmailClassificationOrderByInput]]] = None,
        distinct: Optional[List[types.EmailClassificationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailClassification record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailClassification filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailClassification model
        order
            Order the returned EmailClassification records by any field
        distinct
            Filter EmailClassification records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailClassification
            The first EmailClassification record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailClassification record ordered by the suggestedTaskId field
        emailclassification = await EmailClassification.prisma().find_first_or_raise(
            skip=1,
            order={
                'suggestedTaskId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailClassificationUpdateInput,
        where: types.EmailClassificationWhereUniqueInput,
        include: Optional[types.EmailClassificationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailClassification record.

        Parameters
        ----------
        data
            EmailClassification record data specifying what to update
        where
            EmailClassification filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The updated EmailClassification record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailclassification = await EmailClassification.prisma().update(
            where={
                'id': 'edhjgdfh',
            },
            data={
                # data to update the EmailClassification record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailClassificationWhereUniqueInput,
        data: types.EmailClassificationUpsertInput,
        include: Optional[types.EmailClassificationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailClassification filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailClassification model

        Returns
        -------
        prisma.models.EmailClassification
            The created or updated EmailClassification record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailclassification = await EmailClassification.prisma().upsert(
            where={
                'id': 'bdeffdadda',
            },
            data={
                'create': {
                    'id': 'bdeffdadda',
                    'emailId': 'ddaabegbb',
                    'classificationType': enums.ClassificationType.EXISTING,
                    'confidence': 1768156112.7162,
                },
                'update': {
                    'emailId': 'ddaabegbb',
                    'classificationType': enums.ClassificationType.EXISTING,
                    'confidence': 1768156112.7162,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailClassificationUpdateManyMutationInput,
        where: types.EmailClassificationWhereInput,
    ) -> int:
        """Update multiple EmailClassification records

        Parameters
        ----------
        data
            EmailClassification data to update the selected EmailClassification records to
        where
            Filter to select the EmailClassification records to update

        Returns
        -------
        int
            The total number of EmailClassification records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailClassification records
        total = await EmailClassification.prisma().update_many(
            data={
                'suggestedData': Json({'bjgfdihchf': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailClassification records present in the database

        Parameters
        ----------
        select
            Select the EmailClassification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailClassification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailClassificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailClassification.prisma().count()

        # results: prisma.types.EmailClassificationCountAggregateOutput
        results = await EmailClassification.prisma().count(
            select={
                '_all': True,
                'tags': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailClassificationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
    ) -> types.EmailClassificationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailClassificationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailClassificationWhereInput] = None,
        cursor: Optional[types.EmailClassificationWhereUniqueInput] = None,
    ) -> Union[int, types.EmailClassificationCountAggregateOutput]:
        """Count the number of EmailClassification records present in the database

        Parameters
        ----------
        select
            Select the EmailClassification fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailClassification filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailClassificationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailClassification.prisma().count()

        # results: prisma.types.EmailClassificationCountAggregateOutput
        results = await EmailClassification.prisma().count(
            select={
                '_all': True,
                'confidence': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailClassificationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailClassificationWhereInput] = None
    ) -> int:
        """Delete multiple EmailClassification records.

        Parameters
        ----------
        where
            Optional EmailClassification filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailClassification records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailClassification records
        total = await EmailClassification.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailClassificationScalarFieldKeys'],
        *,
        where: Optional['types.EmailClassificationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailClassificationAvgAggregateInput'] = None,
        sum: Optional['types.EmailClassificationSumAggregateInput'] = None,
        min: Optional['types.EmailClassificationMinAggregateInput'] = None,
        max: Optional['types.EmailClassificationMaxAggregateInput'] = None,
        having: Optional['types.EmailClassificationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailClassificationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailClassificationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailClassificationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailClassificationGroupByOutput']:
        """Group EmailClassification records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailClassification fields to group records by
        where
            EmailClassification filter to select records
        take
            Limit the maximum number of EmailClassification records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailClassificationGroupByOutput]
            A list of dictionaries representing the EmailClassification record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailClassification records by reason values
        # and count how many records are in each group
        results = await EmailClassification.prisma().group_by(
            ['reason'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SearchCacheActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SearchCache]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SearchCache.prisma().query_raw(
            'SELECT * FROM SearchCache WHERE id = $1',
            'iaeihdeei',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SearchCache
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SearchCache.prisma().query_first(
            'SELECT * FROM SearchCache WHERE userId = $1',
            'bfggejgfbd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SearchCacheCreateInput,
        include: Optional[types.SearchCacheInclude] = None
    ) -> _PrismaModelT:
        """Create a new SearchCache record.

        Parameters
        ----------
        data
            SearchCache record data
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The created SearchCache record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SearchCache record from just the required fields
        searchcache = await SearchCache.prisma().create(
            data={
                # data to create a SearchCache record
                'userId': 'ifaaaedja',
                'queryHash': 'cbajdjjabf',
                'results': Json({'bcicggedea': True}),
                'expiresAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SearchCacheCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SearchCache records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SearchCache record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SearchCache.prisma().create_many(
            data=[
                {
                    # data to create a SearchCache record
                    'userId': 'cebcdadjh',
                    'queryHash': 'ehfigdgac',
                    'results': Json({'bhbgccijjf': True}),
                    'expiresAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a SearchCache record
                    'userId': 'bigjhdgbjc',
                    'queryHash': 'bfifdebhfd',
                    'results': Json({'cjchbjde': True}),
                    'expiresAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SearchCacheWhereUniqueInput,
        include: Optional[types.SearchCacheInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SearchCache record.

        Parameters
        ----------
        where
            SearchCache filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The deleted SearchCache record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchcache = await SearchCache.prisma().delete(
            where={
                'id': 'bfiibjcehj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SearchCacheWhereUniqueInput,
        include: Optional[types.SearchCacheInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SearchCache record.

        Parameters
        ----------
        where
            SearchCache filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The found SearchCache record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchcache = await SearchCache.prisma().find_unique(
            where={
                'id': 'ijieafghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SearchCacheWhereUniqueInput,
        include: Optional[types.SearchCacheInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SearchCache record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SearchCache filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The found SearchCache record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchcache = await SearchCache.prisma().find_unique_or_raise(
            where={
                'id': 'hhhegahcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
        include: Optional[types.SearchCacheInclude] = None,
        order: Optional[Union[types.SearchCacheOrderByInput, List[types.SearchCacheOrderByInput]]] = None,
        distinct: Optional[List[types.SearchCacheScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SearchCache records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SearchCache records returned
        skip
            Ignore the first N results
        where
            SearchCache filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchCache model
        order
            Order the returned SearchCache records by any field
        distinct
            Filter SearchCache records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SearchCache]
            The list of all SearchCache records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SearchCache records
        searchcaches = await SearchCache.prisma().find_many(take=10)

        # find the first 5 SearchCache records ordered by the queryHash field
        searchcaches = await SearchCache.prisma().find_many(
            take=5,
            order={
                'queryHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
        include: Optional[types.SearchCacheInclude] = None,
        order: Optional[Union[types.SearchCacheOrderByInput, List[types.SearchCacheOrderByInput]]] = None,
        distinct: Optional[List[types.SearchCacheScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SearchCache record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SearchCache filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchCache model
        order
            Order the returned SearchCache records by any field
        distinct
            Filter SearchCache records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SearchCache
            The first SearchCache record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SearchCache record ordered by the results field
        searchcache = await SearchCache.prisma().find_first(
            skip=1,
            order={
                'results': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
        include: Optional[types.SearchCacheInclude] = None,
        order: Optional[Union[types.SearchCacheOrderByInput, List[types.SearchCacheOrderByInput]]] = None,
        distinct: Optional[List[types.SearchCacheScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SearchCache record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SearchCache filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchCache model
        order
            Order the returned SearchCache records by any field
        distinct
            Filter SearchCache records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SearchCache
            The first SearchCache record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SearchCache record ordered by the expiresAt field
        searchcache = await SearchCache.prisma().find_first_or_raise(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SearchCacheUpdateInput,
        where: types.SearchCacheWhereUniqueInput,
        include: Optional[types.SearchCacheInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SearchCache record.

        Parameters
        ----------
        data
            SearchCache record data specifying what to update
        where
            SearchCache filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The updated SearchCache record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        searchcache = await SearchCache.prisma().update(
            where={
                'id': 'edhijefdi',
            },
            data={
                # data to update the SearchCache record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SearchCacheWhereUniqueInput,
        data: types.SearchCacheUpsertInput,
        include: Optional[types.SearchCacheInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SearchCache filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SearchCache model

        Returns
        -------
        prisma.models.SearchCache
            The created or updated SearchCache record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchcache = await SearchCache.prisma().upsert(
            where={
                'id': 'djddecjhb',
            },
            data={
                'create': {
                    'id': 'djddecjhb',
                    'userId': 'bigjhdgbjc',
                    'queryHash': 'bfifdebhfd',
                    'results': Json({'cjchbjde': True}),
                    'expiresAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'userId': 'bigjhdgbjc',
                    'queryHash': 'bfifdebhfd',
                    'results': Json({'cjchbjde': True}),
                    'expiresAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SearchCacheUpdateManyMutationInput,
        where: types.SearchCacheWhereInput,
    ) -> int:
        """Update multiple SearchCache records

        Parameters
        ----------
        data
            SearchCache data to update the selected SearchCache records to
        where
            Filter to select the SearchCache records to update

        Returns
        -------
        int
            The total number of SearchCache records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SearchCache records
        total = await SearchCache.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SearchCache records present in the database

        Parameters
        ----------
        select
            Select the SearchCache fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SearchCache filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SearchCacheCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SearchCache.prisma().count()

        # results: prisma.types.SearchCacheCountAggregateOutput
        results = await SearchCache.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SearchCacheCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
    ) -> types.SearchCacheCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SearchCacheCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchCacheWhereInput] = None,
        cursor: Optional[types.SearchCacheWhereUniqueInput] = None,
    ) -> Union[int, types.SearchCacheCountAggregateOutput]:
        """Count the number of SearchCache records present in the database

        Parameters
        ----------
        select
            Select the SearchCache fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SearchCache filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SearchCacheCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SearchCache.prisma().count()

        # results: prisma.types.SearchCacheCountAggregateOutput
        results = await SearchCache.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SearchCacheCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SearchCacheWhereInput] = None
    ) -> int:
        """Delete multiple SearchCache records.

        Parameters
        ----------
        where
            Optional SearchCache filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SearchCache records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SearchCache records
        total = await SearchCache.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SearchCacheScalarFieldKeys'],
        *,
        where: Optional['types.SearchCacheWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SearchCacheAvgAggregateInput'] = None,
        sum: Optional['types.SearchCacheSumAggregateInput'] = None,
        min: Optional['types.SearchCacheMinAggregateInput'] = None,
        max: Optional['types.SearchCacheMaxAggregateInput'] = None,
        having: Optional['types.SearchCacheScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SearchCacheCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SearchCacheScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SearchCacheScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SearchCacheGroupByOutput']:
        """Group SearchCache records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SearchCache fields to group records by
        where
            SearchCache filter to select records
        take
            Limit the maximum number of SearchCache records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SearchCacheGroupByOutput]
            A list of dictionaries representing the SearchCache record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SearchCache records by queryHash values
        # and count how many records are in each group
        results = await SearchCache.prisma().group_by(
            ['queryHash'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ConversationHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ConversationHistory.prisma().query_raw(
            'SELECT * FROM ConversationHistory WHERE id = $1',
            'bgdicjhie',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ConversationHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ConversationHistory.prisma().query_first(
            'SELECT * FROM ConversationHistory WHERE threadId = $1',
            'ceibfcgij',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ConversationHistoryCreateInput,
        include: Optional[types.ConversationHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new ConversationHistory record.

        Parameters
        ----------
        data
            ConversationHistory record data
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The created ConversationHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ConversationHistory record from just the required fields
        conversationhistory = await ConversationHistory.prisma().create(
            data={
                # data to create a ConversationHistory record
                'threadId': 'debhbfada',
                'messages': 'bgjchggecd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ConversationHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ConversationHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ConversationHistory.prisma().create_many(
            data=[
                {
                    # data to create a ConversationHistory record
                    'threadId': 'igggcfjg',
                    'messages': 'bgjhijffjh',
                },
                {
                    # data to create a ConversationHistory record
                    'threadId': 'bcigdhache',
                    'messages': 'igefhgdhb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationHistoryWhereUniqueInput,
        include: Optional[types.ConversationHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ConversationHistory record.

        Parameters
        ----------
        where
            ConversationHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The deleted ConversationHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationhistory = await ConversationHistory.prisma().delete(
            where={
                'id': 'ejbiifbae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationHistoryWhereUniqueInput,
        include: Optional[types.ConversationHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ConversationHistory record.

        Parameters
        ----------
        where
            ConversationHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The found ConversationHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationhistory = await ConversationHistory.prisma().find_unique(
            where={
                'id': 'djcfgedjd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationHistoryWhereUniqueInput,
        include: Optional[types.ConversationHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ConversationHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ConversationHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The found ConversationHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationhistory = await ConversationHistory.prisma().find_unique_or_raise(
            where={
                'id': 'bdbjcdegag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
        include: Optional[types.ConversationHistoryInclude] = None,
        order: Optional[Union[types.ConversationHistoryOrderByInput, List[types.ConversationHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ConversationHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ConversationHistory records returned
        skip
            Ignore the first N results
        where
            ConversationHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationHistory model
        order
            Order the returned ConversationHistory records by any field
        distinct
            Filter ConversationHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ConversationHistory]
            The list of all ConversationHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ConversationHistory records
        conversationhistorys = await ConversationHistory.prisma().find_many(take=10)

        # find the first 5 ConversationHistory records ordered by the messages field
        conversationhistorys = await ConversationHistory.prisma().find_many(
            take=5,
            order={
                'messages': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
        include: Optional[types.ConversationHistoryInclude] = None,
        order: Optional[Union[types.ConversationHistoryOrderByInput, List[types.ConversationHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ConversationHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationHistory model
        order
            Order the returned ConversationHistory records by any field
        distinct
            Filter ConversationHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationHistory
            The first ConversationHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationHistory record ordered by the createdAt field
        conversationhistory = await ConversationHistory.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
        include: Optional[types.ConversationHistoryInclude] = None,
        order: Optional[Union[types.ConversationHistoryOrderByInput, List[types.ConversationHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ConversationHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ConversationHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ConversationHistory model
        order
            Order the returned ConversationHistory records by any field
        distinct
            Filter ConversationHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ConversationHistory
            The first ConversationHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ConversationHistory record ordered by the updatedAt field
        conversationhistory = await ConversationHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationHistoryUpdateInput,
        where: types.ConversationHistoryWhereUniqueInput,
        include: Optional[types.ConversationHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ConversationHistory record.

        Parameters
        ----------
        data
            ConversationHistory record data specifying what to update
        where
            ConversationHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The updated ConversationHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversationhistory = await ConversationHistory.prisma().update(
            where={
                'id': 'hbchfebch',
            },
            data={
                # data to update the ConversationHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationHistoryWhereUniqueInput,
        data: types.ConversationHistoryUpsertInput,
        include: Optional[types.ConversationHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ConversationHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ConversationHistory model

        Returns
        -------
        prisma.models.ConversationHistory
            The created or updated ConversationHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversationhistory = await ConversationHistory.prisma().upsert(
            where={
                'id': 'bcjjffegfc',
            },
            data={
                'create': {
                    'id': 'bcjjffegfc',
                    'threadId': 'bcigdhache',
                    'messages': 'igefhgdhb',
                },
                'update': {
                    'threadId': 'bcigdhache',
                    'messages': 'igefhgdhb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationHistoryUpdateManyMutationInput,
        where: types.ConversationHistoryWhereInput,
    ) -> int:
        """Update multiple ConversationHistory records

        Parameters
        ----------
        data
            ConversationHistory data to update the selected ConversationHistory records to
        where
            Filter to select the ConversationHistory records to update

        Returns
        -------
        int
            The total number of ConversationHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ConversationHistory records
        total = await ConversationHistory.prisma().update_many(
            data={
                'id': 'cahaeaicjd'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ConversationHistory records present in the database

        Parameters
        ----------
        select
            Select the ConversationHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationHistory.prisma().count()

        # results: prisma.types.ConversationHistoryCountAggregateOutput
        results = await ConversationHistory.prisma().count(
            select={
                '_all': True,
                'threadId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
    ) -> types.ConversationHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationHistoryWhereInput] = None,
        cursor: Optional[types.ConversationHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationHistoryCountAggregateOutput]:
        """Count the number of ConversationHistory records present in the database

        Parameters
        ----------
        select
            Select the ConversationHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ConversationHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ConversationHistory.prisma().count()

        # results: prisma.types.ConversationHistoryCountAggregateOutput
        results = await ConversationHistory.prisma().count(
            select={
                '_all': True,
                'messages': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationHistoryWhereInput] = None
    ) -> int:
        """Delete multiple ConversationHistory records.

        Parameters
        ----------
        where
            Optional ConversationHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ConversationHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ConversationHistory records
        total = await ConversationHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationHistoryScalarFieldKeys'],
        *,
        where: Optional['types.ConversationHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationHistoryAvgAggregateInput'] = None,
        sum: Optional['types.ConversationHistorySumAggregateInput'] = None,
        min: Optional['types.ConversationHistoryMinAggregateInput'] = None,
        max: Optional['types.ConversationHistoryMaxAggregateInput'] = None,
        having: Optional['types.ConversationHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationHistoryGroupByOutput']:
        """Group ConversationHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ConversationHistory fields to group records by
        where
            ConversationHistory filter to select records
        take
            Limit the maximum number of ConversationHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationHistoryGroupByOutput]
            A list of dictionaries representing the ConversationHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ConversationHistory records by createdAt values
        # and count how many records are in each group
        results = await ConversationHistory.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OutboxEventActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OutboxEvent]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OutboxEvent.prisma().query_raw(
            'SELECT * FROM OutboxEvent WHERE id = $1',
            9742802616,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OutboxEvent
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OutboxEvent.prisma().query_first(
            'SELECT * FROM OutboxEvent WHERE topic = $1',
            'djgacbcch',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OutboxEventCreateInput,
        include: Optional[types.OutboxEventInclude] = None
    ) -> _PrismaModelT:
        """Create a new OutboxEvent record.

        Parameters
        ----------
        data
            OutboxEvent record data
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The created OutboxEvent record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OutboxEvent record from just the required fields
        outboxevent = await OutboxEvent.prisma().create(
            data={
                # data to create a OutboxEvent record
                'topic': 'geeeegace',
                'key': 'bbgdigchd',
                'eventType': 'dajcifgdi',
                'payload': Json({'ccedhdbj': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OutboxEventCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OutboxEvent records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OutboxEvent record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OutboxEvent.prisma().create_many(
            data=[
                {
                    # data to create a OutboxEvent record
                    'topic': 'bjaabjjjce',
                    'key': 'cafhdcdcjd',
                    'eventType': 'bdeebbhbdi',
                    'payload': Json({'cafcbdchah': True}),
                },
                {
                    # data to create a OutboxEvent record
                    'topic': 'bdffbehbae',
                    'key': 'ieahjgeb',
                    'eventType': 'hfeeddceg',
                    'payload': Json({'dbecgbbid': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OutboxEventWhereUniqueInput,
        include: Optional[types.OutboxEventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OutboxEvent record.

        Parameters
        ----------
        where
            OutboxEvent filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The deleted OutboxEvent record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outboxevent = await OutboxEvent.prisma().delete(
            where={
                'id': 2732143248,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OutboxEventWhereUniqueInput,
        include: Optional[types.OutboxEventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OutboxEvent record.

        Parameters
        ----------
        where
            OutboxEvent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The found OutboxEvent record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outboxevent = await OutboxEvent.prisma().find_unique(
            where={
                'id': 5087996412,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OutboxEventWhereUniqueInput,
        include: Optional[types.OutboxEventInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OutboxEvent record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OutboxEvent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The found OutboxEvent record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outboxevent = await OutboxEvent.prisma().find_unique_or_raise(
            where={
                'id': 2163305208,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
        include: Optional[types.OutboxEventInclude] = None,
        order: Optional[Union[types.OutboxEventOrderByInput, List[types.OutboxEventOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxEventScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OutboxEvent records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OutboxEvent records returned
        skip
            Ignore the first N results
        where
            OutboxEvent filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OutboxEvent model
        order
            Order the returned OutboxEvent records by any field
        distinct
            Filter OutboxEvent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OutboxEvent]
            The list of all OutboxEvent records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OutboxEvent records
        outboxevents = await OutboxEvent.prisma().find_many(take=10)

        # find the first 5 OutboxEvent records ordered by the key field
        outboxevents = await OutboxEvent.prisma().find_many(
            take=5,
            order={
                'key': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
        include: Optional[types.OutboxEventInclude] = None,
        order: Optional[Union[types.OutboxEventOrderByInput, List[types.OutboxEventOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxEventScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OutboxEvent record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OutboxEvent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OutboxEvent model
        order
            Order the returned OutboxEvent records by any field
        distinct
            Filter OutboxEvent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OutboxEvent
            The first OutboxEvent record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OutboxEvent record ordered by the eventType field
        outboxevent = await OutboxEvent.prisma().find_first(
            skip=1,
            order={
                'eventType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
        include: Optional[types.OutboxEventInclude] = None,
        order: Optional[Union[types.OutboxEventOrderByInput, List[types.OutboxEventOrderByInput]]] = None,
        distinct: Optional[List[types.OutboxEventScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OutboxEvent record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OutboxEvent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OutboxEvent model
        order
            Order the returned OutboxEvent records by any field
        distinct
            Filter OutboxEvent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OutboxEvent
            The first OutboxEvent record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OutboxEvent record ordered by the payload field
        outboxevent = await OutboxEvent.prisma().find_first_or_raise(
            skip=1,
            order={
                'payload': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OutboxEventUpdateInput,
        where: types.OutboxEventWhereUniqueInput,
        include: Optional[types.OutboxEventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OutboxEvent record.

        Parameters
        ----------
        data
            OutboxEvent record data specifying what to update
        where
            OutboxEvent filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The updated OutboxEvent record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        outboxevent = await OutboxEvent.prisma().update(
            where={
                'id': 691297860,
            },
            data={
                # data to update the OutboxEvent record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OutboxEventWhereUniqueInput,
        data: types.OutboxEventUpsertInput,
        include: Optional[types.OutboxEventInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OutboxEvent filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OutboxEvent model

        Returns
        -------
        prisma.models.OutboxEvent
            The created or updated OutboxEvent record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        outboxevent = await OutboxEvent.prisma().upsert(
            where={
                'id': 24370945440,
            },
            data={
                'create': {
                    'id': 24370945440,
                    'topic': 'bdffbehbae',
                    'key': 'ieahjgeb',
                    'eventType': 'hfeeddceg',
                    'payload': Json({'dbecgbbid': True}),
                },
                'update': {
                    'topic': 'bdffbehbae',
                    'key': 'ieahjgeb',
                    'eventType': 'hfeeddceg',
                    'payload': Json({'dbecgbbid': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OutboxEventUpdateManyMutationInput,
        where: types.OutboxEventWhereInput,
    ) -> int:
        """Update multiple OutboxEvent records

        Parameters
        ----------
        data
            OutboxEvent data to update the selected OutboxEvent records to
        where
            Filter to select the OutboxEvent records to update

        Returns
        -------
        int
            The total number of OutboxEvent records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OutboxEvent records
        total = await OutboxEvent.prisma().update_many(
            data={
                'headers': Json({'bjheigfcdd': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OutboxEvent records present in the database

        Parameters
        ----------
        select
            Select the OutboxEvent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OutboxEvent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OutboxEventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OutboxEvent.prisma().count()

        # results: prisma.types.OutboxEventCountAggregateOutput
        results = await OutboxEvent.prisma().count(
            select={
                '_all': True,
                'occurredAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OutboxEventCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
    ) -> types.OutboxEventCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OutboxEventCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OutboxEventWhereInput] = None,
        cursor: Optional[types.OutboxEventWhereUniqueInput] = None,
    ) -> Union[int, types.OutboxEventCountAggregateOutput]:
        """Count the number of OutboxEvent records present in the database

        Parameters
        ----------
        select
            Select the OutboxEvent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OutboxEvent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OutboxEventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OutboxEvent.prisma().count()

        # results: prisma.types.OutboxEventCountAggregateOutput
        results = await OutboxEvent.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OutboxEventCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OutboxEventWhereInput] = None
    ) -> int:
        """Delete multiple OutboxEvent records.

        Parameters
        ----------
        where
            Optional OutboxEvent filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OutboxEvent records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OutboxEvent records
        total = await OutboxEvent.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OutboxEventScalarFieldKeys'],
        *,
        where: Optional['types.OutboxEventWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OutboxEventAvgAggregateInput'] = None,
        sum: Optional['types.OutboxEventSumAggregateInput'] = None,
        min: Optional['types.OutboxEventMinAggregateInput'] = None,
        max: Optional['types.OutboxEventMaxAggregateInput'] = None,
        having: Optional['types.OutboxEventScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OutboxEventCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OutboxEventScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OutboxEventScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OutboxEventGroupByOutput']:
        """Group OutboxEvent records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OutboxEvent fields to group records by
        where
            OutboxEvent filter to select records
        take
            Limit the maximum number of OutboxEvent records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OutboxEventGroupByOutput]
            A list of dictionaries representing the OutboxEvent record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OutboxEvent records by id values
        # and count how many records are in each group
        results = await OutboxEvent.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Organization]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Organization.prisma().query_raw(
            'SELECT * FROM Organization WHERE id = $1',
            'bjejigcdcg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Organization
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Organization.prisma().query_first(
            'SELECT * FROM Organization WHERE clerkOrganizationId = $1',
            'bifiiibcah',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationCreateInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Organization record.

        Parameters
        ----------
        data
            Organization record data
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created Organization record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Organization record from just the required fields
        organization = await Organization.prisma().create(
            data={
                # data to create a Organization record
                'clerkOrganizationId': 'dbjibjdaa',
                'name': 'dgijbdiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Organization records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Organization record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Organization.prisma().create_many(
            data=[
                {
                    # data to create a Organization record
                    'clerkOrganizationId': 'begfaigba',
                    'name': 'bdjiafcgjb',
                },
                {
                    # data to create a Organization record
                    'clerkOrganizationId': 'bficecgcfg',
                    'name': 'cbjjeedcj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Organization record.

        Parameters
        ----------
        where
            Organization filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The deleted Organization record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().delete(
            where={
                'id': 'dedgbbhja',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Organization record.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique(
            where={
                'id': 'cabiahchj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Organization record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Organization filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The found Organization record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().find_unique_or_raise(
            where={
                'id': 'cgbeccfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Organization records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N results
        where
            Organization filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Organization]
            The list of all Organization records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Organization records
        organizations = await Organization.prisma().find_many(take=10)

        # find the first 5 Organization records ordered by the name field
        organizations = await Organization.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Organization record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the description field
        organization = await Organization.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInclude] = None,
        order: Optional[Union[types.OrganizationOrderByInput, List[types.OrganizationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Organization record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Organization filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Organization model
        order
            Order the returned Organization records by any field
        distinct
            Filter Organization records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Organization
            The first Organization record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Organization record ordered by the imageUrl field
        organization = await Organization.prisma().find_first_or_raise(
            skip=1,
            order={
                'imageUrl': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationUpdateInput,
        where: types.OrganizationWhereUniqueInput,
        include: Optional[types.OrganizationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Organization record.

        Parameters
        ----------
        data
            Organization record data specifying what to update
        where
            Organization filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The updated Organization record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organization = await Organization.prisma().update(
            where={
                'id': 'fcjcagef',
            },
            data={
                # data to update the Organization record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationWhereUniqueInput,
        data: types.OrganizationUpsertInput,
        include: Optional[types.OrganizationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Organization filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Organization model

        Returns
        -------
        prisma.models.Organization
            The created or updated Organization record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organization = await Organization.prisma().upsert(
            where={
                'id': 'bgdhaeacic',
            },
            data={
                'create': {
                    'id': 'bgdhaeacic',
                    'clerkOrganizationId': 'bficecgcfg',
                    'name': 'cbjjeedcj',
                },
                'update': {
                    'clerkOrganizationId': 'bficecgcfg',
                    'name': 'cbjjeedcj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationUpdateManyMutationInput,
        where: types.OrganizationWhereInput,
    ) -> int:
        """Update multiple Organization records

        Parameters
        ----------
        data
            Organization data to update the selected Organization records to
        where
            Filter to select the Organization records to update

        Returns
        -------
        int
            The total number of Organization records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Organization records
        total = await Organization.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> types.OrganizationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationWhereInput] = None,
        cursor: Optional[types.OrganizationWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationCountAggregateOutput]:
        """Count the number of Organization records present in the database

        Parameters
        ----------
        select
            Select the Organization fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Organization filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Organization.prisma().count()

        # results: prisma.types.OrganizationCountAggregateOutput
        results = await Organization.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationWhereInput] = None
    ) -> int:
        """Delete multiple Organization records.

        Parameters
        ----------
        where
            Optional Organization filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Organization records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Organization records
        total = await Organization.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationSumAggregateInput'] = None,
        min: Optional['types.OrganizationMinAggregateInput'] = None,
        max: Optional['types.OrganizationMaxAggregateInput'] = None,
        having: Optional['types.OrganizationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationGroupByOutput']:
        """Group Organization records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Organization fields to group records by
        where
            Organization filter to select records
        take
            Limit the maximum number of Organization records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationGroupByOutput]
            A list of dictionaries representing the Organization record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Organization records by clerkOrganizationId values
        # and count how many records are in each group
        results = await Organization.prisma().group_by(
            ['clerkOrganizationId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrganizationMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrganizationMember.prisma().query_raw(
            'SELECT * FROM OrganizationMember WHERE id = $1',
            'caffafcheh',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrganizationMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrganizationMember.prisma().query_first(
            'SELECT * FROM OrganizationMember WHERE clerkMembershipId = $1',
            'fjjbegge',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationMemberCreateInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrganizationMember record.

        Parameters
        ----------
        data
            OrganizationMember record data
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The created OrganizationMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrganizationMember record from just the required fields
        organizationmember = await OrganizationMember.prisma().create(
            data={
                # data to create a OrganizationMember record
                'clerkMembershipId': 'bdiifhbieb',
                'organizationId': 'cdcaejhgg',
                'userId': 'jbijgfbfj',
                'role': enums.OrganizationRole.ADMIN,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrganizationMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrganizationMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrganizationMember.prisma().create_many(
            data=[
                {
                    # data to create a OrganizationMember record
                    'clerkMembershipId': 'ggfbeddia',
                    'organizationId': 'djjejdaj',
                    'userId': 'bjabbfceji',
                    'role': enums.OrganizationRole.ADMIN,
                },
                {
                    # data to create a OrganizationMember record
                    'clerkMembershipId': 'bgchfbjibb',
                    'organizationId': 'bajecchdjc',
                    'userId': 'dfgacajif',
                    'role': enums.OrganizationRole.ADMIN,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrganizationMember record.

        Parameters
        ----------
        where
            OrganizationMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The deleted OrganizationMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().delete(
            where={
                'id': 'bgdiddfadi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrganizationMember record.

        Parameters
        ----------
        where
            OrganizationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The found OrganizationMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().find_unique(
            where={
                'id': 'bijbfghhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrganizationMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrganizationMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The found OrganizationMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().find_unique_or_raise(
            where={
                'id': 'bahchhihdc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrganizationMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrganizationMember records returned
        skip
            Ignore the first N results
        where
            OrganizationMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrganizationMember]
            The list of all OrganizationMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrganizationMember records
        organizationmembers = await OrganizationMember.prisma().find_many(take=10)

        # find the first 5 OrganizationMember records ordered by the organizationId field
        organizationmembers = await OrganizationMember.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrganizationMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationMember
            The first OrganizationMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationMember record ordered by the userId field
        organizationmember = await OrganizationMember.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
        include: Optional[types.OrganizationMemberInclude] = None,
        order: Optional[Union[types.OrganizationMemberOrderByInput, List[types.OrganizationMemberOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrganizationMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationMember model
        order
            Order the returned OrganizationMember records by any field
        distinct
            Filter OrganizationMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationMember
            The first OrganizationMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationMember record ordered by the role field
        organizationmember = await OrganizationMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationMemberUpdateInput,
        where: types.OrganizationMemberWhereUniqueInput,
        include: Optional[types.OrganizationMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrganizationMember record.

        Parameters
        ----------
        data
            OrganizationMember record data specifying what to update
        where
            OrganizationMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The updated OrganizationMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().update(
            where={
                'id': 'bihjdcibib',
            },
            data={
                # data to update the OrganizationMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationMemberWhereUniqueInput,
        data: types.OrganizationMemberUpsertInput,
        include: Optional[types.OrganizationMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrganizationMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrganizationMember model

        Returns
        -------
        prisma.models.OrganizationMember
            The created or updated OrganizationMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationmember = await OrganizationMember.prisma().upsert(
            where={
                'id': 'bfhhjbbdha',
            },
            data={
                'create': {
                    'id': 'bfhhjbbdha',
                    'clerkMembershipId': 'bgchfbjibb',
                    'organizationId': 'bajecchdjc',
                    'userId': 'dfgacajif',
                    'role': enums.OrganizationRole.ADMIN,
                },
                'update': {
                    'clerkMembershipId': 'bgchfbjibb',
                    'organizationId': 'bajecchdjc',
                    'userId': 'dfgacajif',
                    'role': enums.OrganizationRole.ADMIN,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationMemberUpdateManyMutationInput,
        where: types.OrganizationMemberWhereInput,
    ) -> int:
        """Update multiple OrganizationMember records

        Parameters
        ----------
        data
            OrganizationMember data to update the selected OrganizationMember records to
        where
            Filter to select the OrganizationMember records to update

        Returns
        -------
        int
            The total number of OrganizationMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrganizationMember records
        total = await OrganizationMember.prisma().update_many(
            data={
                'assignmentRules': ['faehcjfdb']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrganizationMember records present in the database

        Parameters
        ----------
        select
            Select the OrganizationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationMember.prisma().count()

        # results: prisma.types.OrganizationMemberCountAggregateOutput
        results = await OrganizationMember.prisma().count(
            select={
                '_all': True,
                'joinedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> types.OrganizationMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationMemberWhereInput] = None,
        cursor: Optional[types.OrganizationMemberWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationMemberCountAggregateOutput]:
        """Count the number of OrganizationMember records present in the database

        Parameters
        ----------
        select
            Select the OrganizationMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationMember.prisma().count()

        # results: prisma.types.OrganizationMemberCountAggregateOutput
        results = await OrganizationMember.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationMemberWhereInput] = None
    ) -> int:
        """Delete multiple OrganizationMember records.

        Parameters
        ----------
        where
            Optional OrganizationMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrganizationMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrganizationMember records
        total = await OrganizationMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationMemberScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationMemberAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationMemberSumAggregateInput'] = None,
        min: Optional['types.OrganizationMemberMinAggregateInput'] = None,
        max: Optional['types.OrganizationMemberMaxAggregateInput'] = None,
        having: Optional['types.OrganizationMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationMemberGroupByOutput']:
        """Group OrganizationMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrganizationMember fields to group records by
        where
            OrganizationMember filter to select records
        take
            Limit the maximum number of OrganizationMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationMemberGroupByOutput]
            A list of dictionaries representing the OrganizationMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrganizationMember records by updatedAt values
        # and count how many records are in each group
        results = await OrganizationMember.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OrganizationInvitationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.OrganizationInvitation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await OrganizationInvitation.prisma().query_raw(
            'SELECT * FROM OrganizationInvitation WHERE id = $1',
            'bbaiefbee',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.OrganizationInvitation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await OrganizationInvitation.prisma().query_first(
            'SELECT * FROM OrganizationInvitation WHERE clerkInvitationId = $1',
            'bdaacgjbaf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OrganizationInvitationCreateInput,
        include: Optional[types.OrganizationInvitationInclude] = None
    ) -> _PrismaModelT:
        """Create a new OrganizationInvitation record.

        Parameters
        ----------
        data
            OrganizationInvitation record data
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The created OrganizationInvitation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a OrganizationInvitation record from just the required fields
        organizationinvitation = await OrganizationInvitation.prisma().create(
            data={
                # data to create a OrganizationInvitation record
                'clerkInvitationId': 'biibaighec',
                'organizationId': 'baicdfeidj',
                'email': 'befgiciadg',
                'role': enums.OrganizationRole.ADMIN,
                'invitedBy': 'cbcehahedh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OrganizationInvitationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple OrganizationInvitation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of OrganizationInvitation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await OrganizationInvitation.prisma().create_many(
            data=[
                {
                    # data to create a OrganizationInvitation record
                    'clerkInvitationId': 'bcjihiaide',
                    'organizationId': 'bagfijcgfj',
                    'email': 'bcggehiidc',
                    'role': enums.OrganizationRole.ADMIN,
                    'invitedBy': 'bjcdacgacf',
                },
                {
                    # data to create a OrganizationInvitation record
                    'clerkInvitationId': 'jfieeahi',
                    'organizationId': 'bijfjbddfj',
                    'email': 'cdcdjdcee',
                    'role': enums.OrganizationRole.ADMIN,
                    'invitedBy': 'bbbgjdbgcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OrganizationInvitationWhereUniqueInput,
        include: Optional[types.OrganizationInvitationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single OrganizationInvitation record.

        Parameters
        ----------
        where
            OrganizationInvitation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The deleted OrganizationInvitation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationinvitation = await OrganizationInvitation.prisma().delete(
            where={
                'id': 'bcedacgecg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OrganizationInvitationWhereUniqueInput,
        include: Optional[types.OrganizationInvitationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique OrganizationInvitation record.

        Parameters
        ----------
        where
            OrganizationInvitation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The found OrganizationInvitation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationinvitation = await OrganizationInvitation.prisma().find_unique(
            where={
                'id': 'cbdffjeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OrganizationInvitationWhereUniqueInput,
        include: Optional[types.OrganizationInvitationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique OrganizationInvitation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            OrganizationInvitation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The found OrganizationInvitation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationinvitation = await OrganizationInvitation.prisma().find_unique_or_raise(
            where={
                'id': 'idbcdhbci',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInvitationInclude] = None,
        order: Optional[Union[types.OrganizationInvitationOrderByInput, List[types.OrganizationInvitationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationInvitationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple OrganizationInvitation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of OrganizationInvitation records returned
        skip
            Ignore the first N results
        where
            OrganizationInvitation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model
        order
            Order the returned OrganizationInvitation records by any field
        distinct
            Filter OrganizationInvitation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.OrganizationInvitation]
            The list of all OrganizationInvitation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 OrganizationInvitation records
        organizationinvitations = await OrganizationInvitation.prisma().find_many(take=10)

        # find the first 5 OrganizationInvitation records ordered by the organizationId field
        organizationinvitations = await OrganizationInvitation.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInvitationInclude] = None,
        order: Optional[Union[types.OrganizationInvitationOrderByInput, List[types.OrganizationInvitationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationInvitationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single OrganizationInvitation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationInvitation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model
        order
            Order the returned OrganizationInvitation records by any field
        distinct
            Filter OrganizationInvitation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationInvitation
            The first OrganizationInvitation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationInvitation record ordered by the email field
        organizationinvitation = await OrganizationInvitation.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
        include: Optional[types.OrganizationInvitationInclude] = None,
        order: Optional[Union[types.OrganizationInvitationOrderByInput, List[types.OrganizationInvitationOrderByInput]]] = None,
        distinct: Optional[List[types.OrganizationInvitationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single OrganizationInvitation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            OrganizationInvitation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model
        order
            Order the returned OrganizationInvitation records by any field
        distinct
            Filter OrganizationInvitation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.OrganizationInvitation
            The first OrganizationInvitation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second OrganizationInvitation record ordered by the role field
        organizationinvitation = await OrganizationInvitation.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OrganizationInvitationUpdateInput,
        where: types.OrganizationInvitationWhereUniqueInput,
        include: Optional[types.OrganizationInvitationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single OrganizationInvitation record.

        Parameters
        ----------
        data
            OrganizationInvitation record data specifying what to update
        where
            OrganizationInvitation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The updated OrganizationInvitation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        organizationinvitation = await OrganizationInvitation.prisma().update(
            where={
                'id': 'bacegehahd',
            },
            data={
                # data to update the OrganizationInvitation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OrganizationInvitationWhereUniqueInput,
        data: types.OrganizationInvitationUpsertInput,
        include: Optional[types.OrganizationInvitationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            OrganizationInvitation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned OrganizationInvitation model

        Returns
        -------
        prisma.models.OrganizationInvitation
            The created or updated OrganizationInvitation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        organizationinvitation = await OrganizationInvitation.prisma().upsert(
            where={
                'id': 'ebedeihec',
            },
            data={
                'create': {
                    'id': 'ebedeihec',
                    'clerkInvitationId': 'jfieeahi',
                    'organizationId': 'bijfjbddfj',
                    'email': 'cdcdjdcee',
                    'role': enums.OrganizationRole.ADMIN,
                    'invitedBy': 'bbbgjdbgcb',
                },
                'update': {
                    'clerkInvitationId': 'jfieeahi',
                    'organizationId': 'bijfjbddfj',
                    'email': 'cdcdjdcee',
                    'role': enums.OrganizationRole.ADMIN,
                    'invitedBy': 'bbbgjdbgcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OrganizationInvitationUpdateManyMutationInput,
        where: types.OrganizationInvitationWhereInput,
    ) -> int:
        """Update multiple OrganizationInvitation records

        Parameters
        ----------
        data
            OrganizationInvitation data to update the selected OrganizationInvitation records to
        where
            Filter to select the OrganizationInvitation records to update

        Returns
        -------
        int
            The total number of OrganizationInvitation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all OrganizationInvitation records
        total = await OrganizationInvitation.prisma().update_many(
            data={
                'status': enums.InvitationStatus.PENDING
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of OrganizationInvitation records present in the database

        Parameters
        ----------
        select
            Select the OrganizationInvitation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationInvitation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationInvitationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationInvitation.prisma().count()

        # results: prisma.types.OrganizationInvitationCountAggregateOutput
        results = await OrganizationInvitation.prisma().count(
            select={
                '_all': True,
                'invitedBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OrganizationInvitationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
    ) -> types.OrganizationInvitationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OrganizationInvitationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OrganizationInvitationWhereInput] = None,
        cursor: Optional[types.OrganizationInvitationWhereUniqueInput] = None,
    ) -> Union[int, types.OrganizationInvitationCountAggregateOutput]:
        """Count the number of OrganizationInvitation records present in the database

        Parameters
        ----------
        select
            Select the OrganizationInvitation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            OrganizationInvitation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OrganizationInvitationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await OrganizationInvitation.prisma().count()

        # results: prisma.types.OrganizationInvitationCountAggregateOutput
        results = await OrganizationInvitation.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OrganizationInvitationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OrganizationInvitationWhereInput] = None
    ) -> int:
        """Delete multiple OrganizationInvitation records.

        Parameters
        ----------
        where
            Optional OrganizationInvitation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of OrganizationInvitation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all OrganizationInvitation records
        total = await OrganizationInvitation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OrganizationInvitationScalarFieldKeys'],
        *,
        where: Optional['types.OrganizationInvitationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OrganizationInvitationAvgAggregateInput'] = None,
        sum: Optional['types.OrganizationInvitationSumAggregateInput'] = None,
        min: Optional['types.OrganizationInvitationMinAggregateInput'] = None,
        max: Optional['types.OrganizationInvitationMaxAggregateInput'] = None,
        having: Optional['types.OrganizationInvitationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OrganizationInvitationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OrganizationInvitationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OrganizationInvitationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OrganizationInvitationGroupByOutput']:
        """Group OrganizationInvitation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar OrganizationInvitation fields to group records by
        where
            OrganizationInvitation filter to select records
        take
            Limit the maximum number of OrganizationInvitation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OrganizationInvitationGroupByOutput]
            A list of dictionaries representing the OrganizationInvitation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group OrganizationInvitation records by expiresAt values
        # and count how many records are in each group
        results = await OrganizationInvitation.prisma().group_by(
            ['expiresAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Project]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Project.prisma().query_raw(
            'SELECT * FROM Project WHERE id = $1',
            'bajagjdfbb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Project
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Project.prisma().query_first(
            'SELECT * FROM Project WHERE organizationId = $1',
            'bggedbjggi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectCreateInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Create a new Project record.

        Parameters
        ----------
        data
            Project record data
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created Project record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Project record from just the required fields
        project = await Project.prisma().create(
            data={
                # data to create a Project record
                'organizationId': 'hgbafifcf',
                'name': 'bejiecfecg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Project records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Project record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Project.prisma().create_many(
            data=[
                {
                    # data to create a Project record
                    'organizationId': 'bjgacaeagh',
                    'name': 'beeaihbefg',
                },
                {
                    # data to create a Project record
                    'organizationId': 'bfbfgeddfd',
                    'name': 'jbgheibja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Project record.

        Parameters
        ----------
        where
            Project filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The deleted Project record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().delete(
            where={
                'id': 'eejajbid',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Project record.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique(
            where={
                'id': 'efhdcdaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Project record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Project filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The found Project record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().find_unique_or_raise(
            where={
                'id': 'cadejecgbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Project records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N results
        where
            Project filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Project]
            The list of all Project records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Project records
        projects = await Project.prisma().find_many(take=10)

        # find the first 5 Project records ordered by the name field
        projects = await Project.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Project record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the description field
        project = await Project.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
        include: Optional[types.ProjectInclude] = None,
        order: Optional[Union[types.ProjectOrderByInput, List[types.ProjectOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Project record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Project filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Project model
        order
            Order the returned Project records by any field
        distinct
            Filter Project records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Project
            The first Project record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Project record ordered by the status field
        project = await Project.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectUpdateInput,
        where: types.ProjectWhereUniqueInput,
        include: Optional[types.ProjectInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Project record.

        Parameters
        ----------
        data
            Project record data specifying what to update
        where
            Project filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The updated Project record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        project = await Project.prisma().update(
            where={
                'id': 'bahjhjjhcc',
            },
            data={
                # data to update the Project record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectWhereUniqueInput,
        data: types.ProjectUpsertInput,
        include: Optional[types.ProjectInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Project filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Project model

        Returns
        -------
        prisma.models.Project
            The created or updated Project record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        project = await Project.prisma().upsert(
            where={
                'id': 'ebhbhbdff',
            },
            data={
                'create': {
                    'id': 'ebhbhbdff',
                    'organizationId': 'bfbfgeddfd',
                    'name': 'jbgheibja',
                },
                'update': {
                    'organizationId': 'bfbfgeddfd',
                    'name': 'jbgheibja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectUpdateManyMutationInput,
        where: types.ProjectWhereInput,
    ) -> int:
        """Update multiple Project records

        Parameters
        ----------
        data
            Project data to update the selected Project records to
        where
            Filter to select the Project records to update

        Returns
        -------
        int
            The total number of Project records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Project records
        total = await Project.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> types.ProjectCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectWhereInput] = None,
        cursor: Optional[types.ProjectWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectCountAggregateOutput]:
        """Count the number of Project records present in the database

        Parameters
        ----------
        select
            Select the Project fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Project filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Project.prisma().count()

        # results: prisma.types.ProjectCountAggregateOutput
        results = await Project.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectWhereInput] = None
    ) -> int:
        """Delete multiple Project records.

        Parameters
        ----------
        where
            Optional Project filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Project records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Project records
        total = await Project.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectScalarFieldKeys'],
        *,
        where: Optional['types.ProjectWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectAvgAggregateInput'] = None,
        sum: Optional['types.ProjectSumAggregateInput'] = None,
        min: Optional['types.ProjectMinAggregateInput'] = None,
        max: Optional['types.ProjectMaxAggregateInput'] = None,
        having: Optional['types.ProjectScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectGroupByOutput']:
        """Group Project records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Project fields to group records by
        where
            Project filter to select records
        take
            Limit the maximum number of Project records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectGroupByOutput]
            A list of dictionaries representing the Project record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Project records by organizationId values
        # and count how many records are in each group
        results = await Project.prisma().group_by(
            ['organizationId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectTagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectTag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectTag.prisma().query_raw(
            'SELECT * FROM ProjectTag WHERE id = $1',
            'bdiefcdfhg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectTag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectTag.prisma().query_first(
            'SELECT * FROM ProjectTag WHERE projectId = $1',
            'cheifeghd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectTagCreateInput,
        include: Optional[types.ProjectTagInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectTag record.

        Parameters
        ----------
        data
            ProjectTag record data
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The created ProjectTag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectTag record from just the required fields
        projecttag = await ProjectTag.prisma().create(
            data={
                # data to create a ProjectTag record
                'projectId': 'fgijheefe',
                'name': 'hcbgbhfch',
                'type': enums.ProjectTagType.COMPANY,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectTagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectTag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectTag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectTag.prisma().create_many(
            data=[
                {
                    # data to create a ProjectTag record
                    'projectId': 'bfbbbgbfhc',
                    'name': 'ibijjdeb',
                    'type': enums.ProjectTagType.COMPANY,
                },
                {
                    # data to create a ProjectTag record
                    'projectId': 'caehiccddi',
                    'name': 'bgcahjbafj',
                    'type': enums.ProjectTagType.COMPANY,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectTagWhereUniqueInput,
        include: Optional[types.ProjectTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectTag record.

        Parameters
        ----------
        where
            ProjectTag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The deleted ProjectTag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projecttag = await ProjectTag.prisma().delete(
            where={
                'id': 'bihhgeihca',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectTagWhereUniqueInput,
        include: Optional[types.ProjectTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectTag record.

        Parameters
        ----------
        where
            ProjectTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The found ProjectTag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projecttag = await ProjectTag.prisma().find_unique(
            where={
                'id': 'bdgbfahbef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectTagWhereUniqueInput,
        include: Optional[types.ProjectTagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectTag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The found ProjectTag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projecttag = await ProjectTag.prisma().find_unique_or_raise(
            where={
                'id': 'fccjhidic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
        include: Optional[types.ProjectTagInclude] = None,
        order: Optional[Union[types.ProjectTagOrderByInput, List[types.ProjectTagOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectTagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectTag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectTag records returned
        skip
            Ignore the first N results
        where
            ProjectTag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectTag model
        order
            Order the returned ProjectTag records by any field
        distinct
            Filter ProjectTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectTag]
            The list of all ProjectTag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectTag records
        projecttags = await ProjectTag.prisma().find_many(take=10)

        # find the first 5 ProjectTag records ordered by the name field
        projecttags = await ProjectTag.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
        include: Optional[types.ProjectTagInclude] = None,
        order: Optional[Union[types.ProjectTagOrderByInput, List[types.ProjectTagOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectTagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectTag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectTag model
        order
            Order the returned ProjectTag records by any field
        distinct
            Filter ProjectTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectTag
            The first ProjectTag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectTag record ordered by the type field
        projecttag = await ProjectTag.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
        include: Optional[types.ProjectTagInclude] = None,
        order: Optional[Union[types.ProjectTagOrderByInput, List[types.ProjectTagOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectTagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectTag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectTag model
        order
            Order the returned ProjectTag records by any field
        distinct
            Filter ProjectTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectTag
            The first ProjectTag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectTag record ordered by the sourceId field
        projecttag = await ProjectTag.prisma().find_first_or_raise(
            skip=1,
            order={
                'sourceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectTagUpdateInput,
        where: types.ProjectTagWhereUniqueInput,
        include: Optional[types.ProjectTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectTag record.

        Parameters
        ----------
        data
            ProjectTag record data specifying what to update
        where
            ProjectTag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The updated ProjectTag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projecttag = await ProjectTag.prisma().update(
            where={
                'id': 'bdgfdgdaff',
            },
            data={
                # data to update the ProjectTag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectTagWhereUniqueInput,
        data: types.ProjectTagUpsertInput,
        include: Optional[types.ProjectTagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectTag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectTag model

        Returns
        -------
        prisma.models.ProjectTag
            The created or updated ProjectTag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projecttag = await ProjectTag.prisma().upsert(
            where={
                'id': 'bicgeaiaga',
            },
            data={
                'create': {
                    'id': 'bicgeaiaga',
                    'projectId': 'caehiccddi',
                    'name': 'bgcahjbafj',
                    'type': enums.ProjectTagType.COMPANY,
                },
                'update': {
                    'projectId': 'caehiccddi',
                    'name': 'bgcahjbafj',
                    'type': enums.ProjectTagType.COMPANY,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectTagUpdateManyMutationInput,
        where: types.ProjectTagWhereInput,
    ) -> int:
        """Update multiple ProjectTag records

        Parameters
        ----------
        data
            ProjectTag data to update the selected ProjectTag records to
        where
            Filter to select the ProjectTag records to update

        Returns
        -------
        int
            The total number of ProjectTag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectTag records
        total = await ProjectTag.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectTag records present in the database

        Parameters
        ----------
        select
            Select the ProjectTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectTag.prisma().count()

        # results: prisma.types.ProjectTagCountAggregateOutput
        results = await ProjectTag.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectTagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
    ) -> types.ProjectTagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectTagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectTagWhereInput] = None,
        cursor: Optional[types.ProjectTagWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectTagCountAggregateOutput]:
        """Count the number of ProjectTag records present in the database

        Parameters
        ----------
        select
            Select the ProjectTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectTag.prisma().count()

        # results: prisma.types.ProjectTagCountAggregateOutput
        results = await ProjectTag.prisma().count(
            select={
                '_all': True,
                'projectId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectTagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectTagWhereInput] = None
    ) -> int:
        """Delete multiple ProjectTag records.

        Parameters
        ----------
        where
            Optional ProjectTag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectTag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectTag records
        total = await ProjectTag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectTagScalarFieldKeys'],
        *,
        where: Optional['types.ProjectTagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectTagAvgAggregateInput'] = None,
        sum: Optional['types.ProjectTagSumAggregateInput'] = None,
        min: Optional['types.ProjectTagMinAggregateInput'] = None,
        max: Optional['types.ProjectTagMaxAggregateInput'] = None,
        having: Optional['types.ProjectTagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectTagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectTagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectTagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectTagGroupByOutput']:
        """Group ProjectTag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectTag fields to group records by
        where
            ProjectTag filter to select records
        take
            Limit the maximum number of ProjectTag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectTagGroupByOutput]
            A list of dictionaries representing the ProjectTag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectTag records by name values
        # and count how many records are in each group
        results = await ProjectTag.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectMember.prisma().query_raw(
            'SELECT * FROM ProjectMember WHERE id = $1',
            'fajhhafab',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectMember.prisma().query_first(
            'SELECT * FROM ProjectMember WHERE projectId = $1',
            'bfeiccieec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectMemberCreateInput,
        include: Optional[types.ProjectMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectMember record.

        Parameters
        ----------
        data
            ProjectMember record data
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The created ProjectMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectMember record from just the required fields
        projectmember = await ProjectMember.prisma().create(
            data={
                # data to create a ProjectMember record
                'projectId': 'hciegiihf',
                'userId': 'bahifjfga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectMember.prisma().create_many(
            data=[
                {
                    # data to create a ProjectMember record
                    'projectId': 'baebfehjaf',
                    'userId': 'bjchdacjfa',
                },
                {
                    # data to create a ProjectMember record
                    'projectId': 'fcadcaihb',
                    'userId': 'bbdcibggga',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectMemberWhereUniqueInput,
        include: Optional[types.ProjectMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectMember record.

        Parameters
        ----------
        where
            ProjectMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The deleted ProjectMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectmember = await ProjectMember.prisma().delete(
            where={
                'id': 'bagbibfheb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectMemberWhereUniqueInput,
        include: Optional[types.ProjectMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectMember record.

        Parameters
        ----------
        where
            ProjectMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The found ProjectMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectmember = await ProjectMember.prisma().find_unique(
            where={
                'id': 'bidgcabjag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectMemberWhereUniqueInput,
        include: Optional[types.ProjectMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The found ProjectMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectmember = await ProjectMember.prisma().find_unique_or_raise(
            where={
                'id': 'hechjdjih',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
        include: Optional[types.ProjectMemberInclude] = None,
        order: Optional[Union[types.ProjectMemberOrderByInput, List[types.ProjectMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectMember records returned
        skip
            Ignore the first N results
        where
            ProjectMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectMember model
        order
            Order the returned ProjectMember records by any field
        distinct
            Filter ProjectMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectMember]
            The list of all ProjectMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectMember records
        projectmembers = await ProjectMember.prisma().find_many(take=10)

        # find the first 5 ProjectMember records ordered by the userId field
        projectmembers = await ProjectMember.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
        include: Optional[types.ProjectMemberInclude] = None,
        order: Optional[Union[types.ProjectMemberOrderByInput, List[types.ProjectMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectMember model
        order
            Order the returned ProjectMember records by any field
        distinct
            Filter ProjectMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectMember
            The first ProjectMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectMember record ordered by the role field
        projectmember = await ProjectMember.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
        include: Optional[types.ProjectMemberInclude] = None,
        order: Optional[Union[types.ProjectMemberOrderByInput, List[types.ProjectMemberOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectMember model
        order
            Order the returned ProjectMember records by any field
        distinct
            Filter ProjectMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectMember
            The first ProjectMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectMember record ordered by the joinedAt field
        projectmember = await ProjectMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'joinedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectMemberUpdateInput,
        where: types.ProjectMemberWhereUniqueInput,
        include: Optional[types.ProjectMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectMember record.

        Parameters
        ----------
        data
            ProjectMember record data specifying what to update
        where
            ProjectMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The updated ProjectMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectmember = await ProjectMember.prisma().update(
            where={
                'id': 'cgfjefhci',
            },
            data={
                # data to update the ProjectMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectMemberWhereUniqueInput,
        data: types.ProjectMemberUpsertInput,
        include: Optional[types.ProjectMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectMember model

        Returns
        -------
        prisma.models.ProjectMember
            The created or updated ProjectMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectmember = await ProjectMember.prisma().upsert(
            where={
                'id': 'egcidbiab',
            },
            data={
                'create': {
                    'id': 'egcidbiab',
                    'projectId': 'fcadcaihb',
                    'userId': 'bbdcibggga',
                },
                'update': {
                    'projectId': 'fcadcaihb',
                    'userId': 'bbdcibggga',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectMemberUpdateManyMutationInput,
        where: types.ProjectMemberWhereInput,
    ) -> int:
        """Update multiple ProjectMember records

        Parameters
        ----------
        data
            ProjectMember data to update the selected ProjectMember records to
        where
            Filter to select the ProjectMember records to update

        Returns
        -------
        int
            The total number of ProjectMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectMember records
        total = await ProjectMember.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectMember records present in the database

        Parameters
        ----------
        select
            Select the ProjectMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectMember.prisma().count()

        # results: prisma.types.ProjectMemberCountAggregateOutput
        results = await ProjectMember.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
    ) -> types.ProjectMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectMemberWhereInput] = None,
        cursor: Optional[types.ProjectMemberWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectMemberCountAggregateOutput]:
        """Count the number of ProjectMember records present in the database

        Parameters
        ----------
        select
            Select the ProjectMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectMember.prisma().count()

        # results: prisma.types.ProjectMemberCountAggregateOutput
        results = await ProjectMember.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectMemberWhereInput] = None
    ) -> int:
        """Delete multiple ProjectMember records.

        Parameters
        ----------
        where
            Optional ProjectMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectMember records
        total = await ProjectMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectMemberScalarFieldKeys'],
        *,
        where: Optional['types.ProjectMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectMemberAvgAggregateInput'] = None,
        sum: Optional['types.ProjectMemberSumAggregateInput'] = None,
        min: Optional['types.ProjectMemberMinAggregateInput'] = None,
        max: Optional['types.ProjectMemberMaxAggregateInput'] = None,
        having: Optional['types.ProjectMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectMemberGroupByOutput']:
        """Group ProjectMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectMember fields to group records by
        where
            ProjectMember filter to select records
        take
            Limit the maximum number of ProjectMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectMemberGroupByOutput]
            A list of dictionaries representing the ProjectMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectMember records by projectId values
        # and count how many records are in each group
        results = await ProjectMember.prisma().group_by(
            ['projectId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TaskActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Task]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Task.prisma().query_raw(
            'SELECT * FROM Task WHERE id = $1',
            'cehjjfgeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Task
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Task.prisma().query_first(
            'SELECT * FROM Task WHERE projectId = $1',
            'hiaaaeeeh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TaskCreateInput,
        include: Optional[types.TaskInclude] = None
    ) -> _PrismaModelT:
        """Create a new Task record.

        Parameters
        ----------
        data
            Task record data
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The created Task record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Task record from just the required fields
        task = await Task.prisma().create(
            data={
                # data to create a Task record
                'projectId': 'ediajdeie',
                'title': 'jdgefgafd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TaskCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Task records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Task record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Task.prisma().create_many(
            data=[
                {
                    # data to create a Task record
                    'projectId': 'bhhihbfeac',
                    'title': 'bajegedfhj',
                },
                {
                    # data to create a Task record
                    'projectId': 'bhfjihjfhg',
                    'title': 'iicaadeeb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TaskWhereUniqueInput,
        include: Optional[types.TaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Task record.

        Parameters
        ----------
        where
            Task filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The deleted Task record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await Task.prisma().delete(
            where={
                'id': 'bigjggdhac',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TaskWhereUniqueInput,
        include: Optional[types.TaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Task record.

        Parameters
        ----------
        where
            Task filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The found Task record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await Task.prisma().find_unique(
            where={
                'id': 'bfdbbbjhad',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TaskWhereUniqueInput,
        include: Optional[types.TaskInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Task record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Task filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The found Task record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await Task.prisma().find_unique_or_raise(
            where={
                'id': 'bdibjhdici',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
        include: Optional[types.TaskInclude] = None,
        order: Optional[Union[types.TaskOrderByInput, List[types.TaskOrderByInput]]] = None,
        distinct: Optional[List[types.TaskScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Task records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Task records returned
        skip
            Ignore the first N results
        where
            Task filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Task model
        order
            Order the returned Task records by any field
        distinct
            Filter Task records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Task]
            The list of all Task records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Task records
        tasks = await Task.prisma().find_many(take=10)

        # find the first 5 Task records ordered by the title field
        tasks = await Task.prisma().find_many(
            take=5,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
        include: Optional[types.TaskInclude] = None,
        order: Optional[Union[types.TaskOrderByInput, List[types.TaskOrderByInput]]] = None,
        distinct: Optional[List[types.TaskScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Task record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Task filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Task model
        order
            Order the returned Task records by any field
        distinct
            Filter Task records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Task
            The first Task record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Task record ordered by the description field
        task = await Task.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
        include: Optional[types.TaskInclude] = None,
        order: Optional[Union[types.TaskOrderByInput, List[types.TaskOrderByInput]]] = None,
        distinct: Optional[List[types.TaskScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Task record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Task filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Task model
        order
            Order the returned Task records by any field
        distinct
            Filter Task records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Task
            The first Task record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Task record ordered by the status field
        task = await Task.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TaskUpdateInput,
        where: types.TaskWhereUniqueInput,
        include: Optional[types.TaskInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Task record.

        Parameters
        ----------
        data
            Task record data specifying what to update
        where
            Task filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The updated Task record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        task = await Task.prisma().update(
            where={
                'id': 'bceigehcbd',
            },
            data={
                # data to update the Task record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TaskWhereUniqueInput,
        data: types.TaskUpsertInput,
        include: Optional[types.TaskInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Task filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Task model

        Returns
        -------
        prisma.models.Task
            The created or updated Task record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        task = await Task.prisma().upsert(
            where={
                'id': 'caehahihfe',
            },
            data={
                'create': {
                    'id': 'caehahihfe',
                    'projectId': 'bhfjihjfhg',
                    'title': 'iicaadeeb',
                },
                'update': {
                    'projectId': 'bhfjihjfhg',
                    'title': 'iicaadeeb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TaskUpdateManyMutationInput,
        where: types.TaskWhereInput,
    ) -> int:
        """Update multiple Task records

        Parameters
        ----------
        data
            Task data to update the selected Task records to
        where
            Filter to select the Task records to update

        Returns
        -------
        int
            The total number of Task records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Task records
        total = await Task.prisma().update_many(
            data={
                'assigneeId': 'jjacdhech'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Task records present in the database

        Parameters
        ----------
        select
            Select the Task fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Task filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Task.prisma().count()

        # results: prisma.types.TaskCountAggregateOutput
        results = await Task.prisma().count(
            select={
                '_all': True,
                'dueDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TaskCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
    ) -> types.TaskCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TaskCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TaskWhereInput] = None,
        cursor: Optional[types.TaskWhereUniqueInput] = None,
    ) -> Union[int, types.TaskCountAggregateOutput]:
        """Count the number of Task records present in the database

        Parameters
        ----------
        select
            Select the Task fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Task filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TaskCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Task.prisma().count()

        # results: prisma.types.TaskCountAggregateOutput
        results = await Task.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TaskCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TaskWhereInput] = None
    ) -> int:
        """Delete multiple Task records.

        Parameters
        ----------
        where
            Optional Task filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Task records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Task records
        total = await Task.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TaskScalarFieldKeys'],
        *,
        where: Optional['types.TaskWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TaskAvgAggregateInput'] = None,
        sum: Optional['types.TaskSumAggregateInput'] = None,
        min: Optional['types.TaskMinAggregateInput'] = None,
        max: Optional['types.TaskMaxAggregateInput'] = None,
        having: Optional['types.TaskScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TaskCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TaskScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TaskScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TaskGroupByOutput']:
        """Group Task records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Task fields to group records by
        where
            Task filter to select records
        take
            Limit the maximum number of Task records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TaskGroupByOutput]
            A list of dictionaries representing the Task record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Task records by updatedAt values
        # and count how many records are in each group
        results = await Task.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectCompanyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectCompany]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectCompany.prisma().query_raw(
            'SELECT * FROM ProjectCompany WHERE id = $1',
            'bbbjadabjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectCompany
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectCompany.prisma().query_first(
            'SELECT * FROM ProjectCompany WHERE projectId = $1',
            'hhaechedd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectCompanyCreateInput,
        include: Optional[types.ProjectCompanyInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectCompany record.

        Parameters
        ----------
        data
            ProjectCompany record data
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The created ProjectCompany record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectCompany record from just the required fields
        projectcompany = await ProjectCompany.prisma().create(
            data={
                # data to create a ProjectCompany record
                'projectId': 'gjjgegdic',
                'companyId': 'bijbiccd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectCompanyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectCompany records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectCompany record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectCompany.prisma().create_many(
            data=[
                {
                    # data to create a ProjectCompany record
                    'projectId': 'cbaagdieci',
                    'companyId': 'jchifaegj',
                },
                {
                    # data to create a ProjectCompany record
                    'projectId': 'dhhdhfebi',
                    'companyId': 'decchddih',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectCompanyWhereUniqueInput,
        include: Optional[types.ProjectCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectCompany record.

        Parameters
        ----------
        where
            ProjectCompany filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The deleted ProjectCompany record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcompany = await ProjectCompany.prisma().delete(
            where={
                'id': 'bbegbdehci',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectCompanyWhereUniqueInput,
        include: Optional[types.ProjectCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectCompany record.

        Parameters
        ----------
        where
            ProjectCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The found ProjectCompany record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcompany = await ProjectCompany.prisma().find_unique(
            where={
                'id': 'bcebgbhhgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectCompanyWhereUniqueInput,
        include: Optional[types.ProjectCompanyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectCompany record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectCompany filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The found ProjectCompany record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcompany = await ProjectCompany.prisma().find_unique_or_raise(
            where={
                'id': 'ghegfaceg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
        include: Optional[types.ProjectCompanyInclude] = None,
        order: Optional[Union[types.ProjectCompanyOrderByInput, List[types.ProjectCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectCompanyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectCompany records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectCompany records returned
        skip
            Ignore the first N results
        where
            ProjectCompany filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectCompany model
        order
            Order the returned ProjectCompany records by any field
        distinct
            Filter ProjectCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectCompany]
            The list of all ProjectCompany records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectCompany records
        projectcompanys = await ProjectCompany.prisma().find_many(take=10)

        # find the first 5 ProjectCompany records ordered by the companyId field
        projectcompanys = await ProjectCompany.prisma().find_many(
            take=5,
            order={
                'companyId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
        include: Optional[types.ProjectCompanyInclude] = None,
        order: Optional[Union[types.ProjectCompanyOrderByInput, List[types.ProjectCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectCompanyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectCompany record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectCompany model
        order
            Order the returned ProjectCompany records by any field
        distinct
            Filter ProjectCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectCompany
            The first ProjectCompany record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectCompany record ordered by the createdAt field
        projectcompany = await ProjectCompany.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
        include: Optional[types.ProjectCompanyInclude] = None,
        order: Optional[Union[types.ProjectCompanyOrderByInput, List[types.ProjectCompanyOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectCompanyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectCompany record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectCompany filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectCompany model
        order
            Order the returned ProjectCompany records by any field
        distinct
            Filter ProjectCompany records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectCompany
            The first ProjectCompany record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectCompany record ordered by the id field
        projectcompany = await ProjectCompany.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectCompanyUpdateInput,
        where: types.ProjectCompanyWhereUniqueInput,
        include: Optional[types.ProjectCompanyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectCompany record.

        Parameters
        ----------
        data
            ProjectCompany record data specifying what to update
        where
            ProjectCompany filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The updated ProjectCompany record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectcompany = await ProjectCompany.prisma().update(
            where={
                'id': 'hdeaejgah',
            },
            data={
                # data to update the ProjectCompany record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectCompanyWhereUniqueInput,
        data: types.ProjectCompanyUpsertInput,
        include: Optional[types.ProjectCompanyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectCompany filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectCompany model

        Returns
        -------
        prisma.models.ProjectCompany
            The created or updated ProjectCompany record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcompany = await ProjectCompany.prisma().upsert(
            where={
                'id': 'ddiiihaci',
            },
            data={
                'create': {
                    'id': 'ddiiihaci',
                    'projectId': 'dhhdhfebi',
                    'companyId': 'decchddih',
                },
                'update': {
                    'projectId': 'dhhdhfebi',
                    'companyId': 'decchddih',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectCompanyUpdateManyMutationInput,
        where: types.ProjectCompanyWhereInput,
    ) -> int:
        """Update multiple ProjectCompany records

        Parameters
        ----------
        data
            ProjectCompany data to update the selected ProjectCompany records to
        where
            Filter to select the ProjectCompany records to update

        Returns
        -------
        int
            The total number of ProjectCompany records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectCompany records
        total = await ProjectCompany.prisma().update_many(
            data={
                'projectId': 'jdhfacdgf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectCompany records present in the database

        Parameters
        ----------
        select
            Select the ProjectCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectCompany.prisma().count()

        # results: prisma.types.ProjectCompanyCountAggregateOutput
        results = await ProjectCompany.prisma().count(
            select={
                '_all': True,
                'companyId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectCompanyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
    ) -> types.ProjectCompanyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectCompanyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectCompanyWhereInput] = None,
        cursor: Optional[types.ProjectCompanyWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectCompanyCountAggregateOutput]:
        """Count the number of ProjectCompany records present in the database

        Parameters
        ----------
        select
            Select the ProjectCompany fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectCompany filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectCompanyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectCompany.prisma().count()

        # results: prisma.types.ProjectCompanyCountAggregateOutput
        results = await ProjectCompany.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectCompanyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectCompanyWhereInput] = None
    ) -> int:
        """Delete multiple ProjectCompany records.

        Parameters
        ----------
        where
            Optional ProjectCompany filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectCompany records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectCompany records
        total = await ProjectCompany.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectCompanyScalarFieldKeys'],
        *,
        where: Optional['types.ProjectCompanyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectCompanyAvgAggregateInput'] = None,
        sum: Optional['types.ProjectCompanySumAggregateInput'] = None,
        min: Optional['types.ProjectCompanyMinAggregateInput'] = None,
        max: Optional['types.ProjectCompanyMaxAggregateInput'] = None,
        having: Optional['types.ProjectCompanyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectCompanyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectCompanyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectCompanyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectCompanyGroupByOutput']:
        """Group ProjectCompany records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectCompany fields to group records by
        where
            ProjectCompany filter to select records
        take
            Limit the maximum number of ProjectCompany records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectCompanyGroupByOutput]
            A list of dictionaries representing the ProjectCompany record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectCompany records by id values
        # and count how many records are in each group
        results = await ProjectCompany.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectContactActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectContact]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectContact.prisma().query_raw(
            'SELECT * FROM ProjectContact WHERE id = $1',
            'fcbbahcbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectContact
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectContact.prisma().query_first(
            'SELECT * FROM ProjectContact WHERE projectId = $1',
            'edcgchech',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectContactCreateInput,
        include: Optional[types.ProjectContactInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectContact record.

        Parameters
        ----------
        data
            ProjectContact record data
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The created ProjectContact record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectContact record from just the required fields
        projectcontact = await ProjectContact.prisma().create(
            data={
                # data to create a ProjectContact record
                'projectId': 'bfehccdcge',
                'contactId': 'ehcibdegf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectContactCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectContact records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectContact record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectContact.prisma().create_many(
            data=[
                {
                    # data to create a ProjectContact record
                    'projectId': 'ebhjifbbi',
                    'contactId': 'jaigficdj',
                },
                {
                    # data to create a ProjectContact record
                    'projectId': 'bggcfifgbc',
                    'contactId': 'bhidfjibgf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectContactWhereUniqueInput,
        include: Optional[types.ProjectContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectContact record.

        Parameters
        ----------
        where
            ProjectContact filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The deleted ProjectContact record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcontact = await ProjectContact.prisma().delete(
            where={
                'id': 'fcgdaijha',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectContactWhereUniqueInput,
        include: Optional[types.ProjectContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectContact record.

        Parameters
        ----------
        where
            ProjectContact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The found ProjectContact record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcontact = await ProjectContact.prisma().find_unique(
            where={
                'id': 'bbgfajah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectContactWhereUniqueInput,
        include: Optional[types.ProjectContactInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectContact record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectContact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The found ProjectContact record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcontact = await ProjectContact.prisma().find_unique_or_raise(
            where={
                'id': 'bbaecgicia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
        include: Optional[types.ProjectContactInclude] = None,
        order: Optional[Union[types.ProjectContactOrderByInput, List[types.ProjectContactOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectContactScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectContact records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectContact records returned
        skip
            Ignore the first N results
        where
            ProjectContact filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectContact model
        order
            Order the returned ProjectContact records by any field
        distinct
            Filter ProjectContact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectContact]
            The list of all ProjectContact records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectContact records
        projectcontacts = await ProjectContact.prisma().find_many(take=10)

        # find the first 5 ProjectContact records ordered by the contactId field
        projectcontacts = await ProjectContact.prisma().find_many(
            take=5,
            order={
                'contactId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
        include: Optional[types.ProjectContactInclude] = None,
        order: Optional[Union[types.ProjectContactOrderByInput, List[types.ProjectContactOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectContactScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectContact record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectContact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectContact model
        order
            Order the returned ProjectContact records by any field
        distinct
            Filter ProjectContact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectContact
            The first ProjectContact record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectContact record ordered by the createdAt field
        projectcontact = await ProjectContact.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
        include: Optional[types.ProjectContactInclude] = None,
        order: Optional[Union[types.ProjectContactOrderByInput, List[types.ProjectContactOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectContactScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectContact record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectContact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectContact model
        order
            Order the returned ProjectContact records by any field
        distinct
            Filter ProjectContact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectContact
            The first ProjectContact record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectContact record ordered by the id field
        projectcontact = await ProjectContact.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectContactUpdateInput,
        where: types.ProjectContactWhereUniqueInput,
        include: Optional[types.ProjectContactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectContact record.

        Parameters
        ----------
        data
            ProjectContact record data specifying what to update
        where
            ProjectContact filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The updated ProjectContact record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectcontact = await ProjectContact.prisma().update(
            where={
                'id': 'hedacahfd',
            },
            data={
                # data to update the ProjectContact record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectContactWhereUniqueInput,
        data: types.ProjectContactUpsertInput,
        include: Optional[types.ProjectContactInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectContact filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectContact model

        Returns
        -------
        prisma.models.ProjectContact
            The created or updated ProjectContact record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectcontact = await ProjectContact.prisma().upsert(
            where={
                'id': 'bhgjecjac',
            },
            data={
                'create': {
                    'id': 'bhgjecjac',
                    'projectId': 'bggcfifgbc',
                    'contactId': 'bhidfjibgf',
                },
                'update': {
                    'projectId': 'bggcfifgbc',
                    'contactId': 'bhidfjibgf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectContactUpdateManyMutationInput,
        where: types.ProjectContactWhereInput,
    ) -> int:
        """Update multiple ProjectContact records

        Parameters
        ----------
        data
            ProjectContact data to update the selected ProjectContact records to
        where
            Filter to select the ProjectContact records to update

        Returns
        -------
        int
            The total number of ProjectContact records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectContact records
        total = await ProjectContact.prisma().update_many(
            data={
                'projectId': 'bfbdieidhf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectContact records present in the database

        Parameters
        ----------
        select
            Select the ProjectContact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectContact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectContact.prisma().count()

        # results: prisma.types.ProjectContactCountAggregateOutput
        results = await ProjectContact.prisma().count(
            select={
                '_all': True,
                'contactId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectContactCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
    ) -> types.ProjectContactCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectContactCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectContactWhereInput] = None,
        cursor: Optional[types.ProjectContactWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectContactCountAggregateOutput]:
        """Count the number of ProjectContact records present in the database

        Parameters
        ----------
        select
            Select the ProjectContact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectContact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectContactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectContact.prisma().count()

        # results: prisma.types.ProjectContactCountAggregateOutput
        results = await ProjectContact.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectContactCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectContactWhereInput] = None
    ) -> int:
        """Delete multiple ProjectContact records.

        Parameters
        ----------
        where
            Optional ProjectContact filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectContact records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectContact records
        total = await ProjectContact.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectContactScalarFieldKeys'],
        *,
        where: Optional['types.ProjectContactWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectContactAvgAggregateInput'] = None,
        sum: Optional['types.ProjectContactSumAggregateInput'] = None,
        min: Optional['types.ProjectContactMinAggregateInput'] = None,
        max: Optional['types.ProjectContactMaxAggregateInput'] = None,
        having: Optional['types.ProjectContactScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectContactCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectContactScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectContactScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectContactGroupByOutput']:
        """Group ProjectContact records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectContact fields to group records by
        where
            ProjectContact filter to select records
        take
            Limit the maximum number of ProjectContact records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectContactGroupByOutput]
            A list of dictionaries representing the ProjectContact record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectContact records by id values
        # and count how many records are in each group
        results = await ProjectContact.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Document]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Document.prisma().query_raw(
            'SELECT * FROM Document WHERE id = $1',
            'ffjbdcfia',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Document
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Document.prisma().query_first(
            'SELECT * FROM Document WHERE name = $1',
            'hfeidjicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DocumentCreateInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Document record.

        Parameters
        ----------
        data
            Document record data
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created Document record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Document record from just the required fields
        document = await Document.prisma().create(
            data={
                # data to create a Document record
                'name': 'bbfbdccdag',
                'type': 'biggefaged',
                'size': 653140496,
                'source': enums.DocumentSource.UPLOAD,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Document records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Document record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Document.prisma().create_many(
            data=[
                {
                    # data to create a Document record
                    'name': 'bhacdebcb',
                    'type': 'jhffeibhe',
                    'size': 808844591,
                    'source': enums.DocumentSource.UPLOAD,
                },
                {
                    # data to create a Document record
                    'name': 'jjhjdgjfg',
                    'type': 'bhhjcfadhd',
                    'size': 51490330,
                    'source': enums.DocumentSource.UPLOAD,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Document record.

        Parameters
        ----------
        where
            Document filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The deleted Document record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().delete(
            where={
                'id': 'bjeaigeddb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Document record.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique(
            where={
                'id': 'eceecabdg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Document record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Document filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The found Document record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().find_unique_or_raise(
            where={
                'id': 'bdgaajbcab',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Document records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N results
        where
            Document filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Document]
            The list of all Document records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Document records
        documents = await Document.prisma().find_many(take=10)

        # find the first 5 Document records ordered by the type field
        documents = await Document.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Document record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the size field
        document = await Document.prisma().find_first(
            skip=1,
            order={
                'size': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
        include: Optional[types.DocumentInclude] = None,
        order: Optional[Union[types.DocumentOrderByInput, List[types.DocumentOrderByInput]]] = None,
        distinct: Optional[List[types.DocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Document record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Document filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Document model
        order
            Order the returned Document records by any field
        distinct
            Filter Document records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Document
            The first Document record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Document record ordered by the url field
        document = await Document.prisma().find_first_or_raise(
            skip=1,
            order={
                'url': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DocumentUpdateInput,
        where: types.DocumentWhereUniqueInput,
        include: Optional[types.DocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Document record.

        Parameters
        ----------
        data
            Document record data specifying what to update
        where
            Document filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The updated Document record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        document = await Document.prisma().update(
            where={
                'id': 'chhgehieg',
            },
            data={
                # data to update the Document record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DocumentWhereUniqueInput,
        data: types.DocumentUpsertInput,
        include: Optional[types.DocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Document filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Document model

        Returns
        -------
        prisma.models.Document
            The created or updated Document record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        document = await Document.prisma().upsert(
            where={
                'id': 'faggbiggd',
            },
            data={
                'create': {
                    'id': 'faggbiggd',
                    'name': 'jjhjdgjfg',
                    'type': 'bhhjcfadhd',
                    'size': 51490330,
                    'source': enums.DocumentSource.UPLOAD,
                },
                'update': {
                    'name': 'jjhjdgjfg',
                    'type': 'bhhjcfadhd',
                    'size': 51490330,
                    'source': enums.DocumentSource.UPLOAD,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DocumentUpdateManyMutationInput,
        where: types.DocumentWhereInput,
    ) -> int:
        """Update multiple Document records

        Parameters
        ----------
        data
            Document data to update the selected Document records to
        where
            Filter to select the Document records to update

        Returns
        -------
        int
            The total number of Document records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Document records
        total = await Document.prisma().update_many(
            data={
                'source': enums.DocumentSource.UPLOAD
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'uploadedBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> types.DocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DocumentWhereInput] = None,
        cursor: Optional[types.DocumentWhereUniqueInput] = None,
    ) -> Union[int, types.DocumentCountAggregateOutput]:
        """Count the number of Document records present in the database

        Parameters
        ----------
        select
            Select the Document fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Document filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Document.prisma().count()

        # results: prisma.types.DocumentCountAggregateOutput
        results = await Document.prisma().count(
            select={
                '_all': True,
                'emailAttachmentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DocumentWhereInput] = None
    ) -> int:
        """Delete multiple Document records.

        Parameters
        ----------
        where
            Optional Document filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Document records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Document records
        total = await Document.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DocumentScalarFieldKeys'],
        *,
        where: Optional['types.DocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DocumentAvgAggregateInput'] = None,
        sum: Optional['types.DocumentSumAggregateInput'] = None,
        min: Optional['types.DocumentMinAggregateInput'] = None,
        max: Optional['types.DocumentMaxAggregateInput'] = None,
        having: Optional['types.DocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DocumentGroupByOutput']:
        """Group Document records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Document fields to group records by
        where
            Document filter to select records
        take
            Limit the maximum number of Document records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DocumentGroupByOutput]
            A list of dictionaries representing the Document record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Document records by aiImportance values
        # and count how many records are in each group
        results = await Document.prisma().group_by(
            ['aiImportance'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProjectDocumentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProjectDocument]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProjectDocument.prisma().query_raw(
            'SELECT * FROM ProjectDocument WHERE id = $1',
            'bciijiajei',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProjectDocument
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProjectDocument.prisma().query_first(
            'SELECT * FROM ProjectDocument WHERE projectId = $1',
            'bdjaadchgf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProjectDocumentCreateInput,
        include: Optional[types.ProjectDocumentInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProjectDocument record.

        Parameters
        ----------
        data
            ProjectDocument record data
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The created ProjectDocument record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProjectDocument record from just the required fields
        projectdocument = await ProjectDocument.prisma().create(
            data={
                # data to create a ProjectDocument record
                'projectId': 'biadfeebhi',
                'documentId': 'biajdcaged',
                'linkedBy': 'ddgjjicai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProjectDocumentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProjectDocument records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProjectDocument record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProjectDocument.prisma().create_many(
            data=[
                {
                    # data to create a ProjectDocument record
                    'projectId': 'efihdjdcb',
                    'documentId': 'bdeacajaig',
                    'linkedBy': 'jddggchfb',
                },
                {
                    # data to create a ProjectDocument record
                    'projectId': 'bccbfcfdfg',
                    'documentId': 'bjchjgjib',
                    'linkedBy': 'ibiaaifcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProjectDocumentWhereUniqueInput,
        include: Optional[types.ProjectDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProjectDocument record.

        Parameters
        ----------
        where
            ProjectDocument filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The deleted ProjectDocument record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectdocument = await ProjectDocument.prisma().delete(
            where={
                'id': 'bffejbbadf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProjectDocumentWhereUniqueInput,
        include: Optional[types.ProjectDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProjectDocument record.

        Parameters
        ----------
        where
            ProjectDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The found ProjectDocument record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectdocument = await ProjectDocument.prisma().find_unique(
            where={
                'id': 'bajgjiebfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProjectDocumentWhereUniqueInput,
        include: Optional[types.ProjectDocumentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProjectDocument record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProjectDocument filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The found ProjectDocument record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectdocument = await ProjectDocument.prisma().find_unique_or_raise(
            where={
                'id': 'bhahahadif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
        include: Optional[types.ProjectDocumentInclude] = None,
        order: Optional[Union[types.ProjectDocumentOrderByInput, List[types.ProjectDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectDocumentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProjectDocument records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProjectDocument records returned
        skip
            Ignore the first N results
        where
            ProjectDocument filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectDocument model
        order
            Order the returned ProjectDocument records by any field
        distinct
            Filter ProjectDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProjectDocument]
            The list of all ProjectDocument records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProjectDocument records
        projectdocuments = await ProjectDocument.prisma().find_many(take=10)

        # find the first 5 ProjectDocument records ordered by the documentId field
        projectdocuments = await ProjectDocument.prisma().find_many(
            take=5,
            order={
                'documentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
        include: Optional[types.ProjectDocumentInclude] = None,
        order: Optional[Union[types.ProjectDocumentOrderByInput, List[types.ProjectDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectDocumentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProjectDocument record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectDocument model
        order
            Order the returned ProjectDocument records by any field
        distinct
            Filter ProjectDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectDocument
            The first ProjectDocument record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectDocument record ordered by the linkedAt field
        projectdocument = await ProjectDocument.prisma().find_first(
            skip=1,
            order={
                'linkedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
        include: Optional[types.ProjectDocumentInclude] = None,
        order: Optional[Union[types.ProjectDocumentOrderByInput, List[types.ProjectDocumentOrderByInput]]] = None,
        distinct: Optional[List[types.ProjectDocumentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProjectDocument record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProjectDocument filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProjectDocument model
        order
            Order the returned ProjectDocument records by any field
        distinct
            Filter ProjectDocument records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProjectDocument
            The first ProjectDocument record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProjectDocument record ordered by the linkedBy field
        projectdocument = await ProjectDocument.prisma().find_first_or_raise(
            skip=1,
            order={
                'linkedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProjectDocumentUpdateInput,
        where: types.ProjectDocumentWhereUniqueInput,
        include: Optional[types.ProjectDocumentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProjectDocument record.

        Parameters
        ----------
        data
            ProjectDocument record data specifying what to update
        where
            ProjectDocument filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The updated ProjectDocument record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        projectdocument = await ProjectDocument.prisma().update(
            where={
                'id': 'bijhaihbcg',
            },
            data={
                # data to update the ProjectDocument record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProjectDocumentWhereUniqueInput,
        data: types.ProjectDocumentUpsertInput,
        include: Optional[types.ProjectDocumentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProjectDocument filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProjectDocument model

        Returns
        -------
        prisma.models.ProjectDocument
            The created or updated ProjectDocument record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        projectdocument = await ProjectDocument.prisma().upsert(
            where={
                'id': 'cbgcjeecd',
            },
            data={
                'create': {
                    'id': 'cbgcjeecd',
                    'projectId': 'bccbfcfdfg',
                    'documentId': 'bjchjgjib',
                    'linkedBy': 'ibiaaifcc',
                },
                'update': {
                    'projectId': 'bccbfcfdfg',
                    'documentId': 'bjchjgjib',
                    'linkedBy': 'ibiaaifcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProjectDocumentUpdateManyMutationInput,
        where: types.ProjectDocumentWhereInput,
    ) -> int:
        """Update multiple ProjectDocument records

        Parameters
        ----------
        data
            ProjectDocument data to update the selected ProjectDocument records to
        where
            Filter to select the ProjectDocument records to update

        Returns
        -------
        int
            The total number of ProjectDocument records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProjectDocument records
        total = await ProjectDocument.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProjectDocument records present in the database

        Parameters
        ----------
        select
            Select the ProjectDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectDocument.prisma().count()

        # results: prisma.types.ProjectDocumentCountAggregateOutput
        results = await ProjectDocument.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProjectDocumentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
    ) -> types.ProjectDocumentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProjectDocumentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProjectDocumentWhereInput] = None,
        cursor: Optional[types.ProjectDocumentWhereUniqueInput] = None,
    ) -> Union[int, types.ProjectDocumentCountAggregateOutput]:
        """Count the number of ProjectDocument records present in the database

        Parameters
        ----------
        select
            Select the ProjectDocument fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProjectDocument filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProjectDocumentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProjectDocument.prisma().count()

        # results: prisma.types.ProjectDocumentCountAggregateOutput
        results = await ProjectDocument.prisma().count(
            select={
                '_all': True,
                'projectId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProjectDocumentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProjectDocumentWhereInput] = None
    ) -> int:
        """Delete multiple ProjectDocument records.

        Parameters
        ----------
        where
            Optional ProjectDocument filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProjectDocument records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProjectDocument records
        total = await ProjectDocument.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProjectDocumentScalarFieldKeys'],
        *,
        where: Optional['types.ProjectDocumentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProjectDocumentAvgAggregateInput'] = None,
        sum: Optional['types.ProjectDocumentSumAggregateInput'] = None,
        min: Optional['types.ProjectDocumentMinAggregateInput'] = None,
        max: Optional['types.ProjectDocumentMaxAggregateInput'] = None,
        having: Optional['types.ProjectDocumentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProjectDocumentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProjectDocumentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProjectDocumentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProjectDocumentGroupByOutput']:
        """Group ProjectDocument records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProjectDocument fields to group records by
        where
            ProjectDocument filter to select records
        take
            Limit the maximum number of ProjectDocument records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProjectDocumentGroupByOutput]
            A list of dictionaries representing the ProjectDocument record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProjectDocument records by documentId values
        # and count how many records are in each group
        results = await ProjectDocument.prisma().group_by(
            ['documentId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            'bebibighfg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE userId = $1',
            'bbhjeejidh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'userId': 'bfgebdfefi',
                'action': 'jgijgagjb',
                'context': 'biagjfcfga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'userId': 'bggbhejccf',
                    'action': 'ichjgigcc',
                    'context': 'bhiiegaibf',
                },
                {
                    # data to create a AuditLog record
                    'userId': 'bdegidheae',
                    'action': 'bddbbjidhd',
                    'context': 'jefedjaji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 'eicbgeabb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 'fchjhjjbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'bagfajdjcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the clerkId field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'clerkId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the action field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the context field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'context': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 'bddhgfeaig',
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 'bfgchaiff',
            },
            data={
                'create': {
                    'id': 'bfgchaiff',
                    'userId': 'bdegidheae',
                    'action': 'bddbbjidhd',
                    'context': 'jefedjaji',
                },
                'update': {
                    'userId': 'bdegidheae',
                    'action': 'bddbbjidhd',
                    'context': 'jefedjaji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'targetData': Json({'cifcjfbfg': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by id values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AgentFileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AgentFile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AgentFile.prisma().query_raw(
            'SELECT * FROM AgentFile WHERE id = $1',
            'bdcjigjhd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AgentFile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AgentFile.prisma().query_first(
            'SELECT * FROM AgentFile WHERE userId = $1',
            'bfefdahgac',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgentFileCreateInput,
        include: Optional[types.AgentFileInclude] = None
    ) -> _PrismaModelT:
        """Create a new AgentFile record.

        Parameters
        ----------
        data
            AgentFile record data
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The created AgentFile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AgentFile record from just the required fields
        agentfile = await AgentFile.prisma().create(
            data={
                # data to create a AgentFile record
                'userId': 'bichcieged',
                'filename': 'caijedigce',
                'mimeType': 'bebebdfbcj',
                'size': 2055744798,
                'url': 'hfdidadjj',
                'blobKey': 'bcdiiadeae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgentFileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AgentFile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AgentFile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AgentFile.prisma().create_many(
            data=[
                {
                    # data to create a AgentFile record
                    'userId': 'bdhhaeiaif',
                    'filename': 'caffgabefa',
                    'mimeType': 'bjjajgjbbf',
                    'size': 934293688,
                    'url': 'bcgbcdjjfd',
                    'blobKey': 'bicgfdhjhe',
                },
                {
                    # data to create a AgentFile record
                    'userId': 'ihfjdgceh',
                    'filename': 'gdaedbiee',
                    'mimeType': 'bibdbbffjh',
                    'size': 1395459970,
                    'url': 'bjcjfbafeh',
                    'blobKey': 'bchgjchgjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgentFileWhereUniqueInput,
        include: Optional[types.AgentFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AgentFile record.

        Parameters
        ----------
        where
            AgentFile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The deleted AgentFile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentfile = await AgentFile.prisma().delete(
            where={
                'id': 'idgcdejfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgentFileWhereUniqueInput,
        include: Optional[types.AgentFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AgentFile record.

        Parameters
        ----------
        where
            AgentFile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The found AgentFile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentfile = await AgentFile.prisma().find_unique(
            where={
                'id': 'baajcgbaag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgentFileWhereUniqueInput,
        include: Optional[types.AgentFileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AgentFile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AgentFile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The found AgentFile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentfile = await AgentFile.prisma().find_unique_or_raise(
            where={
                'id': 'eahbafhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
        include: Optional[types.AgentFileInclude] = None,
        order: Optional[Union[types.AgentFileOrderByInput, List[types.AgentFileOrderByInput]]] = None,
        distinct: Optional[List[types.AgentFileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AgentFile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AgentFile records returned
        skip
            Ignore the first N results
        where
            AgentFile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentFile model
        order
            Order the returned AgentFile records by any field
        distinct
            Filter AgentFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AgentFile]
            The list of all AgentFile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AgentFile records
        agentfiles = await AgentFile.prisma().find_many(take=10)

        # find the first 5 AgentFile records ordered by the organizationId field
        agentfiles = await AgentFile.prisma().find_many(
            take=5,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
        include: Optional[types.AgentFileInclude] = None,
        order: Optional[Union[types.AgentFileOrderByInput, List[types.AgentFileOrderByInput]]] = None,
        distinct: Optional[List[types.AgentFileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AgentFile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgentFile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentFile model
        order
            Order the returned AgentFile records by any field
        distinct
            Filter AgentFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgentFile
            The first AgentFile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgentFile record ordered by the filename field
        agentfile = await AgentFile.prisma().find_first(
            skip=1,
            order={
                'filename': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
        include: Optional[types.AgentFileInclude] = None,
        order: Optional[Union[types.AgentFileOrderByInput, List[types.AgentFileOrderByInput]]] = None,
        distinct: Optional[List[types.AgentFileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AgentFile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgentFile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentFile model
        order
            Order the returned AgentFile records by any field
        distinct
            Filter AgentFile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgentFile
            The first AgentFile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgentFile record ordered by the mimeType field
        agentfile = await AgentFile.prisma().find_first_or_raise(
            skip=1,
            order={
                'mimeType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgentFileUpdateInput,
        where: types.AgentFileWhereUniqueInput,
        include: Optional[types.AgentFileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AgentFile record.

        Parameters
        ----------
        data
            AgentFile record data specifying what to update
        where
            AgentFile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The updated AgentFile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agentfile = await AgentFile.prisma().update(
            where={
                'id': 'chbgcaajc',
            },
            data={
                # data to update the AgentFile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgentFileWhereUniqueInput,
        data: types.AgentFileUpsertInput,
        include: Optional[types.AgentFileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AgentFile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AgentFile model

        Returns
        -------
        prisma.models.AgentFile
            The created or updated AgentFile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentfile = await AgentFile.prisma().upsert(
            where={
                'id': 'baafadjcdh',
            },
            data={
                'create': {
                    'id': 'baafadjcdh',
                    'userId': 'ihfjdgceh',
                    'filename': 'gdaedbiee',
                    'mimeType': 'bibdbbffjh',
                    'size': 1395459970,
                    'url': 'bjcjfbafeh',
                    'blobKey': 'bchgjchgjg',
                },
                'update': {
                    'userId': 'ihfjdgceh',
                    'filename': 'gdaedbiee',
                    'mimeType': 'bibdbbffjh',
                    'size': 1395459970,
                    'url': 'bjcjfbafeh',
                    'blobKey': 'bchgjchgjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgentFileUpdateManyMutationInput,
        where: types.AgentFileWhereInput,
    ) -> int:
        """Update multiple AgentFile records

        Parameters
        ----------
        data
            AgentFile data to update the selected AgentFile records to
        where
            Filter to select the AgentFile records to update

        Returns
        -------
        int
            The total number of AgentFile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AgentFile records
        total = await AgentFile.prisma().update_many(
            data={
                'size': 1487930586
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AgentFile records present in the database

        Parameters
        ----------
        select
            Select the AgentFile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgentFile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentFileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgentFile.prisma().count()

        # results: prisma.types.AgentFileCountAggregateOutput
        results = await AgentFile.prisma().count(
            select={
                '_all': True,
                'url': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgentFileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
    ) -> types.AgentFileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgentFileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentFileWhereInput] = None,
        cursor: Optional[types.AgentFileWhereUniqueInput] = None,
    ) -> Union[int, types.AgentFileCountAggregateOutput]:
        """Count the number of AgentFile records present in the database

        Parameters
        ----------
        select
            Select the AgentFile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgentFile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentFileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgentFile.prisma().count()

        # results: prisma.types.AgentFileCountAggregateOutput
        results = await AgentFile.prisma().count(
            select={
                '_all': True,
                'blobKey': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgentFileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgentFileWhereInput] = None
    ) -> int:
        """Delete multiple AgentFile records.

        Parameters
        ----------
        where
            Optional AgentFile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AgentFile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AgentFile records
        total = await AgentFile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgentFileScalarFieldKeys'],
        *,
        where: Optional['types.AgentFileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgentFileAvgAggregateInput'] = None,
        sum: Optional['types.AgentFileSumAggregateInput'] = None,
        min: Optional['types.AgentFileMinAggregateInput'] = None,
        max: Optional['types.AgentFileMaxAggregateInput'] = None,
        having: Optional['types.AgentFileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgentFileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgentFileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgentFileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgentFileGroupByOutput']:
        """Group AgentFile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AgentFile fields to group records by
        where
            AgentFile filter to select records
        take
            Limit the maximum number of AgentFile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgentFileGroupByOutput]
            A list of dictionaries representing the AgentFile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AgentFile records by openaiFileId values
        # and count how many records are in each group
        results = await AgentFile.prisma().group_by(
            ['openaiFileId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AgentUserVectorStoreActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AgentUserVectorStore]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AgentUserVectorStore.prisma().query_raw(
            'SELECT * FROM AgentUserVectorStore WHERE id = $1',
            'cbdbchfabj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AgentUserVectorStore.prisma().query_first(
            'SELECT * FROM AgentUserVectorStore WHERE userId = $1',
            'bffjafacbg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AgentUserVectorStoreCreateInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None
    ) -> _PrismaModelT:
        """Create a new AgentUserVectorStore record.

        Parameters
        ----------
        data
            AgentUserVectorStore record data
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The created AgentUserVectorStore record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AgentUserVectorStore record from just the required fields
        agentuservectorstore = await AgentUserVectorStore.prisma().create(
            data={
                # data to create a AgentUserVectorStore record
                'userId': 'cbafbcgeab',
                'vectorStoreId': 'bedgbciecc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AgentUserVectorStoreCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AgentUserVectorStore records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AgentUserVectorStore record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AgentUserVectorStore.prisma().create_many(
            data=[
                {
                    # data to create a AgentUserVectorStore record
                    'userId': 'bfeehfcihb',
                    'vectorStoreId': 'ibagheidg',
                },
                {
                    # data to create a AgentUserVectorStore record
                    'userId': 'bibfefchh',
                    'vectorStoreId': 'baeeigbje',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AgentUserVectorStoreWhereUniqueInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AgentUserVectorStore record.

        Parameters
        ----------
        where
            AgentUserVectorStore filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The deleted AgentUserVectorStore record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentuservectorstore = await AgentUserVectorStore.prisma().delete(
            where={
                'id': 'fibhgbdb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AgentUserVectorStoreWhereUniqueInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AgentUserVectorStore record.

        Parameters
        ----------
        where
            AgentUserVectorStore filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The found AgentUserVectorStore record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentuservectorstore = await AgentUserVectorStore.prisma().find_unique(
            where={
                'id': 'bbifhfaabg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AgentUserVectorStoreWhereUniqueInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AgentUserVectorStore record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AgentUserVectorStore filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The found AgentUserVectorStore record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentuservectorstore = await AgentUserVectorStore.prisma().find_unique_or_raise(
            where={
                'id': 'cbbhjdebdh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
        include: Optional[types.AgentUserVectorStoreInclude] = None,
        order: Optional[Union[types.AgentUserVectorStoreOrderByInput, List[types.AgentUserVectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.AgentUserVectorStoreScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AgentUserVectorStore records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AgentUserVectorStore records returned
        skip
            Ignore the first N results
        where
            AgentUserVectorStore filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model
        order
            Order the returned AgentUserVectorStore records by any field
        distinct
            Filter AgentUserVectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AgentUserVectorStore]
            The list of all AgentUserVectorStore records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AgentUserVectorStore records
        agentuservectorstores = await AgentUserVectorStore.prisma().find_many(take=10)

        # find the first 5 AgentUserVectorStore records ordered by the vectorStoreId field
        agentuservectorstores = await AgentUserVectorStore.prisma().find_many(
            take=5,
            order={
                'vectorStoreId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
        include: Optional[types.AgentUserVectorStoreInclude] = None,
        order: Optional[Union[types.AgentUserVectorStoreOrderByInput, List[types.AgentUserVectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.AgentUserVectorStoreScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AgentUserVectorStore record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgentUserVectorStore filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model
        order
            Order the returned AgentUserVectorStore records by any field
        distinct
            Filter AgentUserVectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The first AgentUserVectorStore record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgentUserVectorStore record ordered by the expiresAt field
        agentuservectorstore = await AgentUserVectorStore.prisma().find_first(
            skip=1,
            order={
                'expiresAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
        include: Optional[types.AgentUserVectorStoreInclude] = None,
        order: Optional[Union[types.AgentUserVectorStoreOrderByInput, List[types.AgentUserVectorStoreOrderByInput]]] = None,
        distinct: Optional[List[types.AgentUserVectorStoreScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AgentUserVectorStore record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AgentUserVectorStore filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model
        order
            Order the returned AgentUserVectorStore records by any field
        distinct
            Filter AgentUserVectorStore records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The first AgentUserVectorStore record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AgentUserVectorStore record ordered by the createdAt field
        agentuservectorstore = await AgentUserVectorStore.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AgentUserVectorStoreUpdateInput,
        where: types.AgentUserVectorStoreWhereUniqueInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AgentUserVectorStore record.

        Parameters
        ----------
        data
            AgentUserVectorStore record data specifying what to update
        where
            AgentUserVectorStore filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The updated AgentUserVectorStore record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        agentuservectorstore = await AgentUserVectorStore.prisma().update(
            where={
                'id': 'hddcfecha',
            },
            data={
                # data to update the AgentUserVectorStore record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AgentUserVectorStoreWhereUniqueInput,
        data: types.AgentUserVectorStoreUpsertInput,
        include: Optional[types.AgentUserVectorStoreInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AgentUserVectorStore filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AgentUserVectorStore model

        Returns
        -------
        prisma.models.AgentUserVectorStore
            The created or updated AgentUserVectorStore record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        agentuservectorstore = await AgentUserVectorStore.prisma().upsert(
            where={
                'id': 'bibbehhehb',
            },
            data={
                'create': {
                    'id': 'bibbehhehb',
                    'userId': 'bibfefchh',
                    'vectorStoreId': 'baeeigbje',
                },
                'update': {
                    'userId': 'bibfefchh',
                    'vectorStoreId': 'baeeigbje',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AgentUserVectorStoreUpdateManyMutationInput,
        where: types.AgentUserVectorStoreWhereInput,
    ) -> int:
        """Update multiple AgentUserVectorStore records

        Parameters
        ----------
        data
            AgentUserVectorStore data to update the selected AgentUserVectorStore records to
        where
            Filter to select the AgentUserVectorStore records to update

        Returns
        -------
        int
            The total number of AgentUserVectorStore records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AgentUserVectorStore records
        total = await AgentUserVectorStore.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AgentUserVectorStore records present in the database

        Parameters
        ----------
        select
            Select the AgentUserVectorStore fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgentUserVectorStore filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentUserVectorStoreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgentUserVectorStore.prisma().count()

        # results: prisma.types.AgentUserVectorStoreCountAggregateOutput
        results = await AgentUserVectorStore.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AgentUserVectorStoreCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
    ) -> types.AgentUserVectorStoreCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AgentUserVectorStoreCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None,
        cursor: Optional[types.AgentUserVectorStoreWhereUniqueInput] = None,
    ) -> Union[int, types.AgentUserVectorStoreCountAggregateOutput]:
        """Count the number of AgentUserVectorStore records present in the database

        Parameters
        ----------
        select
            Select the AgentUserVectorStore fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AgentUserVectorStore filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AgentUserVectorStoreCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AgentUserVectorStore.prisma().count()

        # results: prisma.types.AgentUserVectorStoreCountAggregateOutput
        results = await AgentUserVectorStore.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AgentUserVectorStoreCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AgentUserVectorStoreWhereInput] = None
    ) -> int:
        """Delete multiple AgentUserVectorStore records.

        Parameters
        ----------
        where
            Optional AgentUserVectorStore filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AgentUserVectorStore records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AgentUserVectorStore records
        total = await AgentUserVectorStore.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AgentUserVectorStoreScalarFieldKeys'],
        *,
        where: Optional['types.AgentUserVectorStoreWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AgentUserVectorStoreAvgAggregateInput'] = None,
        sum: Optional['types.AgentUserVectorStoreSumAggregateInput'] = None,
        min: Optional['types.AgentUserVectorStoreMinAggregateInput'] = None,
        max: Optional['types.AgentUserVectorStoreMaxAggregateInput'] = None,
        having: Optional['types.AgentUserVectorStoreScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AgentUserVectorStoreCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AgentUserVectorStoreScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AgentUserVectorStoreScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AgentUserVectorStoreGroupByOutput']:
        """Group AgentUserVectorStore records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AgentUserVectorStore fields to group records by
        where
            AgentUserVectorStore filter to select records
        take
            Limit the maximum number of AgentUserVectorStore records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AgentUserVectorStoreGroupByOutput]
            A list of dictionaries representing the AgentUserVectorStore record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AgentUserVectorStore records by vectorStoreId values
        # and count how many records are in each group
        results = await AgentUserVectorStore.prisma().group_by(
            ['vectorStoreId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserRuleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserRule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserRule.prisma().query_raw(
            'SELECT * FROM UserRule WHERE id = $1',
            'cibfeagfc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserRule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserRule.prisma().query_first(
            'SELECT * FROM UserRule WHERE userId = $1',
            'ibifgbhib',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserRuleCreateInput,
        include: Optional[types.UserRuleInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserRule record.

        Parameters
        ----------
        data
            UserRule record data
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The created UserRule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserRule record from just the required fields
        userrule = await UserRule.prisma().create(
            data={
                # data to create a UserRule record
                'userId': 'bgjehbiaja',
                'category': enums.UserRuleCategory.EMAIL_WRITING,
                'content': 'cadgbfjjf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserRuleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserRule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserRule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserRule.prisma().create_many(
            data=[
                {
                    # data to create a UserRule record
                    'userId': 'bgceeachbc',
                    'category': enums.UserRuleCategory.EMAIL_WRITING,
                    'content': 'bbcaehffaf',
                },
                {
                    # data to create a UserRule record
                    'userId': 'ddbhhchfi',
                    'category': enums.UserRuleCategory.EMAIL_WRITING,
                    'content': 'bidbdafbhf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserRuleWhereUniqueInput,
        include: Optional[types.UserRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserRule record.

        Parameters
        ----------
        where
            UserRule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The deleted UserRule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrule = await UserRule.prisma().delete(
            where={
                'id': 'caehibbhia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserRuleWhereUniqueInput,
        include: Optional[types.UserRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserRule record.

        Parameters
        ----------
        where
            UserRule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The found UserRule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrule = await UserRule.prisma().find_unique(
            where={
                'id': 'iafgcehej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserRuleWhereUniqueInput,
        include: Optional[types.UserRuleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserRule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserRule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The found UserRule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrule = await UserRule.prisma().find_unique_or_raise(
            where={
                'id': 'bbaeaehiec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
        include: Optional[types.UserRuleInclude] = None,
        order: Optional[Union[types.UserRuleOrderByInput, List[types.UserRuleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRuleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserRule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserRule records returned
        skip
            Ignore the first N results
        where
            UserRule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRule model
        order
            Order the returned UserRule records by any field
        distinct
            Filter UserRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserRule]
            The list of all UserRule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserRule records
        userrules = await UserRule.prisma().find_many(take=10)

        # find the first 5 UserRule records ordered by the category field
        userrules = await UserRule.prisma().find_many(
            take=5,
            order={
                'category': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
        include: Optional[types.UserRuleInclude] = None,
        order: Optional[Union[types.UserRuleOrderByInput, List[types.UserRuleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRuleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserRule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserRule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRule model
        order
            Order the returned UserRule records by any field
        distinct
            Filter UserRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserRule
            The first UserRule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserRule record ordered by the content field
        userrule = await UserRule.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
        include: Optional[types.UserRuleInclude] = None,
        order: Optional[Union[types.UserRuleOrderByInput, List[types.UserRuleOrderByInput]]] = None,
        distinct: Optional[List[types.UserRuleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserRule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserRule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserRule model
        order
            Order the returned UserRule records by any field
        distinct
            Filter UserRule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserRule
            The first UserRule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserRule record ordered by the isActive field
        userrule = await UserRule.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserRuleUpdateInput,
        where: types.UserRuleWhereUniqueInput,
        include: Optional[types.UserRuleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserRule record.

        Parameters
        ----------
        data
            UserRule record data specifying what to update
        where
            UserRule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The updated UserRule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userrule = await UserRule.prisma().update(
            where={
                'id': 'cfjghaged',
            },
            data={
                # data to update the UserRule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserRuleWhereUniqueInput,
        data: types.UserRuleUpsertInput,
        include: Optional[types.UserRuleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserRule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserRule model

        Returns
        -------
        prisma.models.UserRule
            The created or updated UserRule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userrule = await UserRule.prisma().upsert(
            where={
                'id': 'biggeddiea',
            },
            data={
                'create': {
                    'id': 'biggeddiea',
                    'userId': 'ddbhhchfi',
                    'category': enums.UserRuleCategory.EMAIL_WRITING,
                    'content': 'bidbdafbhf',
                },
                'update': {
                    'userId': 'ddbhhchfi',
                    'category': enums.UserRuleCategory.EMAIL_WRITING,
                    'content': 'bidbdafbhf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserRuleUpdateManyMutationInput,
        where: types.UserRuleWhereInput,
    ) -> int:
        """Update multiple UserRule records

        Parameters
        ----------
        data
            UserRule data to update the selected UserRule records to
        where
            Filter to select the UserRule records to update

        Returns
        -------
        int
            The total number of UserRule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserRule records
        total = await UserRule.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserRule records present in the database

        Parameters
        ----------
        select
            Select the UserRule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserRule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserRuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserRule.prisma().count()

        # results: prisma.types.UserRuleCountAggregateOutput
        results = await UserRule.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserRuleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
    ) -> types.UserRuleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserRuleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserRuleWhereInput] = None,
        cursor: Optional[types.UserRuleWhereUniqueInput] = None,
    ) -> Union[int, types.UserRuleCountAggregateOutput]:
        """Count the number of UserRule records present in the database

        Parameters
        ----------
        select
            Select the UserRule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserRule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserRuleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserRule.prisma().count()

        # results: prisma.types.UserRuleCountAggregateOutput
        results = await UserRule.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserRuleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserRuleWhereInput] = None
    ) -> int:
        """Delete multiple UserRule records.

        Parameters
        ----------
        where
            Optional UserRule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserRule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserRule records
        total = await UserRule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserRuleScalarFieldKeys'],
        *,
        where: Optional['types.UserRuleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserRuleAvgAggregateInput'] = None,
        sum: Optional['types.UserRuleSumAggregateInput'] = None,
        min: Optional['types.UserRuleMinAggregateInput'] = None,
        max: Optional['types.UserRuleMaxAggregateInput'] = None,
        having: Optional['types.UserRuleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserRuleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserRuleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserRuleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserRuleGroupByOutput']:
        """Group UserRule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserRule fields to group records by
        where
            UserRule filter to select records
        take
            Limit the maximum number of UserRule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserRuleGroupByOutput]
            A list of dictionaries representing the UserRule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserRule records by userId values
        # and count how many records are in each group
        results = await UserRule.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailIndexingJobActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailIndexingJob]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailIndexingJob.prisma().query_raw(
            'SELECT * FROM EmailIndexingJob WHERE id = $1',
            'biahhhjceb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailIndexingJob
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailIndexingJob.prisma().query_first(
            'SELECT * FROM EmailIndexingJob WHERE jobId = $1',
            'bdjjdgddhe',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailIndexingJobCreateInput,
        include: Optional[types.EmailIndexingJobInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailIndexingJob record.

        Parameters
        ----------
        data
            EmailIndexingJob record data
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The created EmailIndexingJob record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailIndexingJob record from just the required fields
        emailindexingjob = await EmailIndexingJob.prisma().create(
            data={
                # data to create a EmailIndexingJob record
                'jobId': 'cbaaahdbgh',
                'userId': 'cahhcbdhii',
                'organizationId': 'baibcghaef',
                'jobType': enums.EmailIndexingJobType.ONBOARDING_SENT,
                'status': enums.EmailIndexingJobStatus.PENDING,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailIndexingJobCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailIndexingJob records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailIndexingJob record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailIndexingJob.prisma().create_many(
            data=[
                {
                    # data to create a EmailIndexingJob record
                    'jobId': 'dajaaacfa',
                    'userId': 'gdibgabah',
                    'organizationId': 'bbdgidjcea',
                    'jobType': enums.EmailIndexingJobType.ONBOARDING_SENT,
                    'status': enums.EmailIndexingJobStatus.PENDING,
                },
                {
                    # data to create a EmailIndexingJob record
                    'jobId': 'bigggbcjgb',
                    'userId': 'bfhhaicdhe',
                    'organizationId': 'bgdeigedch',
                    'jobType': enums.EmailIndexingJobType.ONBOARDING_SENT,
                    'status': enums.EmailIndexingJobStatus.PENDING,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailIndexingJobWhereUniqueInput,
        include: Optional[types.EmailIndexingJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailIndexingJob record.

        Parameters
        ----------
        where
            EmailIndexingJob filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The deleted EmailIndexingJob record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailindexingjob = await EmailIndexingJob.prisma().delete(
            where={
                'id': 'gedhbbhdc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailIndexingJobWhereUniqueInput,
        include: Optional[types.EmailIndexingJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailIndexingJob record.

        Parameters
        ----------
        where
            EmailIndexingJob filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The found EmailIndexingJob record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailindexingjob = await EmailIndexingJob.prisma().find_unique(
            where={
                'id': 'bcgcffdgcj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailIndexingJobWhereUniqueInput,
        include: Optional[types.EmailIndexingJobInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailIndexingJob record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailIndexingJob filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The found EmailIndexingJob record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailindexingjob = await EmailIndexingJob.prisma().find_unique_or_raise(
            where={
                'id': 'bihjhiiji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
        include: Optional[types.EmailIndexingJobInclude] = None,
        order: Optional[Union[types.EmailIndexingJobOrderByInput, List[types.EmailIndexingJobOrderByInput]]] = None,
        distinct: Optional[List[types.EmailIndexingJobScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailIndexingJob records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailIndexingJob records returned
        skip
            Ignore the first N results
        where
            EmailIndexingJob filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model
        order
            Order the returned EmailIndexingJob records by any field
        distinct
            Filter EmailIndexingJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailIndexingJob]
            The list of all EmailIndexingJob records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailIndexingJob records
        emailindexingjobs = await EmailIndexingJob.prisma().find_many(take=10)

        # find the first 5 EmailIndexingJob records ordered by the userId field
        emailindexingjobs = await EmailIndexingJob.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
        include: Optional[types.EmailIndexingJobInclude] = None,
        order: Optional[Union[types.EmailIndexingJobOrderByInput, List[types.EmailIndexingJobOrderByInput]]] = None,
        distinct: Optional[List[types.EmailIndexingJobScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailIndexingJob record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailIndexingJob filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model
        order
            Order the returned EmailIndexingJob records by any field
        distinct
            Filter EmailIndexingJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailIndexingJob
            The first EmailIndexingJob record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailIndexingJob record ordered by the organizationId field
        emailindexingjob = await EmailIndexingJob.prisma().find_first(
            skip=1,
            order={
                'organizationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
        include: Optional[types.EmailIndexingJobInclude] = None,
        order: Optional[Union[types.EmailIndexingJobOrderByInput, List[types.EmailIndexingJobOrderByInput]]] = None,
        distinct: Optional[List[types.EmailIndexingJobScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailIndexingJob record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailIndexingJob filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model
        order
            Order the returned EmailIndexingJob records by any field
        distinct
            Filter EmailIndexingJob records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailIndexingJob
            The first EmailIndexingJob record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailIndexingJob record ordered by the jobType field
        emailindexingjob = await EmailIndexingJob.prisma().find_first_or_raise(
            skip=1,
            order={
                'jobType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailIndexingJobUpdateInput,
        where: types.EmailIndexingJobWhereUniqueInput,
        include: Optional[types.EmailIndexingJobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailIndexingJob record.

        Parameters
        ----------
        data
            EmailIndexingJob record data specifying what to update
        where
            EmailIndexingJob filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The updated EmailIndexingJob record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailindexingjob = await EmailIndexingJob.prisma().update(
            where={
                'id': 'ididibbff',
            },
            data={
                # data to update the EmailIndexingJob record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailIndexingJobWhereUniqueInput,
        data: types.EmailIndexingJobUpsertInput,
        include: Optional[types.EmailIndexingJobInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailIndexingJob filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailIndexingJob model

        Returns
        -------
        prisma.models.EmailIndexingJob
            The created or updated EmailIndexingJob record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailindexingjob = await EmailIndexingJob.prisma().upsert(
            where={
                'id': 'cgbfcibga',
            },
            data={
                'create': {
                    'id': 'cgbfcibga',
                    'jobId': 'bigggbcjgb',
                    'userId': 'bfhhaicdhe',
                    'organizationId': 'bgdeigedch',
                    'jobType': enums.EmailIndexingJobType.ONBOARDING_SENT,
                    'status': enums.EmailIndexingJobStatus.PENDING,
                },
                'update': {
                    'jobId': 'bigggbcjgb',
                    'userId': 'bfhhaicdhe',
                    'organizationId': 'bgdeigedch',
                    'jobType': enums.EmailIndexingJobType.ONBOARDING_SENT,
                    'status': enums.EmailIndexingJobStatus.PENDING,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailIndexingJobUpdateManyMutationInput,
        where: types.EmailIndexingJobWhereInput,
    ) -> int:
        """Update multiple EmailIndexingJob records

        Parameters
        ----------
        data
            EmailIndexingJob data to update the selected EmailIndexingJob records to
        where
            Filter to select the EmailIndexingJob records to update

        Returns
        -------
        int
            The total number of EmailIndexingJob records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailIndexingJob records
        total = await EmailIndexingJob.prisma().update_many(
            data={
                'status': enums.EmailIndexingJobStatus.PENDING
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailIndexingJob records present in the database

        Parameters
        ----------
        select
            Select the EmailIndexingJob fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailIndexingJob filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailIndexingJobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailIndexingJob.prisma().count()

        # results: prisma.types.EmailIndexingJobCountAggregateOutput
        results = await EmailIndexingJob.prisma().count(
            select={
                '_all': True,
                'totalEmails': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailIndexingJobCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
    ) -> types.EmailIndexingJobCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailIndexingJobCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailIndexingJobWhereInput] = None,
        cursor: Optional[types.EmailIndexingJobWhereUniqueInput] = None,
    ) -> Union[int, types.EmailIndexingJobCountAggregateOutput]:
        """Count the number of EmailIndexingJob records present in the database

        Parameters
        ----------
        select
            Select the EmailIndexingJob fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailIndexingJob filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailIndexingJobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailIndexingJob.prisma().count()

        # results: prisma.types.EmailIndexingJobCountAggregateOutput
        results = await EmailIndexingJob.prisma().count(
            select={
                '_all': True,
                'processedEmails': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailIndexingJobCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailIndexingJobWhereInput] = None
    ) -> int:
        """Delete multiple EmailIndexingJob records.

        Parameters
        ----------
        where
            Optional EmailIndexingJob filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailIndexingJob records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailIndexingJob records
        total = await EmailIndexingJob.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailIndexingJobScalarFieldKeys'],
        *,
        where: Optional['types.EmailIndexingJobWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailIndexingJobAvgAggregateInput'] = None,
        sum: Optional['types.EmailIndexingJobSumAggregateInput'] = None,
        min: Optional['types.EmailIndexingJobMinAggregateInput'] = None,
        max: Optional['types.EmailIndexingJobMaxAggregateInput'] = None,
        having: Optional['types.EmailIndexingJobScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailIndexingJobCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailIndexingJobScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailIndexingJobScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailIndexingJobGroupByOutput']:
        """Group EmailIndexingJob records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailIndexingJob fields to group records by
        where
            EmailIndexingJob filter to select records
        take
            Limit the maximum number of EmailIndexingJob records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailIndexingJobGroupByOutput]
            A list of dictionaries representing the EmailIndexingJob record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailIndexingJob records by failedEmails values
        # and count how many records are in each group
        results = await EmailIndexingJob.prisma().group_by(
            ['failedEmails'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models