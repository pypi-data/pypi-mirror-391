# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    clerkId: _str
    email: _str
    firstName: Optional[_str] = None
    lastName: Optional[_str] = None
    profileImageUrl: Optional[_str] = None
    phoneNumber: Optional[_str] = None
    isActive: _bool
    version: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    gmailTokens: Optional[List['models.UserGmailToken']] = None
    emailPreferences: Optional['models.UserEmailPreferences'] = None
    emailThreads: Optional[List['models.EmailThread']] = None
    emails: Optional[List['models.Email']] = None
    organizationMemberships: Optional[List['models.OrganizationMember']] = None
    projectMemberships: Optional[List['models.ProjectMember']] = None
    auditLogs: Optional[List['models.AuditLog']] = None
    agentFiles: Optional[List['models.AgentFile']] = None
    userRules: Optional[List['models.UserRule']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class UserGmailToken(bases.BaseUserGmailToken):
    """Represents a UserGmailToken record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    email: _str
    accessToken: _str
    refreshToken: Optional[_str] = None
    tokenType: _str
    scope: _str
    expiresAt: datetime.datetime
    isActive: _bool
    lastSyncAt: Optional[datetime.datetime] = None
    historyId: Optional[_int] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserGmailTokenKeys']] = None,
        exclude: Optional[Iterable['types.UserGmailTokenKeys']] = None,
        required: Optional[Iterable['types.UserGmailTokenKeys']] = None,
        optional: Optional[Iterable['types.UserGmailTokenKeys']] = None,
        relations: Optional[Mapping['types.UserGmailTokenRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserGmailTokenKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserGmailToken_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserGmailToken_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserGmailToken_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserGmailToken_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserGmailToken_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserGmailToken_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserGmailToken', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserGmailToken / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserGmailToken',
            }
        )
        _created_partial_types.add(name)


class Company(bases.BaseCompany):
    """Represents a Company record"""

    id: _str
    name: _str
    domain: Optional[_str] = None
    industry: Optional[_str] = None
    address: Optional[_str] = None
    website: Optional[_str] = None
    description: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    organizations: Optional[List['models.OrganizationCompany']] = None
    contacts: Optional[List['models.Contact']] = None
    projectLinks: Optional[List['models.ProjectCompany']] = None
    tags: Optional[List['models.ProjectTag']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CompanyKeys']] = None,
        exclude: Optional[Iterable['types.CompanyKeys']] = None,
        required: Optional[Iterable['types.CompanyKeys']] = None,
        optional: Optional[Iterable['types.CompanyKeys']] = None,
        relations: Optional[Mapping['types.CompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Company_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Company_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Company_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Company_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Company_relational_fields:
                        raise errors.UnknownRelationalFieldError('Company', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Company / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Company',
            }
        )
        _created_partial_types.add(name)


class OrganizationCompany(bases.BaseOrganizationCompany):
    """Represents a OrganizationCompany record"""

    id: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    companyId: _str
    company: Optional['models.Company'] = None
    note: Optional[_str] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationCompanyKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationCompanyKeys']] = None,
        required: Optional[Iterable['types.OrganizationCompanyKeys']] = None,
        optional: Optional[Iterable['types.OrganizationCompanyKeys']] = None,
        relations: Optional[Mapping['types.OrganizationCompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationCompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OrganizationCompany_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OrganizationCompany_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OrganizationCompany_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OrganizationCompany_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OrganizationCompany_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OrganizationCompany_relational_fields:
                        raise errors.UnknownRelationalFieldError('OrganizationCompany', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OrganizationCompany / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OrganizationCompany',
            }
        )
        _created_partial_types.add(name)


class Contact(bases.BaseContact):
    """Represents a Contact record"""

    id: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    companyId: Optional[_str] = None
    company: Optional['models.Company'] = None
    name: _str
    email: _str
    phone: Optional[_str] = None
    role: Optional[_str] = None
    description: Optional[_str] = None
    source: 'enums.ContactSource'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    projects: Optional[List['models.ProjectContact']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ContactKeys']] = None,
        exclude: Optional[Iterable['types.ContactKeys']] = None,
        required: Optional[Iterable['types.ContactKeys']] = None,
        optional: Optional[Iterable['types.ContactKeys']] = None,
        relations: Optional[Mapping['types.ContactRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ContactKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Contact_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Contact_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Contact_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Contact_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Contact_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Contact_relational_fields:
                        raise errors.UnknownRelationalFieldError('Contact', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Contact / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Contact',
            }
        )
        _created_partial_types.add(name)


class UserEmailPreferences(bases.BaseUserEmailPreferences):
    """Represents a UserEmailPreferences record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    autoSyncEnabled: _bool
    syncFrequencyMinutes: _int
    maxEmailsPerSync: _int
    enableSmartSearch: _bool
    lastHistoryId: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserEmailPreferencesKeys']] = None,
        exclude: Optional[Iterable['types.UserEmailPreferencesKeys']] = None,
        required: Optional[Iterable['types.UserEmailPreferencesKeys']] = None,
        optional: Optional[Iterable['types.UserEmailPreferencesKeys']] = None,
        relations: Optional[Mapping['types.UserEmailPreferencesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserEmailPreferencesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserEmailPreferences_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserEmailPreferences_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserEmailPreferences_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserEmailPreferences_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserEmailPreferences_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserEmailPreferences_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserEmailPreferences', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserEmailPreferences / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserEmailPreferences',
            }
        )
        _created_partial_types.add(name)


class EmailThread(bases.BaseEmailThread):
    """Represents a EmailThread record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    organizationId: _str
    organization: Optional['models.Organization'] = None
    gmailThreadId: _str
    subject: _str
    participants: List[_str]
    lastMessageAt: datetime.datetime
    messageCount: _int
    isRead: _bool
    isImportant: _bool
    labels: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    emails: Optional[List['models.Email']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('participants', 'labels', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailThreadKeys']] = None,
        exclude: Optional[Iterable['types.EmailThreadKeys']] = None,
        required: Optional[Iterable['types.EmailThreadKeys']] = None,
        optional: Optional[Iterable['types.EmailThreadKeys']] = None,
        relations: Optional[Mapping['types.EmailThreadRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailThreadKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailThread_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailThread_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailThread_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailThread_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailThread_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailThread_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailThread', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailThread / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailThread',
            }
        )
        _created_partial_types.add(name)


class Email(bases.BaseEmail):
    """Represents a Email record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    organizationId: _str
    organization: Optional['models.Organization'] = None
    threadId: _str
    thread: Optional['models.EmailThread'] = None
    gmailMessageId: _str
    messageId: Optional[_str] = None
    inReplyTo: Optional[_str] = None
    references: List[_str]
    sender: _str
    senderName: Optional[_str] = None
    recipients: List[_str]
    ccRecipients: List[_str]
    bccRecipients: List[_str]
    subject: _str
    snippet: Optional[_str] = None
    sentAt: datetime.datetime
    receivedAt: datetime.datetime
    emailType: 'enums.EmailType'
    isRead: _bool
    isImportant: _bool
    isDraft: _bool
    labels: List[_str]
    excludeFromAnalysis: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    content: Optional['models.EmailContent'] = None
    attachments: Optional[List['models.EmailAttachment']] = None
    classifications: Optional[List['models.EmailClassification']] = None
    emailTasks: Optional[List['models.EmailTask']] = None
    emailProjects: Optional[List['models.EmailProject']] = None
    emailApproval: Optional['models.EmailApproval'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('references', 'recipients', 'ccRecipients', 'bccRecipients', 'labels', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailKeys']] = None,
        exclude: Optional[Iterable['types.EmailKeys']] = None,
        required: Optional[Iterable['types.EmailKeys']] = None,
        optional: Optional[Iterable['types.EmailKeys']] = None,
        relations: Optional[Mapping['types.EmailRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Email_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Email_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Email_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Email_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Email_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Email_relational_fields:
                        raise errors.UnknownRelationalFieldError('Email', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Email / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Email',
            }
        )
        _created_partial_types.add(name)


class EmailContent(bases.BaseEmailContent):
    """Represents a EmailContent record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    textBody: Optional[_str] = None
    htmlBody: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailContentKeys']] = None,
        exclude: Optional[Iterable['types.EmailContentKeys']] = None,
        required: Optional[Iterable['types.EmailContentKeys']] = None,
        optional: Optional[Iterable['types.EmailContentKeys']] = None,
        relations: Optional[Mapping['types.EmailContentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailContentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailContent_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailContent_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailContent_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailContent_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailContent_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailContent_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailContent', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailContent / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailContent',
            }
        )
        _created_partial_types.add(name)


class EmailAttachment(bases.BaseEmailAttachment):
    """Represents a EmailAttachment record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    gmailAttachmentId: _str
    filename: _str
    mimeType: _str
    size: _int
    openaiFileId: Optional[_str] = None
    openaiFileExpiresAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    document: Optional['models.Document'] = None
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailAttachmentKeys']] = None,
        exclude: Optional[Iterable['types.EmailAttachmentKeys']] = None,
        required: Optional[Iterable['types.EmailAttachmentKeys']] = None,
        optional: Optional[Iterable['types.EmailAttachmentKeys']] = None,
        relations: Optional[Mapping['types.EmailAttachmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailAttachmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailAttachment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailAttachment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailAttachment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailAttachment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailAttachment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailAttachment_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailAttachment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailAttachment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailAttachment',
            }
        )
        _created_partial_types.add(name)


class EmailTask(bases.BaseEmailTask):
    """Represents a EmailTask record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    taskId: _str
    task: Optional['models.Task'] = None
    assignedAt: datetime.datetime
    assignedBy: _str
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailTaskKeys']] = None,
        exclude: Optional[Iterable['types.EmailTaskKeys']] = None,
        required: Optional[Iterable['types.EmailTaskKeys']] = None,
        optional: Optional[Iterable['types.EmailTaskKeys']] = None,
        relations: Optional[Mapping['types.EmailTaskRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailTaskKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailTask_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailTask_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailTask_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailTask_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailTask_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailTask_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailTask', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailTask / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailTask',
            }
        )
        _created_partial_types.add(name)


class EmailProject(bases.BaseEmailProject):
    """Represents a EmailProject record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    projectId: _str
    project: Optional['models.Project'] = None
    assignedAt: datetime.datetime
    assignedBy: _str
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailProjectKeys']] = None,
        exclude: Optional[Iterable['types.EmailProjectKeys']] = None,
        required: Optional[Iterable['types.EmailProjectKeys']] = None,
        optional: Optional[Iterable['types.EmailProjectKeys']] = None,
        relations: Optional[Mapping['types.EmailProjectRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailProjectKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailProject_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailProject_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailProject_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailProject_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailProject_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailProject_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailProject', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailProject / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailProject',
            }
        )
        _created_partial_types.add(name)


class EmailApproval(bases.BaseEmailApproval):
    """Represents a EmailApproval record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    status: 'enums.ClassificationStatus'
    classifiedBy: Optional[_str] = None
    classifiedAt: Optional[datetime.datetime] = None
    comment: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailApprovalKeys']] = None,
        exclude: Optional[Iterable['types.EmailApprovalKeys']] = None,
        required: Optional[Iterable['types.EmailApprovalKeys']] = None,
        optional: Optional[Iterable['types.EmailApprovalKeys']] = None,
        relations: Optional[Mapping['types.EmailApprovalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailApprovalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailApproval_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailApproval_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailApproval_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailApproval_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailApproval_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailApproval_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailApproval', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailApproval / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailApproval',
            }
        )
        _created_partial_types.add(name)


class ProjectProposal(bases.BaseProjectProposal):
    """Represents a ProjectProposal record"""

    id: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    proposedName: _str
    proposedDescription: Optional[_str] = None
    proposedTasks: Optional['fields.Json'] = None
    createdProjectId: Optional[_str] = None
    createdTaskIds: List[_str]
    resolvedAs: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    classifications: Optional[List['models.EmailClassification']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('createdTaskIds', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectProposalKeys']] = None,
        exclude: Optional[Iterable['types.ProjectProposalKeys']] = None,
        required: Optional[Iterable['types.ProjectProposalKeys']] = None,
        optional: Optional[Iterable['types.ProjectProposalKeys']] = None,
        relations: Optional[Mapping['types.ProjectProposalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectProposalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectProposal_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectProposal_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectProposal_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectProposal_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectProposal_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectProposal_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectProposal', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectProposal / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectProposal',
            }
        )
        _created_partial_types.add(name)


class TaskProposal(bases.BaseTaskProposal):
    """Represents a TaskProposal record"""

    id: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    projectId: Optional[_str] = None
    project: Optional['models.Project'] = None
    proposedTaskName: _str
    proposedDescription: Optional[_str] = None
    proposedAssignee: Optional['fields.Json'] = None
    proposedDueDate: Optional[_str] = None
    createdTaskId: Optional[_str] = None
    resolvedAs: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    classifications: Optional[List['models.EmailClassification']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TaskProposalKeys']] = None,
        exclude: Optional[Iterable['types.TaskProposalKeys']] = None,
        required: Optional[Iterable['types.TaskProposalKeys']] = None,
        optional: Optional[Iterable['types.TaskProposalKeys']] = None,
        relations: Optional[Mapping['types.TaskProposalRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TaskProposalKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TaskProposal_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TaskProposal_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TaskProposal_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TaskProposal_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TaskProposal_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TaskProposal_relational_fields:
                        raise errors.UnknownRelationalFieldError('TaskProposal', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TaskProposal / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TaskProposal',
            }
        )
        _created_partial_types.add(name)


class EmailClassification(bases.BaseEmailClassification):
    """Represents a EmailClassification record"""

    id: _str
    emailId: _str
    email: Optional['models.Email'] = None
    classificationType: 'enums.ClassificationType'
    suggestedProjectId: Optional[_str] = None
    suggestedTaskId: Optional[_str] = None
    suggestedData: Optional['fields.Json'] = None
    tags: List[_str]
    confidence: _float
    reason: Optional[_str] = None
    metadata: Optional['fields.Json'] = None
    projectProposalId: Optional[_str] = None
    projectProposal: Optional['models.ProjectProposal'] = None
    taskProposalId: Optional[_str] = None
    taskProposal: Optional['models.TaskProposal'] = None
    originalType: Optional['enums.ClassificationType'] = None
    originalData: Optional['fields.Json'] = None
    convertedAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('tags', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailClassificationKeys']] = None,
        exclude: Optional[Iterable['types.EmailClassificationKeys']] = None,
        required: Optional[Iterable['types.EmailClassificationKeys']] = None,
        optional: Optional[Iterable['types.EmailClassificationKeys']] = None,
        relations: Optional[Mapping['types.EmailClassificationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailClassificationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailClassification_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailClassification_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailClassification_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailClassification_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailClassification_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailClassification_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailClassification', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailClassification / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailClassification',
            }
        )
        _created_partial_types.add(name)


class SearchCache(bases.BaseSearchCache):
    """Represents a SearchCache record"""

    id: _str
    userId: _str
    queryHash: _str
    results: 'fields.Json'
    expiresAt: datetime.datetime
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SearchCacheKeys']] = None,
        exclude: Optional[Iterable['types.SearchCacheKeys']] = None,
        required: Optional[Iterable['types.SearchCacheKeys']] = None,
        optional: Optional[Iterable['types.SearchCacheKeys']] = None,
        relations: Optional[Mapping['types.SearchCacheRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SearchCacheKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SearchCache_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SearchCache_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SearchCache_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SearchCache_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "SearchCache" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SearchCache / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SearchCache',
            }
        )
        _created_partial_types.add(name)


class ConversationHistory(bases.BaseConversationHistory):
    """Represents a ConversationHistory record"""

    id: _str
    threadId: _str
    messages: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ConversationHistoryKeys']] = None,
        exclude: Optional[Iterable['types.ConversationHistoryKeys']] = None,
        required: Optional[Iterable['types.ConversationHistoryKeys']] = None,
        optional: Optional[Iterable['types.ConversationHistoryKeys']] = None,
        relations: Optional[Mapping['types.ConversationHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ConversationHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ConversationHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ConversationHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ConversationHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ConversationHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "ConversationHistory" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ConversationHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ConversationHistory',
            }
        )
        _created_partial_types.add(name)


class OutboxEvent(bases.BaseOutboxEvent):
    """Represents a OutboxEvent record"""

    id: _int
    topic: _str
    key: _str
    eventType: _str
    payload: 'fields.Json'
    headers: Optional['fields.Json'] = None
    occurredAt: datetime.datetime
    status: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OutboxEventKeys']] = None,
        exclude: Optional[Iterable['types.OutboxEventKeys']] = None,
        required: Optional[Iterable['types.OutboxEventKeys']] = None,
        optional: Optional[Iterable['types.OutboxEventKeys']] = None,
        relations: Optional[Mapping['types.OutboxEventRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OutboxEventKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OutboxEvent_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OutboxEvent_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OutboxEvent_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OutboxEvent_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "OutboxEvent" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OutboxEvent / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OutboxEvent',
            }
        )
        _created_partial_types.add(name)


class Organization(bases.BaseOrganization):
    """Represents a Organization record"""

    id: _str
    clerkOrganizationId: _str
    name: _str
    description: Optional[_str] = None
    imageUrl: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    members: Optional[List['models.OrganizationMember']] = None
    invitations: Optional[List['models.OrganizationInvitation']] = None
    emailThreads: Optional[List['models.EmailThread']] = None
    emails: Optional[List['models.Email']] = None
    projects: Optional[List['models.Project']] = None
    companies: Optional[List['models.OrganizationCompany']] = None
    contacts: Optional[List['models.Contact']] = None
    projectProposals: Optional[List['models.ProjectProposal']] = None
    taskProposals: Optional[List['models.TaskProposal']] = None
    agentFiles: Optional[List['models.AgentFile']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationKeys']] = None,
        required: Optional[Iterable['types.OrganizationKeys']] = None,
        optional: Optional[Iterable['types.OrganizationKeys']] = None,
        relations: Optional[Mapping['types.OrganizationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Organization_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Organization_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Organization_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Organization_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Organization_relational_fields:
                        raise errors.UnknownRelationalFieldError('Organization', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Organization / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Organization',
            }
        )
        _created_partial_types.add(name)


class OrganizationMember(bases.BaseOrganizationMember):
    """Represents a OrganizationMember record"""

    id: _str
    clerkMembershipId: _str
    organizationId: _str
    userId: _str
    role: 'enums.OrganizationRole'
    assignmentRules: List[_str]
    joinedAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    organization: Optional['models.Organization'] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('assignmentRules', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        required: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        optional: Optional[Iterable['types.OrganizationMemberKeys']] = None,
        relations: Optional[Mapping['types.OrganizationMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OrganizationMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OrganizationMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OrganizationMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OrganizationMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OrganizationMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('OrganizationMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OrganizationMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OrganizationMember',
            }
        )
        _created_partial_types.add(name)


class OrganizationInvitation(bases.BaseOrganizationInvitation):
    """Represents a OrganizationInvitation record"""

    id: _str
    clerkInvitationId: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    email: _str
    role: 'enums.OrganizationRole'
    status: 'enums.InvitationStatus'
    invitedBy: _str
    createdAt: datetime.datetime
    expiresAt: Optional[datetime.datetime] = None
    acceptedAt: Optional[datetime.datetime] = None
    revokedAt: Optional[datetime.datetime] = None
    revokedBy: Optional[_str] = None
    updatedAt: datetime.datetime
    resendCount: _int
    lastResendBy: Optional[_str] = None
    lastResendAt: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OrganizationInvitationKeys']] = None,
        exclude: Optional[Iterable['types.OrganizationInvitationKeys']] = None,
        required: Optional[Iterable['types.OrganizationInvitationKeys']] = None,
        optional: Optional[Iterable['types.OrganizationInvitationKeys']] = None,
        relations: Optional[Mapping['types.OrganizationInvitationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OrganizationInvitationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _OrganizationInvitation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _OrganizationInvitation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _OrganizationInvitation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _OrganizationInvitation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _OrganizationInvitation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _OrganizationInvitation_relational_fields:
                        raise errors.UnknownRelationalFieldError('OrganizationInvitation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid OrganizationInvitation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'OrganizationInvitation',
            }
        )
        _created_partial_types.add(name)


class Project(bases.BaseProject):
    """Represents a Project record"""

    id: _str
    organizationId: _str
    organization: Optional['models.Organization'] = None
    name: _str
    description: Optional[_str] = None
    status: 'enums.ProjectStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    members: Optional[List['models.ProjectMember']] = None
    tasks: Optional[List['models.Task']] = None
    companies: Optional[List['models.ProjectCompany']] = None
    contacts: Optional[List['models.ProjectContact']] = None
    documents: Optional[List['models.ProjectDocument']] = None
    tags: Optional[List['models.ProjectTag']] = None
    emailProjects: Optional[List['models.EmailProject']] = None
    taskProposals: Optional[List['models.TaskProposal']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectKeys']] = None,
        exclude: Optional[Iterable['types.ProjectKeys']] = None,
        required: Optional[Iterable['types.ProjectKeys']] = None,
        optional: Optional[Iterable['types.ProjectKeys']] = None,
        relations: Optional[Mapping['types.ProjectRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Project_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Project_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Project_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Project_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Project_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Project_relational_fields:
                        raise errors.UnknownRelationalFieldError('Project', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Project / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Project',
            }
        )
        _created_partial_types.add(name)


class ProjectTag(bases.BaseProjectTag):
    """Represents a ProjectTag record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    name: _str
    type: 'enums.ProjectTagType'
    sourceId: Optional[_str] = None
    company: Optional['models.Company'] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectTagKeys']] = None,
        exclude: Optional[Iterable['types.ProjectTagKeys']] = None,
        required: Optional[Iterable['types.ProjectTagKeys']] = None,
        optional: Optional[Iterable['types.ProjectTagKeys']] = None,
        relations: Optional[Mapping['types.ProjectTagRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectTagKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectTag_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectTag_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectTag_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectTag_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectTag_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectTag_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectTag', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectTag / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectTag',
            }
        )
        _created_partial_types.add(name)


class ProjectMember(bases.BaseProjectMember):
    """Represents a ProjectMember record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    userId: _str
    user: Optional['models.User'] = None
    role: 'enums.ProjectRole'
    joinedAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    assignedTasks: Optional[List['models.Task']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectMemberKeys']] = None,
        exclude: Optional[Iterable['types.ProjectMemberKeys']] = None,
        required: Optional[Iterable['types.ProjectMemberKeys']] = None,
        optional: Optional[Iterable['types.ProjectMemberKeys']] = None,
        relations: Optional[Mapping['types.ProjectMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectMember',
            }
        )
        _created_partial_types.add(name)


class Task(bases.BaseTask):
    """Represents a Task record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    title: _str
    description: Optional[_str] = None
    status: 'enums.TaskStatus'
    assigneeId: Optional[_str] = None
    assignee: Optional['models.ProjectMember'] = None
    dueDate: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    emailTasks: Optional[List['models.EmailTask']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TaskKeys']] = None,
        exclude: Optional[Iterable['types.TaskKeys']] = None,
        required: Optional[Iterable['types.TaskKeys']] = None,
        optional: Optional[Iterable['types.TaskKeys']] = None,
        relations: Optional[Mapping['types.TaskRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TaskKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Task_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Task_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Task_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Task_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Task_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Task_relational_fields:
                        raise errors.UnknownRelationalFieldError('Task', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Task / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Task',
            }
        )
        _created_partial_types.add(name)


class ProjectCompany(bases.BaseProjectCompany):
    """Represents a ProjectCompany record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    companyId: _str
    company: Optional['models.Company'] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectCompanyKeys']] = None,
        exclude: Optional[Iterable['types.ProjectCompanyKeys']] = None,
        required: Optional[Iterable['types.ProjectCompanyKeys']] = None,
        optional: Optional[Iterable['types.ProjectCompanyKeys']] = None,
        relations: Optional[Mapping['types.ProjectCompanyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectCompanyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectCompany_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectCompany_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectCompany_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectCompany_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectCompany_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectCompany_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectCompany', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectCompany / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectCompany',
            }
        )
        _created_partial_types.add(name)


class ProjectContact(bases.BaseProjectContact):
    """Represents a ProjectContact record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    contactId: _str
    contact: Optional['models.Contact'] = None
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectContactKeys']] = None,
        exclude: Optional[Iterable['types.ProjectContactKeys']] = None,
        required: Optional[Iterable['types.ProjectContactKeys']] = None,
        optional: Optional[Iterable['types.ProjectContactKeys']] = None,
        relations: Optional[Mapping['types.ProjectContactRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectContactKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectContact_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectContact_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectContact_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectContact_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectContact_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectContact_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectContact', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectContact / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectContact',
            }
        )
        _created_partial_types.add(name)


class Document(bases.BaseDocument):
    """Represents a Document record"""

    id: _str
    name: _str
    type: _str
    size: _int
    url: Optional[_str] = None
    source: 'enums.DocumentSource'
    uploadedBy: Optional[_str] = None
    emailAttachmentId: Optional[_str] = None
    emailAttachment: Optional['models.EmailAttachment'] = None
    aiImportance: Optional['enums.DocumentImportance'] = None
    aiReason: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    projectLinks: Optional[List['models.ProjectDocument']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DocumentKeys']] = None,
        exclude: Optional[Iterable['types.DocumentKeys']] = None,
        required: Optional[Iterable['types.DocumentKeys']] = None,
        optional: Optional[Iterable['types.DocumentKeys']] = None,
        relations: Optional[Mapping['types.DocumentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DocumentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Document_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Document_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Document_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Document_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Document_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Document_relational_fields:
                        raise errors.UnknownRelationalFieldError('Document', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Document / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Document',
            }
        )
        _created_partial_types.add(name)


class ProjectDocument(bases.BaseProjectDocument):
    """Represents a ProjectDocument record"""

    id: _str
    projectId: _str
    project: Optional['models.Project'] = None
    documentId: _str
    document: Optional['models.Document'] = None
    linkedAt: datetime.datetime
    linkedBy: _str
    createdAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProjectDocumentKeys']] = None,
        exclude: Optional[Iterable['types.ProjectDocumentKeys']] = None,
        required: Optional[Iterable['types.ProjectDocumentKeys']] = None,
        optional: Optional[Iterable['types.ProjectDocumentKeys']] = None,
        relations: Optional[Mapping['types.ProjectDocumentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProjectDocumentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProjectDocument_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProjectDocument_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProjectDocument_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProjectDocument_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProjectDocument_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProjectDocument_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProjectDocument', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProjectDocument / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProjectDocument',
            }
        )
        _created_partial_types.add(name)


class AuditLog(bases.BaseAuditLog):
    """Represents a AuditLog record"""

    id: _str
    userId: _str
    clerkId: Optional[_str] = None
    action: _str
    context: _str
    targetData: Optional['fields.Json'] = None
    metadata: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.AuditLogKeys']] = None,
        required: Optional[Iterable['types.AuditLogKeys']] = None,
        optional: Optional[Iterable['types.AuditLogKeys']] = None,
        relations: Optional[Mapping['types.AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuditLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuditLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuditLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuditLog',
            }
        )
        _created_partial_types.add(name)


class AgentFile(bases.BaseAgentFile):
    """Represents a AgentFile record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    organizationId: Optional[_str] = None
    organization: Optional['models.Organization'] = None
    filename: _str
    mimeType: _str
    size: _int
    url: _str
    blobKey: _str
    openaiFileId: Optional[_str] = None
    openaiFileExpiresAt: Optional[datetime.datetime] = None
    vectorStoreId: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AgentFileKeys']] = None,
        exclude: Optional[Iterable['types.AgentFileKeys']] = None,
        required: Optional[Iterable['types.AgentFileKeys']] = None,
        optional: Optional[Iterable['types.AgentFileKeys']] = None,
        relations: Optional[Mapping['types.AgentFileRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AgentFileKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AgentFile_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AgentFile_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AgentFile_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AgentFile_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AgentFile_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AgentFile_relational_fields:
                        raise errors.UnknownRelationalFieldError('AgentFile', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AgentFile / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AgentFile',
            }
        )
        _created_partial_types.add(name)


class AgentUserVectorStore(bases.BaseAgentUserVectorStore):
    """Represents a AgentUserVectorStore record"""

    id: _str
    userId: _str
    vectorStoreId: _str
    expiresAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AgentUserVectorStoreKeys']] = None,
        exclude: Optional[Iterable['types.AgentUserVectorStoreKeys']] = None,
        required: Optional[Iterable['types.AgentUserVectorStoreKeys']] = None,
        optional: Optional[Iterable['types.AgentUserVectorStoreKeys']] = None,
        relations: Optional[Mapping['types.AgentUserVectorStoreRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AgentUserVectorStoreKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AgentUserVectorStore_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AgentUserVectorStore_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AgentUserVectorStore_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AgentUserVectorStore_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "AgentUserVectorStore" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AgentUserVectorStore / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AgentUserVectorStore',
            }
        )
        _created_partial_types.add(name)


class UserRule(bases.BaseUserRule):
    """Represents a UserRule record"""

    id: _str
    userId: _str
    user: Optional['models.User'] = None
    category: 'enums.UserRuleCategory'
    content: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserRuleKeys']] = None,
        exclude: Optional[Iterable['types.UserRuleKeys']] = None,
        required: Optional[Iterable['types.UserRuleKeys']] = None,
        optional: Optional[Iterable['types.UserRuleKeys']] = None,
        relations: Optional[Mapping['types.UserRuleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserRuleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserRule_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserRule_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserRule_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserRule_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserRule_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserRule_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserRule', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserRule / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserRule',
            }
        )
        _created_partial_types.add(name)


class EmailIndexingJob(bases.BaseEmailIndexingJob):
    """Represents a EmailIndexingJob record"""

    id: _str
    jobId: _str
    userId: _str
    organizationId: _str
    jobType: 'enums.EmailIndexingJobType'
    status: 'enums.EmailIndexingJobStatus'
    totalEmails: _int
    processedEmails: _int
    failedEmails: _int
    sinceDate: Optional[datetime.datetime] = None
    untilDate: Optional[datetime.datetime] = None
    emailType: Optional[_str] = None
    startedAt: Optional[datetime.datetime] = None
    completedAt: Optional[datetime.datetime] = None
    lastProgressAt: Optional[datetime.datetime] = None
    errorMessage: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailIndexingJobKeys']] = None,
        exclude: Optional[Iterable['types.EmailIndexingJobKeys']] = None,
        required: Optional[Iterable['types.EmailIndexingJobKeys']] = None,
        optional: Optional[Iterable['types.EmailIndexingJobKeys']] = None,
        relations: Optional[Mapping['types.EmailIndexingJobRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailIndexingJobKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailIndexingJob_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailIndexingJob_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailIndexingJob_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailIndexingJob_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "EmailIndexingJob" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailIndexingJob / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailIndexingJob',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'gmailTokens',
        'emailPreferences',
        'emailThreads',
        'emails',
        'organizationMemberships',
        'projectMemberships',
        'auditLogs',
        'agentFiles',
        'userRules',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clerkId', {
            'name': 'clerkId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstName', {
            'name': 'firstName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastName', {
            'name': 'lastName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('profileImageUrl', {
            'name': 'profileImageUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phoneNumber', {
            'name': 'phoneNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('version', {
            'name': 'version',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('gmailTokens', {
            'name': 'gmailTokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserGmailToken\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailPreferences', {
            'name': 'emailPreferences',
            'is_list': False,
            'optional': True,
            'type': 'models.UserEmailPreferences',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailThreads', {
            'name': 'emailThreads',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailThread\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emails', {
            'name': 'emails',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Email\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationMemberships', {
            'name': 'organizationMemberships',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projectMemberships', {
            'name': 'projectMemberships',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('auditLogs', {
            'name': 'auditLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuditLog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('agentFiles', {
            'name': 'agentFiles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AgentFile\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('userRules', {
            'name': 'userRules',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserRule\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserGmailToken_relational_fields: Set[str] = {
        'user',
    }
_UserGmailToken_fields: Dict['types.UserGmailTokenKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accessToken', {
            'name': 'accessToken',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('refreshToken', {
            'name': 'refreshToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenType', {
            'name': 'tokenType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('scope', {
            'name': 'scope',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastSyncAt', {
            'name': 'lastSyncAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('historyId', {
            'name': 'historyId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Company_relational_fields: Set[str] = {
        'organizations',
        'contacts',
        'projectLinks',
        'tags',
    }
_Company_fields: Dict['types.CompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('domain', {
            'name': 'domain',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('industry', {
            'name': 'industry',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('website', {
            'name': 'website',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizations', {
            'name': 'organizations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contacts', {
            'name': 'contacts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Contact\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projectLinks', {
            'name': 'projectLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectTag\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OrganizationCompany_relational_fields: Set[str] = {
        'organization',
        'company',
    }
_OrganizationCompany_fields: Dict['types.OrganizationCompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('note', {
            'name': 'note',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Contact_relational_fields: Set[str] = {
        'organization',
        'company',
        'projects',
    }
_Contact_fields: Dict['types.ContactKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': 'enums.ContactSource',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('projects', {
            'name': 'projects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectContact\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserEmailPreferences_relational_fields: Set[str] = {
        'user',
    }
_UserEmailPreferences_fields: Dict['types.UserEmailPreferencesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('autoSyncEnabled', {
            'name': 'autoSyncEnabled',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('syncFrequencyMinutes', {
            'name': 'syncFrequencyMinutes',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxEmailsPerSync', {
            'name': 'maxEmailsPerSync',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('enableSmartSearch', {
            'name': 'enableSmartSearch',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastHistoryId', {
            'name': 'lastHistoryId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailThread_relational_fields: Set[str] = {
        'user',
        'organization',
        'emails',
    }
_EmailThread_fields: Dict['types.EmailThreadKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('gmailThreadId', {
            'name': 'gmailThreadId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subject', {
            'name': 'subject',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('participants', {
            'name': 'participants',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastMessageAt', {
            'name': 'lastMessageAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('messageCount', {
            'name': 'messageCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isRead', {
            'name': 'isRead',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isImportant', {
            'name': 'isImportant',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('labels', {
            'name': 'labels',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('emails', {
            'name': 'emails',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Email\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Email_relational_fields: Set[str] = {
        'user',
        'organization',
        'thread',
        'content',
        'attachments',
        'classifications',
        'emailTasks',
        'emailProjects',
        'emailApproval',
    }
_Email_fields: Dict['types.EmailKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('threadId', {
            'name': 'threadId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('thread', {
            'name': 'thread',
            'is_list': False,
            'optional': True,
            'type': 'models.EmailThread',
            'is_relational': True,
            'documentation': None,
        }),
        ('gmailMessageId', {
            'name': 'gmailMessageId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('messageId', {
            'name': 'messageId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('inReplyTo', {
            'name': 'inReplyTo',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('references', {
            'name': 'references',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('sender', {
            'name': 'sender',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('senderName', {
            'name': 'senderName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('recipients', {
            'name': 'recipients',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('ccRecipients', {
            'name': 'ccRecipients',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('bccRecipients', {
            'name': 'bccRecipients',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('subject', {
            'name': 'subject',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('snippet', {
            'name': 'snippet',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentAt', {
            'name': 'sentAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('receivedAt', {
            'name': 'receivedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailType', {
            'name': 'emailType',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailType',
            'is_relational': False,
            'documentation': None,
        }),
        ('isRead', {
            'name': 'isRead',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isImportant', {
            'name': 'isImportant',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('isDraft', {
            'name': 'isDraft',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('labels', {
            'name': 'labels',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('excludeFromAnalysis', {
            'name': 'excludeFromAnalysis',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': True,
            'type': 'models.EmailContent',
            'is_relational': True,
            'documentation': None,
        }),
        ('attachments', {
            'name': 'attachments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailAttachment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('classifications', {
            'name': 'classifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailClassification\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailTasks', {
            'name': 'emailTasks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailTask\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailProjects', {
            'name': 'emailProjects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailProject\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailApproval', {
            'name': 'emailApproval',
            'is_list': False,
            'optional': True,
            'type': 'models.EmailApproval',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmailContent_relational_fields: Set[str] = {
        'email',
    }
_EmailContent_fields: Dict['types.EmailContentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('textBody', {
            'name': 'textBody',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('htmlBody', {
            'name': 'htmlBody',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailAttachment_relational_fields: Set[str] = {
        'email',
        'document',
    }
_EmailAttachment_fields: Dict['types.EmailAttachmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('gmailAttachmentId', {
            'name': 'gmailAttachmentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('filename', {
            'name': 'filename',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mimeType', {
            'name': 'mimeType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('size', {
            'name': 'size',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('openaiFileId', {
            'name': 'openaiFileId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('openaiFileExpiresAt', {
            'name': 'openaiFileExpiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('document', {
            'name': 'document',
            'is_list': False,
            'optional': True,
            'type': 'models.Document',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailTask_relational_fields: Set[str] = {
        'email',
        'task',
    }
_EmailTask_fields: Dict['types.EmailTaskKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('taskId', {
            'name': 'taskId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('task', {
            'name': 'task',
            'is_list': False,
            'optional': True,
            'type': 'models.Task',
            'is_relational': True,
            'documentation': None,
        }),
        ('assignedAt', {
            'name': 'assignedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedBy', {
            'name': 'assignedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailProject_relational_fields: Set[str] = {
        'email',
        'project',
    }
_EmailProject_fields: Dict['types.EmailProjectKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('assignedAt', {
            'name': 'assignedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedBy', {
            'name': 'assignedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailApproval_relational_fields: Set[str] = {
        'email',
    }
_EmailApproval_fields: Dict['types.EmailApprovalKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ClassificationStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('classifiedBy', {
            'name': 'classifiedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('classifiedAt', {
            'name': 'classifiedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ProjectProposal_relational_fields: Set[str] = {
        'organization',
        'classifications',
    }
_ProjectProposal_fields: Dict['types.ProjectProposalKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('proposedName', {
            'name': 'proposedName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposedDescription', {
            'name': 'proposedDescription',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposedTasks', {
            'name': 'proposedTasks',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdProjectId', {
            'name': 'createdProjectId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdTaskIds', {
            'name': 'createdTaskIds',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('resolvedAs', {
            'name': 'resolvedAs',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('classifications', {
            'name': 'classifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailClassification\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TaskProposal_relational_fields: Set[str] = {
        'organization',
        'project',
        'classifications',
    }
_TaskProposal_fields: Dict['types.TaskProposalKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('proposedTaskName', {
            'name': 'proposedTaskName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposedDescription', {
            'name': 'proposedDescription',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposedAssignee', {
            'name': 'proposedAssignee',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('proposedDueDate', {
            'name': 'proposedDueDate',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdTaskId', {
            'name': 'createdTaskId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resolvedAs', {
            'name': 'resolvedAs',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('classifications', {
            'name': 'classifications',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailClassification\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmailClassification_relational_fields: Set[str] = {
        'email',
        'projectProposal',
        'taskProposal',
    }
_EmailClassification_fields: Dict['types.EmailClassificationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailId', {
            'name': 'emailId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': 'models.Email',
            'is_relational': True,
            'documentation': None,
        }),
        ('classificationType', {
            'name': 'classificationType',
            'is_list': False,
            'optional': False,
            'type': 'enums.ClassificationType',
            'is_relational': False,
            'documentation': None,
        }),
        ('suggestedProjectId', {
            'name': 'suggestedProjectId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('suggestedTaskId', {
            'name': 'suggestedTaskId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('suggestedData', {
            'name': 'suggestedData',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('confidence', {
            'name': 'confidence',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('reason', {
            'name': 'reason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectProposalId', {
            'name': 'projectProposalId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectProposal', {
            'name': 'projectProposal',
            'is_list': False,
            'optional': True,
            'type': 'models.ProjectProposal',
            'is_relational': True,
            'documentation': None,
        }),
        ('taskProposalId', {
            'name': 'taskProposalId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('taskProposal', {
            'name': 'taskProposal',
            'is_list': False,
            'optional': True,
            'type': 'models.TaskProposal',
            'is_relational': True,
            'documentation': None,
        }),
        ('originalType', {
            'name': 'originalType',
            'is_list': False,
            'optional': True,
            'type': 'enums.ClassificationType',
            'is_relational': False,
            'documentation': None,
        }),
        ('originalData', {
            'name': 'originalData',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('convertedAt', {
            'name': 'convertedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_SearchCache_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_SearchCache_fields: Dict['types.SearchCacheKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('queryHash', {
            'name': 'queryHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('results', {
            'name': 'results',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ConversationHistory_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_ConversationHistory_fields: Dict['types.ConversationHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('threadId', {
            'name': 'threadId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_OutboxEvent_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_OutboxEvent_fields: Dict['types.OutboxEventKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('topic', {
            'name': 'topic',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('key', {
            'name': 'key',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('eventType', {
            'name': 'eventType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('payload', {
            'name': 'payload',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('headers', {
            'name': 'headers',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('occurredAt', {
            'name': 'occurredAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Organization_relational_fields: Set[str] = {
        'members',
        'invitations',
        'emailThreads',
        'emails',
        'projects',
        'companies',
        'contacts',
        'projectProposals',
        'taskProposals',
        'agentFiles',
    }
_Organization_fields: Dict['types.OrganizationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clerkOrganizationId', {
            'name': 'clerkOrganizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageUrl', {
            'name': 'imageUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('invitations', {
            'name': 'invitations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationInvitation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailThreads', {
            'name': 'emailThreads',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailThread\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emails', {
            'name': 'emails',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Email\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projects', {
            'name': 'projects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Project\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('companies', {
            'name': 'companies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.OrganizationCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contacts', {
            'name': 'contacts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Contact\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('projectProposals', {
            'name': 'projectProposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectProposal\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('taskProposals', {
            'name': 'taskProposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TaskProposal\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('agentFiles', {
            'name': 'agentFiles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AgentFile\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OrganizationMember_relational_fields: Set[str] = {
        'organization',
        'user',
    }
_OrganizationMember_fields: Dict['types.OrganizationMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clerkMembershipId', {
            'name': 'clerkMembershipId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.OrganizationRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignmentRules', {
            'name': 'assignmentRules',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinedAt', {
            'name': 'joinedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_OrganizationInvitation_relational_fields: Set[str] = {
        'organization',
    }
_OrganizationInvitation_fields: Dict['types.OrganizationInvitationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clerkInvitationId', {
            'name': 'clerkInvitationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.OrganizationRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.InvitationStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('invitedBy', {
            'name': 'invitedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('acceptedAt', {
            'name': 'acceptedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('revokedAt', {
            'name': 'revokedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('revokedBy', {
            'name': 'revokedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('resendCount', {
            'name': 'resendCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastResendBy', {
            'name': 'lastResendBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastResendAt', {
            'name': 'lastResendAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Project_relational_fields: Set[str] = {
        'organization',
        'members',
        'tasks',
        'companies',
        'contacts',
        'documents',
        'tags',
        'emailProjects',
        'taskProposals',
    }
_Project_fields: Dict['types.ProjectKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ProjectStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('members', {
            'name': 'members',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectMember\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tasks', {
            'name': 'tasks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Task\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('companies', {
            'name': 'companies',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectCompany\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contacts', {
            'name': 'contacts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectContact\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('documents', {
            'name': 'documents',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectDocument\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectTag\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailProjects', {
            'name': 'emailProjects',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailProject\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('taskProposals', {
            'name': 'taskProposals',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TaskProposal\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ProjectTag_relational_fields: Set[str] = {
        'project',
        'company',
    }
_ProjectTag_fields: Dict['types.ProjectTagKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.ProjectTagType',
            'is_relational': False,
            'documentation': None,
        }),
        ('sourceId', {
            'name': 'sourceId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ProjectMember_relational_fields: Set[str] = {
        'project',
        'user',
        'assignedTasks',
    }
_ProjectMember_fields: Dict['types.ProjectMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.ProjectRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('joinedAt', {
            'name': 'joinedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedTasks', {
            'name': 'assignedTasks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Task\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Task_relational_fields: Set[str] = {
        'project',
        'assignee',
        'emailTasks',
    }
_Task_fields: Dict['types.TaskKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.TaskStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('assigneeId', {
            'name': 'assigneeId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignee', {
            'name': 'assignee',
            'is_list': False,
            'optional': True,
            'type': 'models.ProjectMember',
            'is_relational': True,
            'documentation': None,
        }),
        ('dueDate', {
            'name': 'dueDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailTasks', {
            'name': 'emailTasks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailTask\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ProjectCompany_relational_fields: Set[str] = {
        'project',
        'company',
    }
_ProjectCompany_fields: Dict['types.ProjectCompanyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('companyId', {
            'name': 'companyId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('company', {
            'name': 'company',
            'is_list': False,
            'optional': True,
            'type': 'models.Company',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_ProjectContact_relational_fields: Set[str] = {
        'project',
        'contact',
    }
_ProjectContact_fields: Dict['types.ProjectContactKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('contactId', {
            'name': 'contactId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('contact', {
            'name': 'contact',
            'is_list': False,
            'optional': True,
            'type': 'models.Contact',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Document_relational_fields: Set[str] = {
        'emailAttachment',
        'projectLinks',
    }
_Document_fields: Dict['types.DocumentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('size', {
            'name': 'size',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': 'enums.DocumentSource',
            'is_relational': False,
            'documentation': None,
        }),
        ('uploadedBy', {
            'name': 'uploadedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailAttachmentId', {
            'name': 'emailAttachmentId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailAttachment', {
            'name': 'emailAttachment',
            'is_list': False,
            'optional': True,
            'type': 'models.EmailAttachment',
            'is_relational': True,
            'documentation': None,
        }),
        ('aiImportance', {
            'name': 'aiImportance',
            'is_list': False,
            'optional': True,
            'type': 'enums.DocumentImportance',
            'is_relational': False,
            'documentation': None,
        }),
        ('aiReason', {
            'name': 'aiReason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectLinks', {
            'name': 'projectLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProjectDocument\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ProjectDocument_relational_fields: Set[str] = {
        'project',
        'document',
    }
_ProjectDocument_fields: Dict['types.ProjectDocumentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('projectId', {
            'name': 'projectId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('project', {
            'name': 'project',
            'is_list': False,
            'optional': True,
            'type': 'models.Project',
            'is_relational': True,
            'documentation': None,
        }),
        ('documentId', {
            'name': 'documentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('document', {
            'name': 'document',
            'is_list': False,
            'optional': True,
            'type': 'models.Document',
            'is_relational': True,
            'documentation': None,
        }),
        ('linkedAt', {
            'name': 'linkedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('linkedBy', {
            'name': 'linkedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AuditLog_relational_fields: Set[str] = {
        'user',
    }
_AuditLog_fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clerkId', {
            'name': 'clerkId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('context', {
            'name': 'context',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('targetData', {
            'name': 'targetData',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('metadata', {
            'name': 'metadata',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AgentFile_relational_fields: Set[str] = {
        'user',
        'organization',
    }
_AgentFile_fields: Dict['types.AgentFileKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organization', {
            'name': 'organization',
            'is_list': False,
            'optional': True,
            'type': 'models.Organization',
            'is_relational': True,
            'documentation': None,
        }),
        ('filename', {
            'name': 'filename',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('mimeType', {
            'name': 'mimeType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('size', {
            'name': 'size',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('url', {
            'name': 'url',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('blobKey', {
            'name': 'blobKey',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('openaiFileId', {
            'name': 'openaiFileId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('openaiFileExpiresAt', {
            'name': 'openaiFileExpiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('vectorStoreId', {
            'name': 'vectorStoreId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AgentUserVectorStore_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_AgentUserVectorStore_fields: Dict['types.AgentUserVectorStoreKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('vectorStoreId', {
            'name': 'vectorStoreId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_UserRule_relational_fields: Set[str] = {
        'user',
    }
_UserRule_fields: Dict['types.UserRuleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRuleCategory',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_EmailIndexingJob_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_EmailIndexingJob_fields: Dict['types.EmailIndexingJobKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobId', {
            'name': 'jobId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('organizationId', {
            'name': 'organizationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('jobType', {
            'name': 'jobType',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailIndexingJobType',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailIndexingJobStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalEmails', {
            'name': 'totalEmails',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('processedEmails', {
            'name': 'processedEmails',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('failedEmails', {
            'name': 'failedEmails',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sinceDate', {
            'name': 'sinceDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('untilDate', {
            'name': 'untilDate',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailType', {
            'name': 'emailType',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastProgressAt', {
            'name': 'lastProgressAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorMessage', {
            'name': 'errorMessage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(UserGmailToken)
model_rebuild(Company)
model_rebuild(OrganizationCompany)
model_rebuild(Contact)
model_rebuild(UserEmailPreferences)
model_rebuild(EmailThread)
model_rebuild(Email)
model_rebuild(EmailContent)
model_rebuild(EmailAttachment)
model_rebuild(EmailTask)
model_rebuild(EmailProject)
model_rebuild(EmailApproval)
model_rebuild(ProjectProposal)
model_rebuild(TaskProposal)
model_rebuild(EmailClassification)
model_rebuild(SearchCache)
model_rebuild(ConversationHistory)
model_rebuild(OutboxEvent)
model_rebuild(Organization)
model_rebuild(OrganizationMember)
model_rebuild(OrganizationInvitation)
model_rebuild(Project)
model_rebuild(ProjectTag)
model_rebuild(ProjectMember)
model_rebuild(Task)
model_rebuild(ProjectCompany)
model_rebuild(ProjectContact)
model_rebuild(Document)
model_rebuild(ProjectDocument)
model_rebuild(AuditLog)
model_rebuild(AgentFile)
model_rebuild(AgentUserVectorStore)
model_rebuild(UserRule)
model_rebuild(EmailIndexingJob)
