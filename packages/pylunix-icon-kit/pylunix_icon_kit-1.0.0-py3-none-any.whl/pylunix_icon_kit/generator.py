import os
import re
import logging
import subprocess
import shutil
from xml.dom import minidom
from xml.etree.ElementTree import Element, SubElement, tostring
from typing import Union, Set, List 

logger = logging.getLogger(__name__)

class IconGenerator:
    """
    Tool for generating Qt Resource Files (.qrc) and PyQt/PySide icon access classes.
    """
    def __init__(self, base_dir: str, icons_dir: str, output_dir: str = None):
        self.base_dir = os.path.abspath(base_dir)
        self.icons_dir = os.path.abspath(icons_dir)
        self.output_dir_hint = output_dir 
        self.output_dir = None

    def resolve_output_dir(self, output_dir: Union[str, None], theme_name: str) -> str:
        """Resolves and creates the output directory, using the theme name to create the kit folder."""
        if output_dir:
            out_dir = os.path.abspath(output_dir)
        else:
            kit_name = f"{theme_name}_icon_kit"
            out_dir = os.path.join(self.icons_dir, kit_name)

        if not os.path.exists(out_dir):
            os.makedirs(out_dir, exist_ok=True)
            logger.info(f"Add Output Folder: {out_dir}")
        
        return out_dir
    
    def rename_output_dir(self, output_dir: str, new_name: str) -> str:
        """Renames the output directory."""
        try:
            if not os.path.exists(output_dir):
                raise FileNotFoundError(f"Can't find folder: {output_dir}") 
            parent_dir = os.path.dirname(output_dir)
            new_dir = os.path.join(parent_dir, new_name)
            if os.path.exists(new_dir):
                logger.warning(f"Folder already exists, deleting: {new_dir}")
                shutil.rmtree(new_dir)
            os.rename(output_dir, new_dir)
            logger.info(f"Rename Folder : {output_dir} â†’ {new_dir}")
            return new_dir
        except FileNotFoundError as e:
            logger.error("Error: %s", e)
            raise
        except Exception as e:
            logger.error("Error: %s", e)
            raise

    def sanitize_name(self, name: str, used_names: Set[str]) -> str:
        """Converts file name to a valid Python constant name and handles duplicates."""
        base = os.path.splitext(name)[0]
        base = re.sub(r"[^a-zA-Z0-9]+", "_", base).upper() 
        if not base:
            base = "ICON" 
        if base[0].isdigit():
            base = "_" + base 
            
        new_name = base
        counter = 2
        while new_name in used_names:
            new_name = f"{base}_{counter}"
            counter += 1
            
        used_names.add(new_name)
        return new_name

    def generate_qrc(self, theme_name: str, theme_dir: str, output_qrc_path: str) -> bool:
        """
        Generates the .qrc resource file. The resource paths are relative to the .qrc file itself.
        """
        logger.info(f"[{theme_name}] Generating .qrc...")
        rcc = Element("RCC")
        qresource = SubElement(rcc, "qresource", prefix="/") 
        found_any = False
        
        qrc_base_dir = self.output_dir
        
        for root, _, files in os.walk(theme_dir):
            for file in files:
                if file.lower().endswith((".svg", ".png", ".ico")):
                    full_path = os.path.join(root, file)
                    
                    rel_path_to_qrc = os.path.relpath(full_path, qrc_base_dir).replace("\\", "/") 
                    
                    SubElement(qresource, "file").text = rel_path_to_qrc
                    logger.info(f" + {rel_path_to_qrc}")
                    found_any = True

        if not found_any:
            logger.warning(f"[{theme_name}] No icon files (.svg/.png/.ico) found in {theme_dir}. Skipping .qrc generation.")
            return False

        xml_str = tostring(rcc, encoding="utf-8").decode("utf-8")
        dom = minidom.parseString(xml_str)
        pretty_xml = "\n".join(dom.toprettyxml(indent="    ").splitlines()[1:]) 
        with open(output_qrc_path, "w", encoding="utf-8") as f:
            f.write(pretty_xml)
        logger.info(f"[{theme_name}] .qrc generated at {output_qrc_path}")
        return True

    def generate_icon_class(self, theme_name: str, theme_dir: str):
        """
        Generates the Python icon accessor class, using the QRC resource path key.
        """
        class_name = f"{theme_name.capitalize()}Icon"
        output_path = os.path.join(self.output_dir, f"{theme_name}_icon.py")
        logger.info(f"[{theme_name}] Generating icon class: {class_name} -> {output_path}")

        used_names: Set[str] = set()
        rc_module_name = f"resources_{theme_name}_rc"
        
        lines = [
            "# Auto-generated by pylunix_icon_gen - Do not edit manually", 
            "",
            "from PyQt5.QtGui import QIcon, QPixmap, QColor, QPainter",
            "from PyQt5.QtSvg import QSvgRenderer",
            "from PyQt5.QtCore import QSize, Qt",
            "",
            f"from . import {rc_module_name}", 
            "",
            "class IconAccessor(str):",
            "    def __call__(self, color: str = None, size: QSize = QSize(16,16)) -> QIcon:",
            "        if color is None or not self.lower().endswith('.svg'):",
            "            return QIcon(self)",
            "        renderer = QSvgRenderer(self)",
            "        pixmap = QPixmap(size)",
            "        pixmap.fill(Qt.transparent)",
            "        painter = QPainter(pixmap)",
            "        renderer.render(painter)",
            "        painter.setCompositionMode(QPainter.CompositionMode_SourceIn)",
            "        painter.fillRect(pixmap.rect(), QColor(color))",
            "        painter.end()",
            "        return QIcon(pixmap)",
            "",
            "class ThemeIconMeta(type):",
            "    def __new__(mcs, name, bases, attrs):",
            "        new_attrs = {}",
            "        for key, value in attrs.items():",
            "            if isinstance(value, str) and value.startswith(':/'):",
            "                new_attrs[key] = IconAccessor(value)",
            "            else:",
            "                new_attrs[key] = value",
            "        return super().__new__(mcs, name, bases, new_attrs)",
            "",
            f"class {class_name}(metaclass=ThemeIconMeta):",
            f"    \"\"\"Auto-generated icons for the '{theme_name}' theme. Generated by pylunix_icon_gen.\"\"\"",
        ]

        has_any = False
        
        for root, _, files in os.walk(theme_dir):
            for file in sorted(files):
                if file.lower().endswith((".svg", ".png", ".ico")):
                    const_name = self.sanitize_name(file, used_names)
                    
                    full_path = os.path.join(root, file)
                    rel_path_to_qrc = os.path.relpath(full_path, self.icons_dir).replace("\\", "/")
                    
                    lines.append(f"    {const_name} = IconAccessor(':{rel_path_to_qrc}')") 
                    has_any = True

        if not has_any:
            lines.append("    pass")

        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))

        logger.info(f"[{theme_name}] Icon class generated at {output_path}")

    def _generate_package_inits(self, theme_folders: List[str]):
        """Generates the __init__.py files for the icons directory and the kit directory."""
        
        kit_init_path = os.path.join(self.output_dir, "__init__.py")
        if not os.path.exists(kit_init_path):
            with open(kit_init_path, "w", encoding="utf-8") as f:
                f.write("")
            logger.info(f"Generated empty __init__.py in: {self.output_dir}")

        icons_init_path = os.path.join(self.icons_dir, "__init__.py")
        
        init_lines = [
            "# Auto-generated icons package __init__",
            "",
        ]
        
        kit_dir_name_rel = os.path.basename(self.output_dir) 
        
        all_imports: List[str] = []
        all_exports: List[str] = []
        
        for theme_name in theme_folders:
            class_name = f"{theme_name.capitalize()}Icon"
            icon_module_name = f"{theme_name}_icon" 
            
            import_line = f"from .{kit_dir_name_rel}.{icon_module_name} import {class_name}"
            all_imports.append(import_line)
            all_exports.append(f'"{class_name}"')
            
        init_lines.extend(all_imports)
        init_lines.append("")
        init_lines.append(f"__all__ = [{', '.join(all_exports)}]")
        
        with open(icons_init_path, "w", encoding="utf-8") as f:
            f.write("\n".join(init_lines))
        logger.info(f"Generated icons package __init__.py in: {self.icons_dir}")


    def compile_qrc(self, input_qrc: str, output_py: str):
        """Compiles the .qrc file into a Python resource module (.py)."""
        if not os.path.exists(input_qrc):
            logger.warning(f"QRC file not found: {input_qrc}, skipping compilation.")
            return
        
        logger.info(f"Compiling {input_qrc} -> {output_py}")
        try:
            subprocess.run(["pyrcc5", input_qrc, "-o", output_py], check=True, cwd=self.base_dir)
        except Exception as e:
            logger.error(f"Failed to compile QRC. Is 'pyrcc5' installed and accessible? Error: {e}")

    def generate_all_themes(self, clean_first: bool = False):
        """Generates all themes and creates __init__.py files."""
        if clean_first:
            self.clean_previous_generated(confirm_delete=False)
        
        theme_folders: List[str] = [
            d for d in os.listdir(self.icons_dir)
            if os.path.isdir(os.path.join(self.icons_dir, d)) and not d.startswith("__")
        ]
        
        if not theme_folders:
            logger.warning(f"No valid theme folders found in {self.icons_dir}. Aborting generation.")
            return
            
        first_theme_name = theme_folders[0]
        
        if not self.output_dir_hint:
            self.output_dir = self.resolve_output_dir(None, first_theme_name)
        else:
            self.output_dir = os.path.abspath(self.output_dir_hint)
            logger.info(f"Using specified output folder: {self.output_dir}")

        
        for theme_folder in theme_folders:
            theme_dir = os.path.join(self.icons_dir, theme_folder)
            theme_name = theme_folder
            
            qrc_path = os.path.join(self.output_dir, f"resources_{theme_name}.qrc")
            rcc_py = os.path.join(self.output_dir, f"resources_{theme_name}_rc.py")
            
            # 1. Generate QRC file
            if self.generate_qrc(theme_name, theme_dir, qrc_path):
                # 2. Compile QRC file
                self.compile_qrc(qrc_path, rcc_py)
            
            # 3. Generate Python icon class
            self.generate_icon_class(theme_name, theme_dir)

        # 4. Generate package __init__.py files
        self._generate_package_inits(theme_folders)

    def clean_previous_generated(self, confirm_delete: bool = True):
        """Cleans up previously generated files."""
        removed_files: List[str] = []
        
        for theme_folder in os.listdir(self.icons_dir):
            theme_dir = os.path.join(self.icons_dir, theme_folder)
            if not os.path.isdir(theme_dir) or theme_folder.startswith("__"):
                continue
            
            theme_name = theme_folder
            kit_dir_name = f"{theme_name}_icon_kit"
            kit_dir = os.path.join(self.icons_dir, kit_dir_name)
            
            if os.path.exists(kit_dir) and kit_dir != self.output_dir:
                logger.info(f"Deleting generated kit folder: {kit_dir}")
                try:
                    shutil.rmtree(kit_dir)
                except Exception as e:
                    logger.error(f"Failed to delete kit folder {kit_dir}: {e}")
                continue
                
            current_output_dir = self.output_dir or kit_dir
            if current_output_dir and os.path.exists(current_output_dir):
                qrc_file = os.path.join(current_output_dir, f"resources_{theme_name}.qrc") 
                rc_file = os.path.join(current_output_dir, f"resources_{theme_name}_rc.py")
                icon_file = os.path.join(current_output_dir, f"{theme_name}_icon.py")

                for f in [qrc_file, rc_file, icon_file]:
                    if os.path.exists(f):
                        removed_files.append(f)
        
        icons_init = os.path.join(self.icons_dir, "__init__.py")
        if os.path.exists(icons_init):
            removed_files.append(icons_init)


        if not removed_files:
            logger.info("No previous generated files detected.")
            return

        for f in removed_files:
            try:
                os.remove(f)
                logger.info(f"Deleted: {f}")
            except Exception as e:
                logger.error(f"Failed to delete {f}: {e}")