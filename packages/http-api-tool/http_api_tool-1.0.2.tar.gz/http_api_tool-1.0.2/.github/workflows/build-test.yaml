---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: 'Build/Test and Publish Docker Image'

on:
  workflow_dispatch:
    inputs:
      bust_cache:
        description: 'Bust Docker build cache (forces fresh build)'
        required: false
        type: boolean
        default: false
      purge_all_caches:
        description: 'Purge ALL GitHub Actions caches for this repository'
        required: false
        type: boolean
        default: false
  push:
    branches: [ 'main' ]
  pull_request:
    branches: [ 'main' ]

permissions: {}

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Purge all caches if requested via workflow_dispatch
  purge-caches:
    name: "Purge All Caches"
    if: github.event_name == 'workflow_dispatch' && inputs.purge_all_caches == true
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      actions: write
    steps:
      - name: Purge all GitHub Actions caches
        run: |
          echo "ðŸ—‘ï¸ Purging all GitHub Actions caches for this repository..."

          # Get all cache keys using GitHub API
          REPO="${{ github.repository }}"

          echo "Fetching cache list..."
          gh api -X GET "/repos/$REPO/actions/caches" --paginate | \
            jq -r '.actions_caches[].id' | \
            while read -r cache_id; do
              echo "Deleting cache ID: $cache_id"
              gh api -X DELETE "/repos/$REPO/actions/caches/$cache_id" || true
            done

          echo "âœ… All caches purged successfully"
        env:
          GH_TOKEN: ${{ github.token }}

  # Build Docker image with comprehensive caching
  docker-build:
    needs: [purge-caches]
    if: always() && (needs.purge-caches.result == 'success' || needs.purge-caches.result == 'skipped')
    name: "Build Docker Image"
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
    outputs:
      image-tag: ${{ steps.build.outputs.imageid }}

    steps:
      # Harden the runner
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Set up Docker Buildx with caching
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      # Build Docker image with registry cache
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: false
          load: true
          tags: http-api-tool:test
          build-args: |
            VERSION=0.0.0.dev0
          cache-from: |
            # yamllint disable-line rule:line-length
            ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true && 'type=gha,scope=docker-build-never-exists' || 'type=gha,scope=docker-build' }}
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-base
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-deps
          cache-to: type=gha,mode=max,scope=docker-build
          no-cache: ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true }}
          labels: |
            org.opencontainers.image.title=HTTP API Tool
            org.opencontainers.image.description=A Python HTTP/HTTPS API testing tool
            org.opencontainers.image.vendor=The Linux Foundation

      # Test basic image functionality
      - name: Test Docker image help
        run: |
          docker run --rm http-api-tool:test --help

  # Integration tests
  integration-tests:
    name: "Integration Tests"
    runs-on: ubuntu-latest
    needs: docker-build
    timeout-minutes: 15
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Set up go-httpbin for testing
      - name: Setup go-httpbin HTTPS service
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        id: go-httpbin
        with:
          debug: 'true'
          port: '8080'

      # Test 1: Basic GET request
      - name: Test Basic GET request
        uses: ./
        with:
          url: 'https://${{ steps.go-httpbin.outputs.host-gateway-ip }}:8080/get'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true
          expected_http_code: 200

      # Test 2: POST request with JSON
      - name: Test POST request with JSON
        uses: ./
        with:
          url: 'https://${{ steps.go-httpbin.outputs.host-gateway-ip }}:8080/post'
          http_method: 'POST'
          request_body: '{"test": "data", "number": 42}'
          content_type: 'application/json'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true
          expected_http_code: 200

      # Test 3: Custom headers
      - name: Test Custom headers
        uses: ./
        with:
          url: 'https://${{ steps.go-httpbin.outputs.host-gateway-ip }}:8080/headers'
          request_headers: '{"X-Test-Header": "test-value", "X-API-Key": "secret123"}'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true
          expected_http_code: 200

      # Test 4: Error handling (404)
      - name: Test Error handling (404)
        uses: ./
        with:
          url: 'https://${{ steps.go-httpbin.outputs.host-gateway-ip }}:8080/status/404'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true
          expected_http_code: 404

      # Test 5: Error handling (500)
      - name: Test Error handling (500)
        uses: ./
        with:
          url: 'https://${{ steps.go-httpbin.outputs.host-gateway-ip }}:8080/status/500'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true
          expected_http_code: 500

      # Clean up is handled automatically by the go-httpbin action

  # Publish to GHCR (only after successful tests)
  docker-publish:
    name: "Publish to GHCR"
    runs-on: ubuntu-latest
    needs: [docker-build, integration-tests]
    if: github.event_name != 'pull_request'
    timeout-minutes: 10
    permissions:
      contents: read
      packages: write

    steps:
      # Harden the runner
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      # Login to GitHub Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Extract metadata for tags and labels
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893 # v5.9.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=HTTP API Tool
            org.opencontainers.image.description=A Python HTTP/HTTPS API testing tool for GitHub Actions and CLI usage
            org.opencontainers.image.vendor=The Linux Foundation

      # Build and push image with comprehensive caching
      - name: Build and push Docker image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=0.0.0.dev0
          cache-from: |
            # yamllint disable-line rule:line-length
            ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true && 'type=gha,scope=docker-publish-never-exists' || 'type=gha,scope=docker-publish' }}
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-base
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-deps
          no-cache: ${{ github.event_name == 'workflow_dispatch' && inputs.bust_cache == true }}
          cache-to: |
            type=gha,mode=max,scope=docker-publish
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-base,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-deps,mode=max

      - name: Verify published image
        run: |
          echo "Image published successfully to GHCR"
          echo "Tags: ${{ steps.meta.outputs.tags }}"

  # Python build for additional testing (runs in parallel with container pipeline)
  python-build:
    name: 'Python Build'
    runs-on: 'ubuntu-latest'
    outputs:
      matrix_json: "${{ steps.python-build.outputs.matrix_json }}"
      artefact_name: "${{ steps.python-build.outputs.artefact_name }}"
      artefact_path: "${{ steps.python-build.outputs.artefact_path }}"
    permissions:
      contents: read
    timeout-minutes: 12
    env:
      GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with enhanced caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies
      - name: Cache PDM dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/pdm
            .pdm-python
            .venv
          key: pdm-${{ runner.os }}-python-3.11-${{ hashFiles('pyproject.toml', 'pdm.lock') }}
          restore-keys: |
            pdm-${{ runner.os }}-python-3.11-
            pdm-${{ runner.os }}-

      - name: 'Build Python project'
        id: python-build
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-build-action@48381cece78a990a6ba93bd5924bcd40bf0d1a7d # v0.1.20

  # Python tests with matrix strategy (after container pipeline)
  python-tests:
    name: 'Python Tests'
    runs-on: 'ubuntu-latest'
    needs: [integration-tests, python-build]
    # Matrix job
    strategy:
      fail-fast: false
      matrix: "${{ fromJson(needs.python-build.outputs.matrix_json) }}"
    permissions:
      contents: read
    timeout-minutes: 12
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies for test environment
      - name: Cache PDM test dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/pdm
            .pdm-python
            .venv
          # yamllint disable-line rule:line-length
          key: pdm-test-${{ runner.os }}-python-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml', 'pdm.lock') }}
          restore-keys: |
            pdm-test-${{ runner.os }}-python-${{ matrix.python-version }}-
            pdm-test-${{ runner.os }}-

      - name: "Python tests [pytest] ${{ matrix.python-version }}"
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-test-action@b997656111c9b547f8458b18baf6be139e2d2c6c # v0.1.12
        with:
          python_version: ${{ matrix.python-version }}

  # Python dependency auditing (after container pipeline)
  python-audit:
    name: 'Python Audit'
    runs-on: 'ubuntu-latest'
    needs: [integration-tests, python-build]
    # Matrix job
    strategy:
      fail-fast: false
      matrix: "${{ fromJson(needs.python-build.outputs.matrix_json) }}"
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies for audit environment
      - name: Cache PDM audit dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/pdm
            .pdm-python
            .venv
          # yamllint disable-line rule:line-length
          key: pdm-audit-${{ runner.os }}-python-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml', 'pdm.lock') }}
          restore-keys: |
            pdm-audit-${{ runner.os }}-python-${{ matrix.python-version }}-
            pdm-audit-${{ runner.os }}-

      - name: "Audit dependencies ${{ matrix.python-version }}"
        # yamllint disable-line rule:line-length
        uses: lfreleng-actions/python-audit-action@d2a271bdbf08572dbd8addd3358e5e937ab3739b # v0.2.3
        with:
          python_version: "${{ matrix.python-version }}"

  # Makefile tests (after container pipeline)
  makefile-tests:
    name: 'Makefile Tests'
    runs-on: ubuntu-latest
    needs: [integration-tests, python-build]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies for makefile tests
      - name: Cache PDM makefile dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/pdm
            .pdm-python
            .venv
          key: pdm-makefile-${{ runner.os }}-python-3.11-${{ hashFiles('pyproject.toml', 'pdm.lock') }}
          restore-keys: |
            pdm-makefile-${{ runner.os }}-python-3.11-
            pdm-makefile-${{ runner.os }}-

      - name: Install PDM
        run: |
          # Generate PDM requirements with complete dependency tree and hashes
          python3 scripts/generate_requirements.py \
            --platform linux_x86_64 \
            --python-version 311 \
            --output /tmp/pdm-requirements.txt \
            --comment "PDM with complete dependency tree" \
            pdm==2.24.2
          pip install --require-hashes -r /tmp/pdm-requirements.txt

      - name: Test Makefile targets
        run: |
          # Test basic make targets
          make install-test
          make test

          # Test help target
          make help

      - name: Test make docker-build
        run: |
          # Test Docker build via Makefile
          make docker-build

  # CLI integration tests (after container pipeline)
  cli-tests:
    name: 'CLI Integration Tests'
    runs-on: ubuntu-latest
    needs: [integration-tests, python-build]
    permissions:
      contents: read
    timeout-minutes: 15
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with comprehensive caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies for CLI tests
      - name: Cache PDM CLI dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ~/.cache/pdm
            .pdm-python
            .venv
          key: pdm-cli-${{ runner.os }}-python-3.11-${{ hashFiles('pyproject.toml', 'pdm.lock') }}
          restore-keys: |
            pdm-cli-${{ runner.os }}-python-3.11-
            pdm-cli-${{ runner.os }}-

      - name: Install PDM and dependencies
        run: |
          # Generate PDM requirements with complete dependency tree and hashes
          python3 scripts/generate_requirements.py \
            --platform linux_x86_64 \
            --python-version 311 \
            --output /tmp/pdm-requirements.txt \
            --comment "PDM with complete dependency tree" \
            pdm==2.24.2
          pip install --require-hashes -r /tmp/pdm-requirements.txt
          pdm install -G test

      - name: Test CLI help and version
        run: |
          # Test CLI help
          pdm run python -m http_api_tool --help

          # Test specific command help
          pdm run python -m http_api_tool test --help

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      - name: Test CLI with various scenarios
        run: |
          # Use the HTTPS service URL and CA bundle from the go-httpbin action
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          CA_BUNDLE="${{ steps.go-httpbin.outputs.ca-cert-path }}"

          echo "Testing with service URL: $SERVICE_URL"
          echo "Using CA bundle: $CA_BUNDLE"

          # Test basic GET request
          pdm run python -m http_api_tool test \
            --url "$SERVICE_URL/get" \
            --http-method GET \
            --expected-http-code 200 \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug \
            --retries 3

          # Test POST request with JSON
          pdm run python -m http_api_tool test \
            --url "$SERVICE_URL/post" \
            --http-method POST \
            --expected-http-code 200 \
            --request-body '{"test": "data"}' \
            --content-type "application/json" \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug

          # Test with headers
          pdm run python -m http_api_tool test \
            --url "$SERVICE_URL/headers" \
            --http-method GET \
            --expected-http-code 200 \
            --request-headers '{"X-Custom-Header": "test-value"}' \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug

          # Test with authentication (if supported)
          pdm run python -m http_api_tool test \
            --url "$SERVICE_URL/basic-auth/user/pass" \
            --http-method GET \
            --expected-http-code 401 \
            --ca-bundle-path "$CA_BUNDLE" \
            --debug || echo "Expected 401 for unauth request"

      - name: Test CLI error handling
        run: |
          # Test with invalid URL (should fail gracefully)
          pdm run python -m http_api_tool test \
            --url "https://localhost:9999/nonexistent" \
            --http-method GET \
            --expected-http-code 200 \
            --retries 1 \
            --debug || echo "Expected failure for invalid URL"

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # GitHub Action functionality tests (after container pipeline)
  action-tests:
    name: 'GitHub Action Tests'
    runs-on: ubuntu-latest
    needs: [integration-tests]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      - name: Test GitHub Action (local)
        uses: ./
        with:
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'HTTPBin Test Service'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      - name: Test GitHub Action with POST
        uses: ./
        with:
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'HTTPBin POST Test'
          http_method: 'POST'
          expected_http_code: 200
          request_body: '{"test": "data"}'
          content_type: 'application/json'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'

      - name: Test GitHub Action error handling
        uses: ./
        continue-on-error: true
        with:
          url: 'https://localhost:9999/nonexistent'
          service_name: 'Non-existent Service'
          expected_http_code: 200
          retries: 1

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Test deployment modes (uvx vs docker) to verify localhost URL handling
  deployment-mode-tests:
    name: 'Deployment Mode Tests (uvx vs docker)'
    runs-on: ubuntu-latest
    needs: [integration-tests]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner used by this workflow
      - uses: step-security/harden-runner@f4a75cfd619ee5ce8d5b864b0d183aff3c69b55a # v2.13.1
        with:
          egress-policy: 'audit'

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'
          skip-readiness-check: 'true'

      - name: Verify service URL uses localhost
        run: |
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          echo "Service URL: $SERVICE_URL"
          if [[ "$SERVICE_URL" != *"localhost"* ]]; then
            echo "ERROR: Service URL should contain 'localhost' for host-based testing"
            exit 1
          fi
          echo "âœ… Service URL correctly uses localhost"

      - name: Test uvx deployment (default) with localhost URL
        uses: ./
        with:
          deploy: 'uvx'
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'UVX Deployment Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test uvx deployment should NOT transform localhost URLs
        run: |
          echo "Testing that uvx mode does not transform localhost to gateway IP"
          # The uvx test above should have succeeded without transformation
          echo "âœ… UVX mode correctly keeps localhost URLs unchanged"

      - name: Test docker deployment with localhost URL
        uses: ./
        with:
          deploy: 'docker'
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'Docker Deployment Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test docker deployment transforms localhost URLs
        run: |
          echo "Docker mode should transform localhost URLs to gateway IP when in container"
          echo "âœ… Docker mode handled localhost URL transformation correctly"

      - name: Derive 127.0.0.1 URL from service URL
        id: derive-ip-url
        run: |
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          # Replace localhost with 127.0.0.1 to test IP-based access
          IP_URL="${SERVICE_URL//localhost/127.0.0.1}"
          echo "ip-url=${IP_URL}" >> "$GITHUB_OUTPUT"
          echo "Derived IP URL: ${IP_URL}"

      - name: Test uvx deployment with explicit 127.0.0.1
        uses: ./
        with:
          deploy: 'uvx'
          url: '${{ steps.derive-ip-url.outputs.ip-url }}/get'
          service_name: 'UVX 127.0.0.1 Test'
          expected_http_code: 200
          retries: 3
          initial_sleep_time: 1
          verify_ssl: 'false'
          debug: 'true'

      - name: Test uvx with POST request
        uses: ./
        with:
          deploy: 'uvx'
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'UVX POST Test'
          http_method: 'POST'
          request_body: '{"deployment": "uvx", "test": "localhost_handling"}'
          content_type: 'application/json'
          expected_http_code: 200
          verify_ssl: 'false'
          debug: 'true'

      - name: Verify both deployment modes work
        run: |
          echo "=== Deployment Mode Test Summary ==="
          echo "âœ… UVX mode: Works with localhost URLs (no transformation)"
          echo "âœ… Docker mode: Works with localhost URLs (transforms to gateway IP in container)"
          echo "âœ… Both modes successfully connect to Docker-mapped ports"
          echo ""
          echo "This test prevents regressions in localhost URL handling between deployment modes"

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Docker integration test for PRs (using GitHub Action instead of Docker CLI)
  docker-integration-test-pr:
    name: 'Docker Integration Test (PR)'
    runs-on: ubuntu-latest
    needs: [integration-tests, python-tests, python-audit, makefile-tests, cli-tests, action-tests]
    if: github.event_name == 'pull_request'
    permissions:
      contents: read
    timeout-minutes: 15

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      # Test Docker integration via GitHub Action (no Docker CLI dependency)
      - name: Test Docker integration via GitHub Action
        uses: ./
        with:
          url: '${{ steps.go-httpbin.outputs.service-url }}/get'
          service_name: 'Docker Integration Test (PR)'
          expected_http_code: 200
          retries: 3
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true

      # Test additional Docker integration scenarios via GitHub Action
      - name: Test Docker integration with POST
        uses: ./
        with:
          url: '${{ steps.go-httpbin.outputs.service-url }}/post'
          service_name: 'Docker Integration POST Test (PR)'
          http_method: 'POST'
          expected_http_code: 200
          request_body: '{"integration": "test", "pr": true}'
          content_type: 'application/json'
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true

      # Test Docker integration with custom headers
      - name: Test Docker integration with headers
        uses: ./
        with:
          url: '${{ steps.go-httpbin.outputs.service-url }}/headers'
          service_name: 'Docker Integration Headers Test (PR)'
          request_headers: '{"X-Integration-Test": "docker-pr", "X-Test-Type": "headers"}'
          expected_http_code: 200
          ca_bundle_path: '${{ steps.go-httpbin.outputs.ca-cert-path }}'
          debug: true

      # Clean up test containers
      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Comprehensive Docker integration tests (after container pipeline and all other tests)
  docker-integration-test:
    name: 'Docker Integration Test'
    runs-on: ubuntu-latest
    needs: [docker-publish, python-tests, python-audit, makefile-tests, cli-tests, action-tests]
    if: github.event_name != 'pull_request'
    permissions:
      contents: read
      packages: read
    timeout-minutes: 15

    steps:
      # Harden the runner used by this workflow
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1

      # Login to Container Registry
      - name: Login to Container Registry
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Test Docker image functionality
      - name: Test Docker image functionality
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "Testing published image: $IMAGE_TAG"

          # Test basic help command
          docker run --rm "$IMAGE_TAG" --help

      # Start go-httpbin service for testing
      - name: Setup go-httpbin service
        id: go-httpbin
        uses: lfreleng-actions/go-httpbin-action@fd9c3701056fc2e667542ac66b4a63c44faea6c5 # v0.1.0
        with:
          port: '8080'
          debug: 'true'

      - name: Test Docker image with go-httpbin
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "Using image tag: $IMAGE_TAG"

          # Get service URL and CA bundle from go-httpbin action
          SERVICE_URL="${{ steps.go-httpbin.outputs.service-url }}"
          CA_BUNDLE="${{ steps.go-httpbin.outputs.ca-cert-path }}"

          # Test the http-api-tool against go-httpbin with HTTPS
          docker run --rm --network host \
            -v "$GITHUB_WORKSPACE/$CA_BUNDLE:/tmp/ca-bundle.pem:ro" \
            "$IMAGE_TAG" \
            test \
            --url "$SERVICE_URL/get" \
            --ca-bundle-path "/tmp/ca-bundle.pem" \
            --debug \
            --retries 3

      - name: Clean up test containers
        if: always()
        run: |
          docker rm -f go-httpbin || true

  # Security scan job
  security-scan:
    name: 'Security Scan'
    runs-on: ubuntu-latest
    needs: [python-build]
    permissions:
      contents: read
    timeout-minutes: 10
    steps:
      # Harden the runner
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0

      # Setup Python with caching
      - name: Set up Python
        uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
        with:
          python-version: '3.10'
          cache: 'pip'
          cache-dependency-path: |
            requirements-docker.txt
            pyproject.toml

      # Cache PDM dependencies
      - name: Cache PDM dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
        with:
          path: |
            ./.venv
            ~/.cache/pip
            ~/.cache/pdm
          key: ${{ runner.os }}-security-scan-deps-${{ hashFiles('**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-security-scan-deps-
            ${{ runner.os }}-security-scan-

      # Install security tools
      - name: Install security scanning tools
        run: |
          # Ensure we have a recent version of pip that supports --hash properly
          VERSION=$(pip --version)
          echo "Using pip version: $VERSION"

          # Generate requirements file with complete dependency tree and hashes
          echo "Generating security tools requirements with all transitive dependencies..."
          python3 scripts/generate_requirements.py \
            --platform linux_x86_64 \
            --python-version 310 \
            --output /tmp/security-requirements.txt \
            --comment "Security scanning tools with complete dependency tree" \
            safety==3.6.0 \
            bandit==1.8.3 \
            pip-audit==2.7.3

          # Install security tools with hash verification using requirements file
          echo "Installing security tools with hash verification..."
          pip install --require-hashes -r /tmp/security-requirements.txt

      # Check pip install security (SHA pinning)
      - name: Check pip install commands for SHA hash pinning
        run: |
          echo "::group::Pip Install Security Check"
          python3 scripts/check-pip-security.py
          echo "::endgroup::"

      # Run safety check
      - name: Run safety check
        run: |
          echo "::group::Safety Dependency Check"
          safety check --full-report
          echo "::endgroup::"
        continue-on-error: true

      # Run bandit
      - name: Run bandit static code analysis
        run: |
          echo "::group::Bandit Static Analysis"
          bandit -r src/ -c pyproject.toml -ll
          echo "::endgroup::"

      # Run pip-audit
      - name: Run pip-audit for vulnerabilities
        run: |
          echo "::group::Pip Audit"
          pip-audit -r requirements-docker.txt || true
          pip-audit -f json -r requirements-docker.txt > security-report.json || true
          echo "::endgroup::"
        continue-on-error: true

      # Check for specific vulnerabilities
      - name: Check for known vulnerabilities
        run: |
          echo "::group::Targeted Vulnerability Check"

          # Check for MongoDB driver vulnerability (GHSA-48p4-8xcf-vxj5)
          echo "Checking for MongoDB driver vulnerability (GHSA-48p4-8xcf-vxj5)..."
          if pip list | grep -i mongodb; then
            echo "::warning::MongoDB driver detected - check version for GHSA-48p4-8xcf-vxj5 vulnerability"
          else
            echo "MongoDB driver not found - not vulnerable to GHSA-48p4-8xcf-vxj5"
          fi

          # Check for Request package vulnerability (GHSA-pq67-6m6q-mj2v)
          echo "Checking for Request package vulnerability (GHSA-pq67-6m6q-mj2v)..."
          if pip list | grep -i requests; then
            # The vulnerability affects all versions of the deprecated 'request' package
            # Warn if it's being used directly in production code
            # yamllint disable-line rule:line-length
            if grep -r "import requests" src/ --include="*.py" || grep -r "from requests" src/ --include="*.py"; then
              # yamllint disable-line rule:line-length
              echo "::warning::Requests package is directly imported in code - check usage patterns for SSRF vulnerabilities"
            else
              echo "Requests package is a dependency but not directly imported - lower risk"
            fi
          else
            echo "Requests package not found - not vulnerable to GHSA-pq67-6m6q-mj2v"
          fi

          echo "::endgroup::"
