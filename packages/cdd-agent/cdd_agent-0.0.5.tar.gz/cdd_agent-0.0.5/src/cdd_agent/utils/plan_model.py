"""Implementation plan data models.

This module provides data structures for representing and managing
implementation plans generated by the Planner Agent.
"""

import json
import re
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional


@dataclass
class PlanStep:
    """Single implementation step in a plan.

    Attributes:
        number: Step number (1-indexed)
        title: Short step title
        description: Detailed step description
        complexity: Complexity level (simple/medium/complex)
        estimated_time: Time estimate (e.g., "30 min", "2 hours")
        dependencies: List of step numbers this depends on
        files_affected: List of file paths that will be modified
    """

    number: int
    title: str
    description: str
    complexity: str = "medium"
    estimated_time: str = "1 hour"
    dependencies: list[int] = field(default_factory=list)
    files_affected: list[str] = field(default_factory=list)

    def __post_init__(self):
        """Validate step data."""
        valid_complexities = ["simple", "medium", "complex"]
        if self.complexity not in valid_complexities:
            raise ValueError(
                f"Invalid complexity '{self.complexity}'. "
                f"Must be one of: {', '.join(valid_complexities)}"
            )


@dataclass
class ImplementationPlan:
    """Complete implementation plan for a ticket.

    Attributes:
        ticket_slug: Ticket identifier (e.g., "feature-user-auth")
        ticket_title: Human-readable ticket title
        ticket_type: Ticket type (feature/bug/refactor/etc)
        overview: High-level implementation approach
        steps: List of implementation steps
        total_complexity: Overall complexity assessment
        total_estimated_time: Total time estimate
        risks: List of potential risks/challenges
        created_at: Plan creation timestamp
    """

    ticket_slug: str
    ticket_title: str
    ticket_type: str
    overview: str
    steps: list[PlanStep]
    total_complexity: str = "medium"
    total_estimated_time: str = "4 hours"
    risks: list[str] = field(default_factory=list)
    created_at: Optional[str] = None

    def __post_init__(self):
        """Set creation timestamp if not provided."""
        if not self.created_at:
            self.created_at = datetime.now().strftime("%Y-%m-%d")

    def to_markdown(self) -> str:
        """Convert plan to markdown format.

        Returns:
            Formatted markdown string

        Example:
            >>> plan.to_markdown()
            '# Implementation Plan: User Authentication\\n...'
        """
        md = f"""# Implementation Plan: {self.ticket_title}

**Ticket:** `{self.ticket_slug}`
**Type:** {self.ticket_type}
**Complexity:** {self.total_complexity}
**Estimated Time:** {self.total_estimated_time}
**Created:** {self.created_at}

---

## Overview

{self.overview}

---

## Implementation Steps

"""

        for step in self.steps:
            deps = (
                ", ".join(f"Step {d}" for d in step.dependencies)
                if step.dependencies
                else "None"
            )

            files_section = ""
            if step.files_affected:
                files_section = "**Files Affected:**\n"
                for file_path in step.files_affected:
                    files_section += f"- `{file_path}`\n"
            else:
                files_section = "**Files Affected:** None specified\n"

            md += f"""### Step {step.number}: {step.title}

**Description:** {step.description}

**Complexity:** {step.complexity}
**Estimated Time:** {step.estimated_time}
**Dependencies:** {deps}

{files_section}
---

"""

        if self.risks:
            md += "## Risks & Considerations\n\n"
            for risk in self.risks:
                md += f"- {risk}\n"
            md += "\n---\n\n"

        md += f"""## Next Steps

To execute this plan:

```bash
/exec {self.ticket_slug}
```

---

*Generated by Planner Agent on {self.created_at}*
"""

        return md

    @classmethod
    def from_markdown(cls, content: str, ticket_slug: str = "") -> "ImplementationPlan":
        """Parse implementation plan from markdown.

        Args:
            content: Markdown content
            ticket_slug: Optional ticket slug (extracted if not provided)

        Returns:
            Parsed ImplementationPlan

        Raises:
            ValueError: If markdown format is invalid
        """
        lines = content.split("\n")

        # Extract metadata
        title = ""
        slug = ticket_slug
        ticket_type = "feature"
        complexity = "medium"
        estimated_time = "4 hours"
        created = datetime.now().strftime("%Y-%m-%d")

        for line in lines[:20]:  # Check first 20 lines for metadata
            if line.startswith("# Implementation Plan:"):
                title = line.replace("# Implementation Plan:", "").strip()
            elif line.startswith("**Ticket:**"):
                slug = line.split("`")[1] if "`" in line else ""
            elif line.startswith("**Type:**"):
                ticket_type = line.split("**Type:**")[1].strip()
            elif line.startswith("**Complexity:**"):
                complexity = line.split("**Complexity:**")[1].strip().lower()
            elif line.startswith("**Estimated Time:**"):
                estimated_time = line.split("**Estimated Time:**")[1].strip()
            elif line.startswith("**Created:**"):
                created = line.split("**Created:**")[1].strip()

        # Extract overview
        overview = ""
        in_overview = False
        for i, line in enumerate(lines):
            if line.strip() == "## Overview":
                in_overview = True
                continue
            if in_overview:
                if line.startswith("##"):
                    break
                if line.strip() and line.strip() != "---":
                    overview += line + "\n"

        overview = overview.strip()

        # Extract steps
        steps = []
        step_pattern = re.compile(r"### Step (\d+): (.+)")
        current_step = None

        for i, line in enumerate(lines):
            match = step_pattern.match(line)
            if match:
                if current_step:
                    steps.append(current_step)

                step_num = int(match.group(1))
                step_title = match.group(2).strip()
                current_step = {
                    "number": step_num,
                    "title": step_title,
                    "description": "",
                    "complexity": "medium",
                    "estimated_time": "1 hour",
                    "dependencies": [],
                    "files_affected": [],
                }
            elif current_step:
                if line.startswith("**Description:**"):
                    current_step["description"] = line.split("**Description:**")[
                        1
                    ].strip()
                elif line.startswith("**Complexity:**"):
                    current_step["complexity"] = (
                        line.split("**Complexity:**")[1].strip().lower()
                    )
                elif line.startswith("**Estimated Time:**"):
                    current_step["estimated_time"] = line.split("**Estimated Time:**")[
                        1
                    ].strip()
                elif line.startswith("**Dependencies:**"):
                    deps_str = line.split("**Dependencies:**")[1].strip()
                    if deps_str.lower() != "none":
                        # Extract step numbers
                        dep_nums = re.findall(r"Step (\d+)", deps_str)
                        current_step["dependencies"] = [int(d) for d in dep_nums]
                elif line.startswith("- `") and "files_affected" in current_step:
                    file_path = line.strip().lstrip("- `").rstrip("`")
                    current_step["files_affected"].append(file_path)

        if current_step:
            steps.append(current_step)

        # Convert step dicts to PlanStep objects
        plan_steps = [PlanStep(**step_dict) for step_dict in steps]

        # Extract risks
        risks = []
        in_risks = False
        for line in lines:
            if line.strip() == "## Risks & Considerations":
                in_risks = True
                continue
            if in_risks:
                if line.startswith("##"):
                    break
                if line.startswith("- "):
                    risks.append(line.lstrip("- ").strip())

        return cls(
            ticket_slug=slug,
            ticket_title=title,
            ticket_type=ticket_type,
            overview=overview,
            steps=plan_steps,
            total_complexity=complexity,
            total_estimated_time=estimated_time,
            risks=risks,
            created_at=created,
        )

    @classmethod
    def from_json(
        cls, json_str: str, ticket_slug: str, ticket_title: str, ticket_type: str
    ) -> "ImplementationPlan":
        """Parse plan from JSON (LLM response format).

        Args:
            json_str: JSON string from LLM
            ticket_slug: Ticket identifier
            ticket_title: Ticket title
            ticket_type: Ticket type

        Returns:
            Parsed ImplementationPlan
        """
        try:
            data = json.loads(json_str)
        except json.JSONDecodeError:
            # Try to extract JSON from markdown code blocks
            json_match = re.search(
                r"```(?:json)?\s*(\{.*?\})\s*```", json_str, re.DOTALL
            )
            if json_match:
                data = json.loads(json_match.group(1))
            else:
                raise ValueError("Invalid JSON format in LLM response")

        # Parse steps
        steps = []
        for step_data in data.get("steps", []):
            steps.append(
                PlanStep(
                    number=step_data.get("number", len(steps) + 1),
                    title=step_data.get("title", ""),
                    description=step_data.get("description", ""),
                    complexity=step_data.get("complexity", "medium"),
                    estimated_time=step_data.get("estimated_time", "1 hour"),
                    dependencies=step_data.get("dependencies", []),
                    files_affected=step_data.get("files_affected", []),
                )
            )

        return cls(
            ticket_slug=ticket_slug,
            ticket_title=ticket_title,
            ticket_type=ticket_type,
            overview=data.get("overview", ""),
            steps=steps,
            total_complexity=data.get("total_complexity", "medium"),
            total_estimated_time=data.get("total_estimated_time", "4 hours"),
            risks=data.get("risks", []),
        )
