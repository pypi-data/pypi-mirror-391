"""
Build HTML documentation from Markdown files.

This module provides functionality to convert markdown files into a single,
self-contained HTML documentation site with navigation and table of contents.
"""

from __future__ import annotations

import html
import sys
from datetime import UTC, datetime
from pathlib import Path
from typing import TYPE_CHECKING

import markdown
from jinja2 import Template

if TYPE_CHECKING:
    from collections.abc import Sequence


def convert_markdown_to_html(md_content: str) -> tuple[str, markdown.Markdown]:
    """
    Convert markdown content to HTML with syntax highlighting and extensions.

    Args:
        md_content: Raw markdown content as string

    Returns:
        Tuple containing:
            - Converted HTML content as string
            - Markdown instance with parsed metadata (toc_tokens, etc.)

    """
    md = markdown.Markdown(
        extensions=[
            "extra",
            "codehilite",
            "fenced_code",
            "tables",
            "toc",
        ],
        extension_configs={
            "codehilite": {
                "css_class": "highlight",
                "linenums": False,
            }
        },
    )
    html = md.convert(md_content)
    return html, md


def extract_title_from_markdown_instance(md: markdown.Markdown) -> str:
    """
    Extract the first H1 heading from parsed Markdown.

    Uses the TOC tokens generated by the Markdown 'toc' extension
    to find the first level-1 heading.

    Args:
        md: Markdown instance after conversion with 'toc' extension enabled

    Returns:
        The first H1 heading text, or "Documentation" if no H1 found.

    """
    if hasattr(md, "toc_tokens") and md.toc_tokens:
        for token in md.toc_tokens:
            if token.get("level") == 1:
                return token.get("name", "Documentation")
    return "Documentation"


def convert_plain_text_to_html(text_content: str) -> str:
    """
    Convert plain text to HTML with preserved line breaks.

    For non-markdown files, escapes HTML entities and converts
    newlines to <br> tags.

    Args:
        text_content: Plain text content as string

    Returns:
        HTML with line breaks preserved

    """
    escaped_content = html.escape(text_content)
    # Convert newlines to <br> tags
    html_with_breaks = escaped_content.replace("\n", "<br>\n")
    return f"<div>{html_with_breaks}</div>"


def build_documentation(
    input_files: Sequence[Path],
    output_path: Path,
    template_path: Path | None = None,
    *,
    repo_url: str | None = None,
    title: str | None = None,
) -> None:
    """
    Build the documentation HTML file from input files.

    Converts multiple files into a single HTML documentation site
    with navigation, table of contents, and syntax highlighting.

    Markdown files (.md, .markdown) are processed with full Markdown support.
    Other text files are displayed as plain text with preserved formatting.

    Args:
        input_files: List of files to convert (Markdown or plain text)
        output_path: Path where the output HTML file will be written
        template_path: Optional custom HTML template. Defaults to built-in template.
        repo_url: Optional repository URL to link in navigation
        title: Optional documentation title. Falls back to first H1 in first file.

    Raises:
        FileNotFoundError: If input files or template don't exist
        OSError: If unable to write output file

    """
    # Set default template if not provided
    if template_path is None:
        template_path = Path(__file__).parent / "templates" / "default.html"

    # Load CSS file for inlining (if exists)
    # CSS file should have same name as template: default.html → default.css
    css_path = template_path.with_suffix(".css")
    inlined_css = ""
    if css_path.exists():
        sys.stdout.write(f"Reading CSS from {css_path}\n")
        inlined_css = css_path.read_text(encoding="utf-8")

    # Process each markdown file
    converted_sections = []
    extracted_title = None

    for input_file in input_files:
        sys.stdout.write(f"Reading {input_file}\n")
        file_content = input_file.read_text(encoding="utf-8")

        # Check if file is markdown or plain text
        is_markdown = input_file.suffix.lower() in {".md", ".markdown"}

        if is_markdown:
            sys.stdout.write(f"Converting {input_file.name} to HTML...\n")
            html_content, md_instance = convert_markdown_to_html(file_content)

            # Extract title from first file only (if not provided)
            if extracted_title is None:
                extracted_title = extract_title_from_markdown_instance(md_instance)
        else:
            sys.stdout.write(f"Converting {input_file.name} as plain text...\n")
            html_content = convert_plain_text_to_html(file_content)

        # Build section data
        section_id = input_file.stem.lower()
        converted_sections.append(
            {
                "id": section_id,
                "name": input_file.stem,
                "html": html_content,
            }
        )

    # Use provided title, or fall back to extracted title, or use default
    final_title = title or extracted_title or "Documentation"

    # Generate timestamp
    build_timestamp = datetime.now(UTC).strftime("%Y-%m-%d %H:%M:%S UTC")

    # Load and render template
    sys.stdout.write(f"Reading template from {template_path}\n")
    template_content = template_path.read_text(encoding="utf-8")

    template = Template(template_content)
    html_output = template.render(
        title=final_title,
        sections=converted_sections,
        inlined_css=inlined_css,
        repo_url=repo_url,
        build_timestamp=build_timestamp,
    )

    # Write output file
    sys.stdout.write(f"Writing output to {output_path}\n")
    output_path.write_text(html_output, encoding="utf-8")

    sys.stdout.write(f"✓ Documentation built successfully: {output_path}\n")
    sys.stdout.write(f"  Size: {output_path.stat().st_size:,} bytes\n")
