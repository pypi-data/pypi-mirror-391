# Copilot PR Review Instructions

## Generated Code Awareness

This project uses `unasync` to automatically generate synchronous code from asynchronous source.

### Important Directories

- **`src/pyplanhat/_async/`** - Source of truth for all code (REVIEW THIS)
- **`src/pyplanhat/_sync/`** - Auto-generated sync code (DO NOT REVIEW)
- **`tests/_async/`** - Source of truth for all tests (REVIEW THIS)
- **`tests/_sync/`** - Auto-generated sync tests (DO NOT REVIEW)

### Review Guidelines

1. **Only review files in `_async/` directories** - These are the source files
2. **Ignore files in `_sync/` directories** - These are auto-generated and should not be manually edited
3. **Generated code markers**:
   - Any file path containing `/_sync/` is auto-generated
   - Changes to `_sync/` files should redirect review to corresponding `_async/` file

### Code Generation Process

The sync code is generated by running:
```bash
uv run python scripts/generate_sync.py
```

This transforms:
- `async def` → `def`
- `await` → (removed)
- `AsyncClient` → `Client`
- `AsyncPyPlanhat` → `PyPlanhat`
- `__aenter__`/`__aexit__` → `__enter__`/`__exit__`
- `aclose` → `close`

### What to Review

✅ Review:
- Code in `_async/` directories
- Architecture and design patterns
- Error handling and edge cases
- Test coverage in `_async/` tests
- Documentation accuracy

❌ Don't Review:
- Code in `_sync/` directories (auto-generated)
- Docstring consistency in `_sync/` (handled by source)
- Formatting in `_sync/` (auto-formatted after generation)

### If You Find Issues in Generated Code

Instead of commenting on `_sync/` files, please:
1. Identify the corresponding `_async/` source file
2. Comment on the `_async/` file with the issue
3. The fix will automatically propagate to `_sync/` on next generation

## Project-Specific Patterns

### Exception Hierarchy

All exceptions inherit from `PyPlanhatError` base class:
- `APIConnectionError` - Network/timeout issues
- `APIError` - Base for HTTP errors
  - `AuthenticationError` - 401/403
  - `InvalidRequestError` - 400/404
  - `RateLimitError` - 429
  - `ServerError` - 5xx

### DRY Architecture Principle

This project follows a strict DRY (Don't Repeat Yourself) principle:
- **Single source of truth**: All business logic in `_async/` only
- **Zero duplication**: Sync code is 100% generated, never manually written
- **Consistency guaranteed**: Generation ensures sync/async parity

When reviewing, ensure no business logic divergence between async source and any other code.

### Docstring Guidelines

**Important for reviewers**: Async source docstrings must be generic to work correctly in generated sync code.

✅ **Correct docstring patterns**:
- "PyPlanhat client" (not "Async PyPlanhat client")
- "Tests for PyPlanhat SDK" (not "Async tests" or "Sync tests")
- "Fixture providing a PyPlanhat client" (not "async PyPlanhat client")

❌ **Incorrect docstring patterns**:
- Any docstring with "async" or "sync" specifiers
- Implementation-specific references that won't translate

**Why**: The generation process preserves docstring content but transforms code tokens. Generic docstrings ensure accurate documentation in both async and sync variants.

## Common Issues to Watch For (Phase 1 Lessons)

### 1. Fixture Decorator Mismatches

**Async fixtures** must use `@pytest_asyncio.fixture`:
```python
# ✅ CORRECT (tests/_async/conftest.py)
import pytest_asyncio

@pytest_asyncio.fixture
async def async_client() -> AsyncPyPlanhat:
    ...
```

**Sync fixtures** must use `@pytest.fixture`:
```python
# ✅ CORRECT (tests/_sync/conftest.py)
import pytest

@pytest.fixture  # NOT pytest_asyncio.fixture
def async_client() -> PyPlanhat:
    ...
```

**Common Bug**: unasync copies `@pytest_asyncio.fixture` to sync code - this is **incorrect** and causes test failures.

### 2. Duplicate Fixtures

❌ **DON'T** redefine fixtures in test files if they already exist in conftest.py:
```python
# ❌ BAD - test_companies.py
@pytest_asyncio.fixture
async def async_client():  # Already in conftest!
    ...
```

This causes fixture conflicts and test failures.

### 3. Type-Safe Response Handling

✅ **DO** use assertions for type narrowing:
```python
async def create(self, item: Model) -> Model:
    data = await self._handle_response(response)
    assert data is not None  # mypy type narrowing
    return Model(**data)
```

❌ **DON'T** raise status 500 for defensive None checks:
```python
# ❌ BAD - Status 500 = server error, not client logic
if data is None:
    raise InvalidRequestError("Failed", 500, "")
```

### 4. Error Message Redundancy

❌ **Redundant f-string**:
```python
response.text or f"Server error: {response.text}"  # ❌
```

✅ **Simple fallback**:
```python
response.text or "Server error"  # ✅
```

**Why redundant**: When `response.text` is truthy, the f-string is never evaluated.

### 5. Trust _handle_response()

The `_handle_response()` method already raises exceptions for HTTP errors (4xx, 5xx).

✅ **DO** trust it to handle errors:
```python
data = await self._handle_response(response)
return Model(**data)  # If we reach here, response was successful
```

❌ **DON'T** add defensive checks with incorrect status codes:
```python
# ❌ Unnecessary - _handle_response already raised if error
if data is None:
    raise InvalidRequestError("Failed", 500, "")
```
