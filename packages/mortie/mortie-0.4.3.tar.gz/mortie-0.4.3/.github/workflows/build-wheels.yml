name: Build Wheels

on:
  push:
    branches: [main, feature/rust-acceleration]
    tags:
      - '*.*.*'
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  # Update changelog from PR titles
  update-changelog:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write
      pull-requests: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Get tag name
      id: get_tag
      run: |
        echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Get previous tag
      id: get_previous_tag
      run: |
        PREV_TAG=$(git describe --tags --abbrev=0 ${{ steps.get_tag.outputs.tag }}^ 2>/dev/null || echo "")
        echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
        echo "Previous tag: $PREV_TAG"

    - name: Generate changelog entry
      id: generate_changelog
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        CURRENT_TAG: ${{ steps.get_tag.outputs.tag }}
        PREVIOUS_TAG: ${{ steps.get_previous_tag.outputs.previous_tag }}
      run: |
        echo "Generating changelog for $CURRENT_TAG"

        # Get the date for the current tag
        TAG_DATE=$(git log -1 --format=%cd --date=short $CURRENT_TAG 2>/dev/null || date +%Y-%m-%d)

        # Create temporary file for the new changelog entry
        NEW_ENTRY_FILE=$(mktemp)

        # Header for the new version
        echo "## [$CURRENT_TAG] - $TAG_DATE" > $NEW_ENTRY_FILE
        echo "" >> $NEW_ENTRY_FILE

        if [ -n "$PREVIOUS_TAG" ]; then
          echo "Getting PRs merged between $PREVIOUS_TAG and $CURRENT_TAG"

          # Get the date of the previous tag for API filtering (use unix timestamp for easier comparison)
          PREV_TAG_DATE=$(git log -1 --format=%ct $PREVIOUS_TAG 2>/dev/null)
          CURRENT_TAG_DATE=$(git log -1 --format=%ct $CURRENT_TAG 2>/dev/null)

          echo "Previous tag date: $PREV_TAG_DATE"
          echo "Current tag date: $CURRENT_TAG_DATE"

          # Get merged PRs in the date range using GitHub API
          if [ -n "$PREV_TAG_DATE" ] && [ -n "$CURRENT_TAG_DATE" ]; then
            echo "Fetching merged PRs from GitHub API..."

            # Use GitHub CLI to get merged PRs and filter by date using shell
            TEMP_PR_FILE=$(mktemp)
            gh api graphql \
              -f query='
                query($owner: String!, $repo: String!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequests(states: MERGED, first: 100, orderBy: {field: UPDATED_AT, direction: DESC}) {
                      edges {
                        node {
                          number
                          title
                          author {
                            login
                          }
                          url
                          mergedAt
                        }
                      }
                    }
                  }
                }' \
              -f owner="${{ github.repository_owner }}" \
              -f repo="${{ github.event.repository.name }}" \
              -q '.data.repository.pullRequests.edges[].node | "- " + .title + " ([#" + (.number | tostring) + "](" + .url + ")) by @" + .author.login + "|" + .mergedAt' > $TEMP_PR_FILE

            # Filter PRs by date range and format output
            while IFS='|' read -r pr_line merge_date; do
              if [[ -n "$merge_date" && -n "$PREV_TAG_DATE" && -n "$CURRENT_TAG_DATE" ]]; then
                # Convert GitHub API date to unix timestamp for comparison
                merge_timestamp=$(date -d "$merge_date" +%s 2>/dev/null || echo "0")
                if [[ "$merge_timestamp" -ge "$PREV_TAG_DATE" && "$merge_timestamp" -le "$CURRENT_TAG_DATE" ]]; then
                  echo "$pr_line" >> $NEW_ENTRY_FILE
                fi
              fi
            done < $TEMP_PR_FILE

            rm -f $TEMP_PR_FILE
          fi

          # If no PRs found, fall back to commit messages
          if ! grep -q "^-" $NEW_ENTRY_FILE; then
            echo "No PRs found in commit range, using commit messages instead"
            git log ${PREVIOUS_TAG}..${CURRENT_TAG} --pretty=format:"- %s (%h)" --no-merges >> $NEW_ENTRY_FILE
          fi

        else
          echo "- Initial release" >> $NEW_ENTRY_FILE
        fi

        echo "" >> $NEW_ENTRY_FILE

        # Store the new entry file path
        echo "new_entry_file=$NEW_ENTRY_FILE" >> $GITHUB_OUTPUT

    - name: Update CHANGELOG.md
      run: |
        NEW_ENTRY_FILE="${{ steps.generate_changelog.outputs.new_entry_file }}"

        if [ -f "CHANGELOG.md" ]; then
          # Create temporary file for updated changelog
          TEMP_CHANGELOG=$(mktemp)

          # Find the line with "## [Unreleased]" and add new entry after it
          awk '
            /^## \[Unreleased\]/ {
              print $0
              print ""
              while ((getline line < "'"$NEW_ENTRY_FILE"'") > 0) {
                print line
              }
              next
            }
            { print }
          ' CHANGELOG.md > $TEMP_CHANGELOG

          # Replace original with updated version
          mv $TEMP_CHANGELOG CHANGELOG.md

          # Clean up
          rm -f $NEW_ENTRY_FILE

        else
          echo "Warning: CHANGELOG.md not found, creating new one"
          cat > CHANGELOG.md << 'EOF'
        # Changelog

        All notable changes to this project will be documented in this file.

        The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
        and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

        ## [Unreleased]

        - Upcoming features and fixes

        EOF
          cat $NEW_ENTRY_FILE >> CHANGELOG.md
          rm -f $NEW_ENTRY_FILE
        fi

    - name: Commit changelog updates
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        git config --local user.name "github-actions[bot]"
        git config --local user.email "github-actions[bot]@users.noreply.github.com"

        # Switch to main branch and pull latest changes
        git checkout main
        git pull origin main

        # Check if there are any changes to commit
        if git diff --quiet CHANGELOG.md; then
          echo "No changes to CHANGELOG.md"
        else
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG.md for ${{ steps.get_tag.outputs.tag }}"
          git push origin main
          echo "âœ… CHANGELOG.md updated and pushed to main branch"
        fi

  # Build wheels for Linux, Windows, and macOS
  build-wheels:
    needs: [update-changelog]
    if: always() && (needs.update-changelog.result == 'success' || needs.update-changelog.result == 'skipped')
    name: Build wheels on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-13, macos-14]

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Set version from git tag
      if: startsWith(github.ref, 'refs/tags/')
      shell: bash
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        sed -i.bak "s/^version = .*/version = \"$TAG\"/" Cargo.toml
        rm Cargo.toml.bak || true

    - name: Build wheels
      uses: PyO3/maturin-action@v1
      with:
        command: build
        args: --release --out dist --interpreter 3.10
        manylinux: auto
        sccache: 'true'

    - name: Upload wheels
      uses: actions/upload-artifact@v4
      with:
        name: wheels-${{ matrix.os }}
        path: dist

  # Build source distribution
  build-sdist:
    needs: [update-changelog]
    if: always() && (needs.update-changelog.result == 'success' || needs.update-changelog.result == 'skipped')
    name: Build source distribution
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable

    - name: Set version from git tag
      if: startsWith(github.ref, 'refs/tags/')
      shell: bash
      run: |
        TAG=${GITHUB_REF#refs/tags/}
        sed -i.bak "s/^version = .*/version = \"$TAG\"/" Cargo.toml
        rm Cargo.toml.bak || true

    - name: Build sdist
      uses: PyO3/maturin-action@v1
      with:
        command: sdist
        args: --out dist

    - name: Upload sdist
      uses: actions/upload-artifact@v4
      with:
        name: sdist
        path: dist

  # Test the wheels (only on tags before publishing)
  # Note: Windows tests are excluded because healpy has no pre-built wheels for Windows
  test-wheels:
    name: Test wheels on ${{ matrix.os }} - Python ${{ matrix.python-version }}
    needs: [build-wheels]
    runs-on: ${{ matrix.os }}
    if: startsWith(github.ref, 'refs/tags/')
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-13]
        python-version: ['3.10', '3.11', '3.12', '3.13']

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Download wheels
      uses: actions/download-artifact@v4
      with:
        name: wheels-${{ matrix.os }}
        path: dist

    - name: Install dependencies
      run: |
        pip install numpy healpy

    - name: Install wheel
      shell: bash
      run: |
        pip install --no-deps --find-links dist mortie

    - name: Install test dependencies
      run: |
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        pytest -v mortie/tests/test_tools.py mortie/tests/test_polygon_regression.py

  # Publish to TestPyPI on tag (before production publish)
  publish-testpypi:
    name: Publish to TestPyPI
    needs: [build-wheels, build-sdist, test-wheels]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    environment:
      name: testpypi
      url: https://test.pypi.org/p/mortie
    permissions:
      id-token: write

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist-artifacts

    - name: Flatten artifacts
      run: |
        mkdir -p dist
        find dist-artifacts -type f -exec mv {} dist/ \;

    - name: Publish to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        repository-url: https://test.pypi.org/legacy/

  # Publish to PyPI on tag (only if TestPyPI succeeds)
  publish:
    name: Publish to PyPI
    needs: [build-wheels, build-sdist, test-wheels, publish-testpypi]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    environment:
      name: pypi
      url: https://pypi.org/p/mortie
    permissions:
      id-token: write

    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist-artifacts

    - name: Flatten artifacts
      run: |
        mkdir -p dist
        find dist-artifacts -type f -exec mv {} dist/ \;

    - name: Publish to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1

  # Create GitHub Release with artifacts
  create-release:
    name: Create GitHub Release
    needs: [publish]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Get tag name
      id: get_tag
      run: |
        echo "tag=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: dist-artifacts

    - name: Flatten artifacts
      run: |
        mkdir -p dist
        find dist-artifacts -type f -exec mv {} dist/ \;

    - name: Extract changelog for this version
      id: changelog
      run: |
        TAG="${{ steps.get_tag.outputs.tag }}"
        # Extract the changelog section for this version
        if [ -f "CHANGELOG.md" ]; then
          # Get content between this version's header and the next version header
          CHANGELOG=$(awk "/^## \[$TAG\]/,/^## \[/" CHANGELOG.md | sed '$d' | tail -n +2)
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="Release $TAG"
          fi
        else
          CHANGELOG="Release $TAG"
        fi
        # Save to file to preserve formatting
        echo "$CHANGELOG" > changelog_body.txt

    - name: Create GitHub Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG="${{ steps.get_tag.outputs.tag }}"
        gh release create "$TAG" \
          --title "Release $TAG" \
          --notes-file changelog_body.txt \
          dist/*
