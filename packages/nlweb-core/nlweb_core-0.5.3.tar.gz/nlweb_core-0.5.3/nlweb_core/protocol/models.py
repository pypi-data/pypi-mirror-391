# generated by datamodel-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-11-06T03:54:28+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Literal

from pydantic import BaseModel, Field


class Agent(BaseModel):
    field_type: str = Field(
        ...,
        alias='@type',
        description='Type of agent (e.g., "Search Agent" or "Analytics Agent")',
    )
    agentSpec: dict[str, Any] = Field(
        ..., description='Agent specification - structure will depend on agent type'
    )


class Mode(Enum):
    list = 'list'
    summary = 'summary'


class AskRequest(BaseModel):
    query: str = Field(..., description='natural language query (required)')
    prev: list[str] | None = Field(
        None,
        description='Previous conversational context.  Should be provided in comma separated list. We would like Ask requests to be restful. Passing the previous queries enables continued conversations without the server keeping state indefinitely.',
    )
    context: str | None = Field(
        None, description='additional context (e.g., from memory)'
    )
    mode: Mode | None = Field(
        None,
        description='Mode of response.  Currently available modes are to return a list of matching items, or to provide a summary answer.',
    )
    site: str | None = Field(
        None,
        description='Site:  An endpoint may provide the Ask interface for multiple sites.  Use this to specify which site(s) to include responses from.',
    )
    streaming: bool | None = Field(
        None,
        description='Streaming:  Indicates whether the results should be streamed back.',
    )
    response_format: str | None = Field(
        None, description='Response format:  Optional field for future use.'
    )


class Resource(BaseModel):
    uri: str | None = Field(
        None,
        description='Resource identifier/template reference (e.g., ui://widget/restaurant-card.html)',
    )
    mimeType: str | None = Field(
        None, description='MIME type (e.g., text/html+skybridge for ChatGPT Apps)'
    )
    text: str | None = Field(
        None, description='Raw content, typically HTML for widget rendering'
    )
    data: dict[str, Any] | list[dict[str, Any]] = Field(
        ...,
        description='Structured data payload.\nCan be a single object or an array of objects (potentially of different types)',
    )

class ResourceContent(BaseModel):
    type: Literal['resource'] = Field(..., description='must be "resource"')
    resource: Resource = Field(..., description='Resource details')


class ResponseMeta(BaseModel):
    model_config = {"extra": "allow"}
    
    conversation_id: str | None = Field(
        None,
        description='conversational identifier - pass-through only when there are simultaneous conversations to track',
    )
    version: str = Field(..., description='protocol version')


class TextContent(BaseModel):
    type: Literal['text'] = Field(..., description='Must be "text"')
    text: str = Field(..., description='Natural language content')


class WhoRequest(BaseModel):
    query: str = Field(
        ..., description='Natural language query for agent discovery (required)'
    )
    streaming: bool | None = Field(None, description='Enable streaming response')
    constr: dict[str, Any] | None = Field(
        None, description='Additional Constraints (filters, capabilities, etc.)'
    )


class WhoResponse(BaseModel):
    field_meta: ResponseMeta = Field(
        ..., alias='_meta', description='Metadata about the response'
    )
    content: list[TextContent | ResourceContent] = Field(
        ...,
        description='Array of content items containing agent descriptions.\n\nConstraints:\n- Must contain at least one item\n- Typically contains ResourceContent with Agent data\n- May include TextContent for descriptions',
        min_length=1,
    )


class AskResponse(BaseModel):
    field_meta: ResponseMeta = Field(
        ..., alias='_meta', description='Metadata about the response'
    )
    content: list[TextContent | ResourceContent] = Field(
        ...,
        description='Array of content items (text and/or resource).\n\nConstraints:\n- Must contain at least one item\n- Must contain at least one TextContent item\n- May contain multiple items of each type in any order\n\nNote:  The requirement for at least one TextContent item must be validated by implementations, as this constraint cannot be expressed in the type system.',
        min_length=1,
    )
