# DO NOT EDIT THIS FILE: these stubs have been autogenerated

# Polars Version: 1.34.0
from __future__ import annotations

from typing import TYPE_CHECKING, Any, Callable, TypeVar
import polars as pl
from collections.abc import Sequence
from paguro.models.vfm import VFrameModel, VFM
from collections.abc import Mapping
from typing import TYPE_CHECKING, Any, Callable, TypeVar
from polars._utils.various import no_default
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import sys
    from collections.abc import Iterable, Mapping
    from pathlib import Path

    from polars import DataFrame
    from polars._typing import (
        IntoExpr,
    )


    from datetime import timedelta
    from polars._typing import (
        IntoExpr,
        MaintainOrderJoin
    )

    if sys.version_info >= (3, 11):
        from typing import Self
    else:
        from typing_extensions import Self
if TYPE_CHECKING:
    from polars.schema import Schema
    from polars.interchange.protocol import CompatLevel
    from polars._typing import JaxExportType, TorchExportType
    from polars._dependencies import pandas as pd
    from polars._dependencies import pyarrow as pa
    from polars._dependencies import torch
    from polars._dependencies import numpy as np
    from pathlib import Path
    import polars._reexport as pl
    from collections.abc import Iterable, Sequence
    import sys
    from collections.abc import Collection, Iterator, Mapping
    from datetime import timedelta
    from typing import Literal

    import jax
    import numpy.typing as npt

    from polars import Expr, Series
    from polars._typing import (
        ColumnNameOrSelector,
        FillNullStrategy,
        IndexOrder,
        IntoExpr,
        IntoExprColumn,
        MaintainOrderJoin,
        PivotAgg,
        PolarsDataType,
        PythonDataType,
        QuantileMethod,
        SchemaDict,
        SizeUnit,
        UniqueKeepStrategy,
        UnstackDirection,
    )
    from polars._utils.various import NoDefault
    from polars.interchange.dataframe import PolarsDataFrame
    from polars.ml.torch import PolarsDataset

    if sys.version_info >= (3, 10):
        from typing import Concatenate, ParamSpec
    else:
        from typing_extensions import Concatenate, ParamSpec

    if sys.version_info >= (3, 13):
        pass
    else:
        pass  # noqa: TC004

    T = TypeVar("T")
    P = ParamSpec("P")
if TYPE_CHECKING:
    from polars import DataFrame

    import sys

    if sys.version_info >= (3, 11):
        from typing import Self
    else:
        from typing_extensions import Self
if TYPE_CHECKING:

    from paguro import Dataset


    import sys

    if sys.version_info >= (3, 11):
        from typing import Self
    else:
        from typing_extensions import Self

U = TypeVar("U", bound=VFrameModel)

class _DatasetMixin:
    """Stub class for _DatasetMixin."""

    def _getattr(self, attr) -> Any:
         raise NotImplementedError

    def approx_n_unique(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("approx_n_unique")()

    def bottom_k(self, k: int, *, by: IntoExpr | Iterable[IntoExpr], reverse: bool | Sequence[bool] = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("bottom_k")(k, by=by, reverse=reverse)

    def cast(self, dtypes: Mapping[ColumnNameOrSelector | PolarsDataType, PolarsDataType | PythonDataType] | PolarsDataType, *, strict: bool = True) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("cast")(dtypes, strict=strict)

    def clear(self, n: int = 0) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("clear")(n=n)

    def clone(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("clone")()

    def collect_model_blueprint(self, path: str | Path | None = None, *, name: str | None = 'DatasetModel', dtypes: bool | Literal['as_values'] = False, allow_nulls: bool | None = None) -> dict[str, str]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("collect_model_blueprint")(path, name=name, dtypes=dtypes, allow_nulls=allow_nulls)

    def collect_schema(self) -> dict[str, Schema]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("collect_schema")()

    @property
    def columns(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("columns")

    def corr(self, **kwargs: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("corr")(**kwargs)

    def count(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("count")()

    def describe(self, percentiles: Sequence[float] | float | None = (0.25, 0.5, 0.75), *, interpolation: QuantileMethod = 'nearest') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("describe")(percentiles, interpolation=interpolation)

    def drop(self, *columns: ColumnNameOrSelector | Iterable[ColumnNameOrSelector], strict: bool = True) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("drop")(*columns, strict=strict)

    def drop_in_place(self, name: str) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("drop_in_place")(name=name)

    def drop_nans(self, subset: ColumnNameOrSelector | Collection[ColumnNameOrSelector] | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("drop_nans")(subset=subset)

    def drop_nulls(self, subset: ColumnNameOrSelector | Collection[ColumnNameOrSelector] | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("drop_nulls")(subset=subset)

    @property
    def dtypes(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("dtypes")

    def equals(self, other: DataFrame, *, null_equal: bool = True) -> dict[str, bool]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("equals")(other, null_equal=null_equal)

    def estimated_size(self, unit: SizeUnit = 'b') -> dict[str, int | float]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("estimated_size")(unit=unit)

    def explode(self, columns: ColumnNameOrSelector | Iterable[ColumnNameOrSelector], *more_columns: ColumnNameOrSelector) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("explode")(columns, *more_columns)

    def extend(self, other: DataFrame) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("extend")(other=other)

    def fill_nan(self, value: Expr | int | float | None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("fill_nan")(value=value)

    def fill_null(self, value: Any | Expr | None = None, strategy: FillNullStrategy | None = None, limit: int | None = None, *, matches_supertype: bool = True) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("fill_null")(value, strategy, limit, matches_supertype=matches_supertype)

    def filter(self, *predicates: IntoExprColumn | Iterable[IntoExprColumn] | bool | list[bool] | np.ndarray[Any, Any], **constraints: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("filter")(*predicates, **constraints)

    @property
    def flags(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("flags")

    def fold(self, operation: Callable[[Series, Series], Series]) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("fold")(operation=operation)

    def gather_every(self, n: int, offset: int = 0) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("gather_every")(n=n, offset=offset)

    def get_column(self, name: str, *, default: Any | NoDefault = no_default) -> dict[str, Series | Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("get_column")(name, default=default)

    def get_column_index(self, name: str) -> dict[str, int]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("get_column_index")(name=name)

    def get_columns(self) -> dict[str, list[Series]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("get_columns")()

    def glimpse(self, *, max_items_per_column: int = 10, max_colname_length: int = 50, return_as_string: bool = False) -> dict[str, str | None]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("glimpse")(max_items_per_column=max_items_per_column, max_colname_length=max_colname_length, return_as_string=return_as_string)

    def hash_rows(self, seed: int = 0, seed_1: int | None = None, seed_2: int | None = None, seed_3: int | None = None) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("hash_rows")(seed=seed, seed_1=seed_1, seed_2=seed_2, seed_3=seed_3)

    def head(self, n: int = 5) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("head")(n=n)

    @property
    def height(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("height")

    def hstack(self, columns: list[Series] | DataFrame, *, in_place: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("hstack")(columns, in_place=in_place)

    def insert_column(self, index: int, column: IntoExprColumn) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("insert_column")(index=index, column=column)

    def interpolate(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("interpolate")()

    def is_duplicated(self) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("is_duplicated")()

    def is_empty(self) -> dict[str, bool]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("is_empty")()

    def is_unique(self) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("is_unique")()

    def item(self, row: int | None = None, column: int | str | None = None) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("item")(row=row, column=column)

    def iter_columns(self) -> dict[str, Iterator[Series]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("iter_columns")()

    def iter_rows(self, *, named: bool = False, buffer_size: int = 512) -> dict[str, Iterator[tuple[Any, ...]] | Iterator[dict[str, Any]]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("iter_rows")(named=named, buffer_size=buffer_size)

    def iter_slices(self, n_rows: int = 10000) -> dict[str, Iterator[DataFrame]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("iter_slices")(n_rows=n_rows)

    def limit(self, n: int = 5) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("limit")(n=n)

    def map_columns(self, column_names: str | Sequence[str] | pl.Selector, function: Callable[[Series], Series], *args: P.args, **kwargs: P.kwargs) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("map_columns")(column_names, function, *args, **kwargs)

    def map_rows(self, function: Callable[[tuple[Any, ...]], Any], return_dtype: PolarsDataType | None = None, *, inference_size: int = 256) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("map_rows")(function, return_dtype, inference_size=inference_size)

    def match_to_schema(self, schema: SchemaDict | Schema, *, missing_columns: Literal['insert', 'raise'] | Mapping[str, Literal['insert', 'raise'] | Expr] = 'raise', missing_struct_fields: Literal['insert', 'raise'] | Mapping[str, Literal['insert', 'raise']] = 'raise', extra_columns: Literal['ignore', 'raise'] = 'raise', extra_struct_fields: Literal['ignore', 'raise'] | Mapping[str, Literal['ignore', 'raise']] = 'raise', integer_cast: Literal['upcast', 'forbid'] | Mapping[str, Literal['upcast', 'forbid']] = 'forbid', float_cast: Literal['upcast', 'forbid'] | Mapping[str, Literal['upcast', 'forbid']] = 'forbid') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("match_to_schema")(schema, missing_columns=missing_columns, missing_struct_fields=missing_struct_fields, extra_columns=extra_columns, extra_struct_fields=extra_struct_fields, integer_cast=integer_cast, float_cast=float_cast)

    def max(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("max")()

    def max_horizontal(self) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("max_horizontal")()

    def mean(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("mean")()

    def mean_horizontal(self, *, ignore_nulls: bool = True) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("mean_horizontal")(ignore_nulls=ignore_nulls)

    def median(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("median")()

    def melt(self, id_vars: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, value_vars: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, variable_name: str | None = None, value_name: str | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("melt")(id_vars=id_vars, value_vars=value_vars, variable_name=variable_name, value_name=value_name)

    def merge_sorted(self, other: Dataset[U] | pl.DataFrame, key: str) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("merge_sorted")(other=other, key=key)

    def min(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("min")()

    def min_horizontal(self) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("min_horizontal")()

    @property
    def model(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("model")

    def n_chunks(self, strategy: Literal['first', 'all'] = 'first') -> dict[str, int | list[int]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("n_chunks")(strategy=strategy)

    def n_unique(self, subset: str | Expr | Sequence[str | Expr] | None = None) -> dict[str, int]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("n_unique")(subset=subset)

    def null_count(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("null_count")()

    def partition_by(self, by: ColumnNameOrSelector | Sequence[ColumnNameOrSelector], *more_by: ColumnNameOrSelector, maintain_order: bool = True, include_key: bool = True, as_dict: bool = False) -> dict[str, list[DataFrame] | dict[tuple[Any, ...], DataFrame]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("partition_by")(by, *more_by, maintain_order=maintain_order, include_key=include_key, as_dict=as_dict)

    def pipe(self, function: Callable[Concatenate[DataFrame, P], T], *args: P.args, **kwargs: P.kwargs) -> dict[str, T]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("pipe")(function, *args, **kwargs)

    def pivot(self, on: ColumnNameOrSelector | Sequence[ColumnNameOrSelector], *, index: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, values: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, aggregate_function: PivotAgg | Expr | None = None, maintain_order: bool = True, sort_columns: bool = False, separator: str = '_') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("pivot")(on, index=index, values=values, aggregate_function=aggregate_function, maintain_order=maintain_order, sort_columns=sort_columns, separator=separator)

    @property
    def plot(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("plot")

    def product(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("product")()

    def quantile(self, quantile: float, interpolation: QuantileMethod = 'nearest') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("quantile")(quantile=quantile, interpolation=interpolation)

    def rechunk(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("rechunk")()

    def remove(self, *predicates: IntoExprColumn | Iterable[IntoExprColumn] | bool | list[bool] | np.ndarray[Any, Any], **constraints: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("remove")(*predicates, **constraints)

    def rename(self, mapping: Mapping[str, str] | Callable[[str], str], *, strict: bool = True) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("rename")(mapping, strict=strict)

    def replace_column(self, index: int, column: Series) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("replace_column")(index=index, column=column)

    def reverse(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("reverse")()

    def row(self, index: int | None = None, *, by_predicate: Expr | None = None, named: bool = False) -> dict[str, tuple[Any, ...] | dict[str, Any]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("row")(index, by_predicate=by_predicate, named=named)

    def rows(self, *, named: bool = False) -> dict[str, list[tuple[Any, ...]] | list[dict[str, Any]]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("rows")(named=named)

    def rows_by_key(self, key: ColumnNameOrSelector | Sequence[ColumnNameOrSelector], *, named: bool = False, include_key: bool = False, unique: bool = False) -> dict[str, dict[Any, Any]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("rows_by_key")(key, named=named, include_key=include_key, unique=unique)

    def sample(self, n: int | Series | None = None, *, fraction: float | Series | None = None, with_replacement: bool = False, shuffle: bool = False, seed: int | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("sample")(n, fraction=fraction, with_replacement=with_replacement, shuffle=shuffle, seed=seed)

    @property
    def schema(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("schema")

    def select(self, *exprs: IntoExpr | Iterable[IntoExpr], **named_exprs: IntoExpr) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("select")(*exprs, **named_exprs)

    def select_seq(self, *exprs: IntoExpr | Iterable[IntoExpr], **named_exprs: IntoExpr) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("select_seq")(*exprs, **named_exprs)

    def set_sorted(self, column: str, *, descending: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("set_sorted")(column, descending=descending)

    @property
    def shape(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("shape")

    def shift(self, n: int = 1, *, fill_value: IntoExpr | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("shift")(n, fill_value=fill_value)

    def shrink_to_fit(self, *, in_place: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("shrink_to_fit")(in_place=in_place)

    def skim(self, config: list[tuple] | None = None, *, by: str | list[str] | None = None, hist: bool = False, unnest_structs: bool | ColumnNameOrSelector = False) -> dict[str, Collection]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("skim")(config, by=by, hist=hist, unnest_structs=unnest_structs)

    def slice(self, offset: int, length: int | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("slice")(offset=offset, length=length)

    def sort(self, by: IntoExpr | Iterable[IntoExpr], *more_by: IntoExpr, descending: bool | Sequence[bool] = False, nulls_last: bool | Sequence[bool] = False, multithreaded: bool = True, maintain_order: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("sort")(by, *more_by, descending=descending, nulls_last=nulls_last, multithreaded=multithreaded, maintain_order=maintain_order)

    def sql(self, query: str, *, table_name: str = 'self') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("sql")(query, table_name=table_name)

    def std(self, ddof: int = 1) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("std")(ddof=ddof)

    @property
    def style(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("style")

    def sum(self) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("sum")()

    def sum_horizontal(self, *, ignore_nulls: bool = True) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("sum_horizontal")(ignore_nulls=ignore_nulls)

    def tail(self, n: int = 5) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("tail")(n=n)

    def to_arrow(self, *, compat_level: CompatLevel | None = None) -> dict[str, pa.Table]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_arrow")(compat_level=compat_level)

    def to_dataframe(self) -> dict[str, pl.DataFrame]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_dataframe")()

    def to_dummies(self, columns: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, *, separator: str = '_', drop_first: bool = False, drop_nulls: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_dummies")(columns, separator=separator, drop_first=drop_first, drop_nulls=drop_nulls)

    def to_init_repr(self, n: int = 1000) -> dict[str, str]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_init_repr")(n=n)

    def to_jax(self, return_type: JaxExportType = 'array', *, device: jax.Device | str | None = None, label: str | Expr | Sequence[str | Expr] | None = None, features: str | Expr | Sequence[str | Expr] | None = None, dtype: PolarsDataType | None = None, order: IndexOrder = 'fortran') -> dict[str, jax.Array | dict[str, jax.Array]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_jax")(return_type, device=device, label=label, features=features, dtype=dtype, order=order)

    def to_lazyframe(self) -> dict[str, pl.LazyFrame]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_lazyframe")()

    def to_numpy(self, *, order: IndexOrder = 'fortran', writable: bool = False, allow_copy: bool = True, structured: bool = False, use_pyarrow: bool | None = None) -> dict[str, np.ndarray[Any, Any]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_numpy")(order=order, writable=writable, allow_copy=allow_copy, structured=structured, use_pyarrow=use_pyarrow)

    def to_pandas(self, *, use_pyarrow_extension_array: bool = False, **kwargs: Any) -> dict[str, pd.DataFrame]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_pandas")(use_pyarrow_extension_array=use_pyarrow_extension_array, **kwargs)

    def to_polars(self) -> dict[str, pl.DataFrame]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_polars")()

    def to_series(self, index: int = 0) -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_series")(index=index)

    def to_struct(self, name: str = 'paguro.shared._getattr._polars') -> dict[str, Series]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_struct")(name=name)

    def to_torch(self, return_type: TorchExportType = 'tensor', *, label: str | Expr | Sequence[str | Expr] | None = None, features: str | Expr | Sequence[str | Expr] | None = None, dtype: PolarsDataType | None = None) -> dict[str, torch.Tensor | dict[str, torch.Tensor] | PolarsDataset]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("to_torch")(return_type, label=label, features=features, dtype=dtype)

    def top_k(self, k: int, *, by: IntoExpr | Iterable[IntoExpr], reverse: bool | Sequence[bool] = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("top_k")(k, by=by, reverse=reverse)

    def transpose(self, *, include_header: bool = False, header_name: str = 'column', column_names: str | Iterable[str] | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("transpose")(include_header=include_header, header_name=header_name, column_names=column_names)

    def unique(self, subset: ColumnNameOrSelector | Collection[ColumnNameOrSelector] | None = None, *, keep: UniqueKeepStrategy = 'any', maintain_order: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("unique")(subset, keep=keep, maintain_order=maintain_order)

    def unnest(self, columns: ColumnNameOrSelector | Collection[ColumnNameOrSelector], *more_columns: ColumnNameOrSelector) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("unnest")(columns, *more_columns)

    def unpivot(self, on: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, *, index: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, variable_name: str | None = None, value_name: str | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("unpivot")(on, index=index, variable_name=variable_name, value_name=value_name)

    def unstack(self, *, step: int, how: UnstackDirection = 'vertical', columns: ColumnNameOrSelector | Sequence[ColumnNameOrSelector] | None = None, fill_values: list[Any] | None = None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("unstack")(step=step, how=how, columns=columns, fill_values=fill_values)

    def update(self, other: DataFrame, on: str | Sequence[str] | None = None, how: Literal['left', 'inner', 'full'] = 'left', *, left_on: str | Sequence[str] | None = None, right_on: str | Sequence[str] | None = None, include_nulls: bool = False, maintain_order: MaintainOrderJoin | None = 'left') -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("update")(other, on, how, left_on=left_on, right_on=right_on, include_nulls=include_nulls, maintain_order=maintain_order)

    def upsample(self, time_column: str, *, every: str | timedelta, group_by: str | Sequence[str] | None = None, maintain_order: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("upsample")(time_column, every=every, group_by=group_by, maintain_order=maintain_order)

    def var(self, ddof: int = 1) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("var")(ddof=ddof)

    @property
    def vcol(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("vcol")

    def vstack(self, other: Dataset[VFM] | pl.DataFrame, *, in_place: bool = False) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("vstack")(other, in_place=in_place)

    @property
    def width(self) -> dict[str, Any]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("width")

    def with_columns(self, *exprs: IntoExpr | Iterable[IntoExpr], **named_exprs: IntoExpr) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("with_columns")(*exprs, **named_exprs)

    def with_columns_seq(self, *exprs: IntoExpr | Iterable[IntoExpr], **named_exprs: IntoExpr) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("with_columns_seq")(*exprs, **named_exprs)

    def with_name(self, name: str | None) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("with_name")(name=name)

    def with_row_count(self, name: str = 'row_nr', offset: int = 0) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("with_row_count")(name=name, offset=offset)

    def with_row_index(self, name: str = 'index', offset: int = 0) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("with_row_index")(name=name, offset=offset)

    def without_model(self) -> dict[str, Dataset[Any]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("without_model")()

    # ------- dunder methods ---------

    def __add__(self, other: DataFrame | Series | int | float | bool | str) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__add__")(other=other)

    def __array__(self, dtype: npt.DTypeLike | None = None, copy: bool | None = None) -> dict[str, np.ndarray[Any, Any]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__array__")(dtype=dtype, copy=copy)

    def __arrow_c_stream__(self, requested_schema: object | None = None) -> dict[str, object]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__arrow_c_stream__")(requested_schema=requested_schema)

    def __dataframe__(self, nan_as_null: bool = False, allow_copy: bool = True) -> dict[str, PolarsDataFrame]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__dataframe__")(nan_as_null=nan_as_null, allow_copy=allow_copy)

    def __floordiv__(self, other: DataFrame | Series | int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__floordiv__")(other=other)

    def __ge__(self, other: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__ge__")(other=other)

    def __gt__(self, other: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__gt__")(other=other)

    def __le__(self, other: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__le__")(other=other)

    def __lt__(self, other: Any) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__lt__")(other=other)

    def __mod__(self, other: DataFrame | Series | int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__mod__")(other=other)

    def __mul__(self, other: DataFrame | Series | int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__mul__")(other=other)

    def __radd__(self, other: DataFrame | Series | int | float | bool | str) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__radd__")(other=other)

    def __reversed__(self) -> dict[str, Iterator[Series]]:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__reversed__")()

    def __rmul__(self, other: int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__rmul__")(other=other)

    def __sub__(self, other: DataFrame | Series | int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__sub__")(other=other)

    def __truediv__(self, other: DataFrame | Series | int | float) -> Self:
        """


        Group
        -----
            Delegated
        """
        return self._getattr("__truediv__")(other=other)
