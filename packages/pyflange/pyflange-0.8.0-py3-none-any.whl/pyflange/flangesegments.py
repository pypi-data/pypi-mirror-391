# pyFlange - python library for large flanges design
# Copyright (C) 2024  KCI The Engineers B.V.,
#                     Siemens Gamesa Renewable Energy B.V.,
#                     Nederlandse Organisatie voor toegepast-natuurwetenschappelijk onderzoek TNO.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License, as published by
# the Free Software Foundation, either version 3 of the License, or any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License version 3 for more details.
#
# You should have received a copy of the GNU General Public License
# version 3 along with this program.  If not, see <https://www.gnu.org/licenses/>.

'''
This module contains ``FlangeSegment`` classes, which model the mechanical
behavior of a flange sector containig one bolt only.

Currently, the only two type of FlangeSegment available are an L-Flange segment
and a T-Flange segment, implementing a polinomial relation between tower shell force
force and bolt force / bolt moment. Nonetheless, this module has been structured
to be easily extensible with other types of FlangeSegment model, such as
Multilinear (Petersen) L-Flanges, Multilinear T-Flanges, etc.

The models implemented in this module are based on the following references:

[1]:  Marc Seidel, SGRE TE TF PST: IEC 61400-6 AMD1 Background Document
      Fatigue design for ring flange connsections in wind turbine support structures.

[2]:  IEC 61400-6:2020/AMD1 - wIND ENERGY GENERATION SYSTEMS - Part 6: Tower and foundation
      design requirements - AMENDMENT 1
      Draft version 2024-10-01

[3]:  Petersen, C.: Nachweis der Betriebsfestigkeit exzentrisch beanspruchter Ringflansch-verbindungen
      (Fatigue assessment of eccentrically loaded ring flange connections).
      Stahlbau 67 (1998), S. 191-203. https://onlinelibrary.wiley.com/doi/abs/10.1002/stab.199800690

[4]:  Petersen, C.: Stahlbau (Steel construction), 4. Auflage Braunschweig: Wiesbaden: Springer Vieweg 2012.
      https://link.springer.com/book/10.1007%2F978-3-8348-8610-1

[9]:  Tobinaga, I.; Ishihara, T.: A study of action point correction factor for Lâ€type flanges of wind turbine towers.
      Wind Energy 21 (2018), p. 801-806. https://doi.org/10.1002/we.2193


'''



from abc import ABC, abstractmethod
from dataclasses import dataclass
from functools import cache, cached_property

from .utils import Logger, log_data
logger = Logger(__name__)

import numpy as np

from .bolts import Bolt, Washer, Nut

from math import pi

import pandas as pd
#from.fatigue import SNCurve



class FlangeSegment (ABC):
    ''' Abstract FlangeSegment class.

    This class is meant to be extended and not to be instatiated directly.

    Each FlangeSegment child class must implement the two transfer-function
    methods:

    - `.bolt_axial_force(Z)`, returning the bolt axial force generated by a shell
      pull force Z
    - `.bolt_bending_moment(Z)`, returning the bolt bending moment generted by
      a shekk pull force Z
    '''

    @abstractmethod
    def bolt_axial_force (self, shell_pull):
        pass

    @abstractmethod
    def bolt_bending_moment (self, shell_pull):
        pass



class PolynomialFlangeSegment (FlangeSegment):
    ''' Generic FlangeSegment implementing polynomial transfer functions.

    This is a generic FlangeSegment that implements a polynomial relation between
    tower shell force Z and bolt axial force Fs or bolt bending moment Ms.

    It is not meant to be instantiated directly, but to be subclassed instead.

    The polynomial transfer functions `.bolt_axial_force(Z)` and
    `.bolt_bending_moment(Z)` are defined based on 4 points, through which the
    polynomials pass. Those points are implementation specific.

    The 4 reference points for the Fs(Z) polynomial are:

    - `P1 = (Z1, Fs1)` representing the flange segment state at rest (no
      loads applied, other than the self-weight). Each implementatio of
      this class should define Z1 as `shell_force_at_rest` property and
      Fs1 as `bolt_force_at_rest` property.

    - `P2 = (Z2, Fs2)` representing the flange segment ultimate tensile
      limit state (failure state B). Each implementatio of this class should
      define Z2 as `shell_force_at_tensile_ULS` property and Fs2 as
      `bolt_force_at_ultimate_ULS` property.

    - `P3 = (Z3, Fs3)` representing the flange segment in small tensile
      deformation condition. This point is meant to define the initial slope
      of the polynomial. Each implementatio of this class should
      define Z3 as `shell_force_at_small_displacement` property and Fs3 as
      `bolt_force_at_small_displacement` property.

    - `P4 = (Z4, Fs4)` representing the gap closure state. Each implementatio
      of this class should define Z4 as `shell_force_at_closed_gap` property,
      while Fs4 is automatically defined.

    The 4 reference points for the Ms(Z) polynomial are:

    - `Q1 = (Z1, Ms1)` corresponding to P1 as defined above. Each implementation
      of this class should define Ms1 as `bolt_moment_at_rest` property.

    - `Q2 = (Z2, Ms2)` corresponding to P2 as defined above. Each implementation
      of this class should define Ms2 as `bolt_moment_at_tensile_ULS` property.

    - `Q3 = (Z3, Ms3)` corresponding to P3 as defined above. Each implementation
      of this class should define Ms3 as `bolt_moment_at_small_displacement` property.

    - `Q4 = (Z4, Ms4)` corresponding to P4 as defined above. Each implementatio
      of this class should define Z4 as `shell_force_at_closed_gap` property,
      while Ms4 is automatically defined.
    '''

    def bolt_axial_force (self, shell_pull):
        ''' Bolt axial force due to a given tower shell force force Z.

        The relation between tower shell force Z and bolt axial force Fs,
        is a polynomial function, as defined in ref.[1], section 8.2 and in
        ref.[2], section G.4.2.

        The passed shell_pull parameter must be either a real number or
        a numpy.array. If a numpy.array is passed, then the corresponding
        array of Fs values will be returned.
        '''

        # Retrueve the polynomial branch in the tensile domain and the
        # polynomial branch in the compressive domain. The evaluation
        # of both polynomials is delegated to a separate getter for
        # the sake of separation of concerns and code readability.
        tens_poli = self._tensile_force_polynomial
        comp_poli = self._compressive_force_polynomial

        # The tensile polynomial is defined between Z1 and Z2, while
        # the compressive prolynomila between Zmin and Z1
        Z1, Z2 = tens_poli.domain
        Zmin = comp_poli.domain[0]

        # Calculate a vector with the same size as shell_pull, having the Fs value
        # in tensile domain where shell_value is greater than Z1 and 0 in all
        # the other cases.
        Fs_tens = tens_poli(shell_pull) * (shell_pull > Z1)

        # Calculate a vector with the same size as shell_pull, having the Fs value
        # in compressive domain where shell_value is between Zmin and Z1 and 0 in all
        # the other cases.
        Fs_comp = comp_poli(shell_pull) * (shell_pull > Zmin) * (shell_pull <= Z1)

        # Calculate a vector with the same size as shell_pull, having the Fs(Zmin)
        # value where shell_value is lower than or equal to zmin and 0 in all
        # the other cases.
        Fs_min  = comp_poli(Zmin) * (shell_pull <= Zmin)

        # Compose the three branches together and return them.
        return Fs_tens + Fs_comp + Fs_min


    def bolt_bending_moment (self, shell_pull):
        ''' Bolt bending moment due to a given tower shell force force Z.

        The relation between tower shell force force Z and bolt bending moment Ms,
        is a polynomial function, as defined in ref.[1], section 8.3 and in
        Ref.[2], section G.4.2.

        The passed shell_pull parameter must be either a real number or
        a numpy.array. If a numpy.array is passed, then the corresponding
        array of Ms values will be returned.
        '''

        # Retrueve the polynomial branch in the tensile domain and the
        # polynomial branch in the compressive domain. The evaluation
        # of both polynomials is delegated to a separate getter for
        # the sake of separation of concerns and code readability.
        tens_poli = self._tensile_moment_polynomial
        comp_poli = self._compressive_moment_polynomial

        # The tensile polynomial is defined between Z1 and Z2, while
        # the compressive prolynomila between Zmin and Z1
        Z1, Z2 = tens_poli.domain
        Zmin = comp_poli.domain[0]

        # Calculate a vector with the same size as shell_pull, having the Ms values
        # in tensile domain where shell_value is greater than Z1 and 0 in all
        # the other cases.
        Ms_tens = tens_poli(shell_pull) * (shell_pull > Z1)

        # Calculate a vector with the same size as shell_pull, having the Ms values
        # in compressive domain where shell_value is between Zmin and Z1 and 0 in all
        # the other cases.
        Ms_comp = comp_poli(shell_pull) * (shell_pull > Zmin) * (shell_pull <= Z1)

        # Calculate a vector with the same size as shell_pull, having the Ms(Zmin)
        # value where shell_value is lower than or equal to zmin and 0 in all
        # the other cases.
        Ms_min  = comp_poli(Zmin) * (shell_pull <= Zmin)

        # Compose the three branches together and return them.
        return Ms_tens + Ms_comp + Ms_min


    @cached_property
    def _tensile_force_polynomial (self):
        ''' Polynomia Fs(Z) in the tensile domain

        This getter returns the polynomial Fs(Z) defined by refs. [1] and [2]
        between point 1 (flange semgment at rest) and point 2 (ultimate
        tensile limit state of the bolt).
        '''

        from numpy.polynomial.polynomial import Polynomial
        from numpy.linalg import inv

        # The polynomial function Fs(Z) passes through the following points
        # The point getters are implementation-specific and they should be
        # defined by the child class (L-Flange class or T-Flange class).
        Z1 = self.shell_force_at_rest
        Fs1 = self.bolt_force_at_rest

        Z2 = self.shell_force_at_tensile_ULS
        Fs2 = self.bolt_force_at_tensile_ULS

        Z3 = self.shell_force_at_small_displacement
        Fs3 = self.bolt_force_at_small_displacement

        # The three fitting conditions Fs(Z1)=Fs1, Fs(Z2)=Fs2 and Fs(Z3)=Fs3
        # are written in matrix form as: Z*A=F whenre A is the coefficients
        # vector and F and Z are defined below:
        F = np.array([Fs1, Fs2, Fs3])
        Z = np.array([
            [1, Z1, Z1**2],
            [1, Z2, Z2**2],
            [1, Z3, Z3**2]])

        # The coefficients are therefore:
        a0, a1, a2 = inv(Z) @ F

        # Create and return the polynomial for the tensile domain [Z1, Z2]
        return Polynomial(
            (a0, a1, a2),       # coefficients
            domain=(Z1, Z2),    # the polynomial is defined between Z1 and Z2
            window=(Z1, Z2),
            symbol="Z")         # used to render the independent variable in serializations


    @cached_property
    def _compressive_force_polynomial (self):
        ''' Polynomia Fs(Z) in the tensile domain

        This getter returns the polynomial Fs(Z) defined by refs. [1] and [2]
        between point 1 (flange semgment at rest) and point 4 (gap closed)
        '''

        from numpy.polynomial.polynomial import Polynomial

        # Retrieve origin of the compressive polynomial
        Z1 = self.shell_force_at_rest
        Fs1 = self.bolt_force_at_rest

        # Retrieve slope of the compressive polynomial at point (Z1, Fs1)
        dtp = self._tensile_force_polynomial.deriv()    # first derivative of the tensile polynomial
        X1 = dtp(Z1)                                    # slope of the tensile polinomial at Z=Z1

        # Value of Z below which the compressive polynomial
        # becomes practically constant
        Zmin = self.shell_force_at_closed_gap

        # Compressive polynomial coefficients
        c2 = 0.5 * X1 / (Z1 - Zmin)
        c1 = X1 - 2*c2*Z1
        c0 = Fs1 - c1*Z1 - c2*Z1**2

        # Create and return the polynomial for the tensile domain [Zmin, Z1]
        return Polynomial(
            (c0, c1, c2),       # coefficients
            domain=(Zmin, Z1),  # the polynomial is defined between Zmin and Z1
            window=(Zmin, Z1),
            symbol="Z")         # used to render the independent variable in serializations


    @cached_property
    def _tensile_moment_polynomial (self):
        ''' Polynomia Ms(Z) in the tensile domain

        This getter returns the polynomial Ms(Z) defined by refs. [1] and [2]
        between point 1 (flange semgment at rest) and point 2 (ultimate
        tensile limit state of the bolt).
        '''

        from numpy.polynomial.polynomial import Polynomial
        from numpy.linalg import inv

        # The polynomial function Fs(Z) passes through the following points
        # The point getters are implementation-specific and they should be
        # defined by the child class (L-Flange class or T-Flange class).
        Z1 = self.shell_force_at_rest
        Ms1 = self.bolt_moment_at_rest

        Z2 = self.shell_force_at_tensile_ULS
        Ms2 = self.bolt_moment_at_tensile_ULS

        Z3 = self.shell_force_at_small_displacement
        Ms3 = self.bolt_moment_at_small_displacement

        # The three fitting conditions Fs(Z1)=Fs1, Fs(Z2)=Fs2 and Fs(Z3)=Fs3
        # are written in matrix form as: Z*A=F whenre A is the coefficients
        # vector and F and Z are defined below:
        M = np.array([Ms1, Ms2, Ms3])
        Z = np.array([
            [1, Z1, Z1**2],
            [1, Z2, Z2**2],
            [1, Z3, Z3**2]])

        # The coefficients are therefore:
        a0, a1, a2 = inv(Z) @ M

        # Create and return the polynomial for the tensile domain [Z1, Z2]
        return Polynomial(
            (a0, a1, a2),       # coefficients
            domain=(Z1, Z2),    # the polynomial is defined between Z1 and Z2
            window=(Z1, Z2),
            symbol="Z")         # used to render the independent variable in serializations


    @cached_property
    def _compressive_moment_polynomial (self):
        ''' Polynomia Ms(Z) in the tensile domain

        This getter returns the polynomial Ms(Z) defined by refs. [1] and [2]
        between point 1 (flange semgment at rest) and point 4 (gap closed)
        '''

        from numpy.polynomial.polynomial import Polynomial

        # Retrieve origin of the compressive polynomial
        Z1 = self.shell_force_at_rest
        Ms1 = self.bolt_moment_at_rest

        # Retrieve slope of the compressive polynomial at point (Z1, Fs1)
        dtp = self._tensile_moment_polynomial.deriv()    # first derivative of the tensile polynomial
        X1 = dtp(Z1)                                    # slope of the tensile polinomial at Z=Z1

        # Value of Z below which the compressive polynomial
        # becomes practically constant
        Zmin = self.shell_force_at_closed_gap

        # Compressive polynomial coefficients
        c2 = 0.5 * X1 / (Z1 - Zmin)
        c1 = X1 - 2*c2*Z1
        c0 = Ms1 - c1*Z1 - c2*Z1**2

        # Create and return the polynomial for the tensile domain [Zmin, Z1]
        return Polynomial(
            (c0, c1, c2),       # coefficients
            domain=(Zmin, Z1),  # the polynomial is defined between Zmin and Z1
            window=(Zmin, Z1),
            symbol="Z")         # used to render the independent variable in serializations


    @property
    @abstractmethod
    def shell_force_at_rest (self):
        pass


    @property
    @abstractmethod
    def bolt_force_at_rest (self):
        pass


    @property
    @abstractmethod
    def bolt_moment_at_rest (self):
        pass


    @property
    @abstractmethod
    def shell_force_at_small_displacement (self):
        pass


    @property
    @abstractmethod
    def bolt_force_at_small_displacement (self):
        pass


    @property
    @abstractmethod
    def bolt_moment_at_small_displacement (self):
        pass


    @property
    @abstractmethod
    def shell_force_at_tensile_ULS (self):
        pass


    @property
    @abstractmethod
    def bolt_force_at_tensile_ULS (self):
        pass


    @property
    @abstractmethod
    def bolt_moment_at_tensile_ULS (self):
        pass


    @property
    @abstractmethod
    def shell_force_at_closed_gap (self):
        pass



@dataclass
class PolynomialLFlangeSegment (PolynomialFlangeSegment):
    ''' A `PolynomialFlangeSegment` implementation for L-Flanges.

    The ploynomial model implemented in this class is based on ref. [1] and
    ref. [2].

    For this particular case of flange, this class defines the polynomial
    reference points `P1`, `P2`, `P3`, `P4`, `Q1`, `Q2`, `Q3`, `Q4` and
    inherits the polynomial functions `.bolt_axial_force(Z)` and
    `.bolt_bending_moment(Z)` from the parent class.

    Args:
        a: Distance between inner face of the flange and center of the bolt hole.

        b: Distance between center of the bolt hole and center-line of the shell.

        s: Shell thickness.

        t: Flange thickness.

        R: Shell outer curvature radius.

        central_angle: Angle subtended by the flange segment arc.

        Zg: Load applied to the flange segment shell at rest (normally dead weight
            of tower + RNA, divided by the number of bolts). Negative if compression.

        bolt: Bolt object representing the flange segment bolt.

        Fv: Design value of the preload, calculated as per ref. [2], eq. 23 or 25

        Do: Bolt hole diameter.

        washer: Washer object representing the fastener wahsers. If this parameter
            is `None`, then no washer is considered to be present.

        nut: Nut object representing the fastenrr nut.

        gap_height: Maximum longitudinal gap height.

        gap_angle: Angle subtended by the gap arc from the flange center.

        gap_shape_factor: A correction factor that applies to `Fs2-Fs1` and to
            `Fs3-Fs1` to account for gap shape different that the default sinusoidal
            shape. If omitted, it defaults to 1.0 (sinusoida shape).

        tilt_angle: Flange tilt angle, in radians.

        E: Young modulus of the flange. If omitted, it will be taken equal to 210 GPa.

        G: Shear modulus of the flange. If omitted, it will be taken equal to 80.77 GPa.

        s_ratio: Ratio of bottom shell thickness over s. If omitted, it will be taken
            equal to 1.0, threfore, by default, s_botom = s.

        r: Radius of the rouding between the shell and the flange.
    
        k_shell: Is either a stiffness value, a function or None:
            - If it is a stiffness value (e.g. calculated by a spearate FE analysis,
              it will be used as shell stiffness. The unit must be [N/m/m]. 
            - If it is a function, the value `k_shell(self)` will be used as shell
              stiffness.
            - If None or omitted, the interpolated formula from [1] will be used.

    The given parameters are also available as attributes (e.g. `fseg.a`, `fseg.Fv`, etc.).

    This class is designed to be immutable, therefore modifying the attributes after
    instantiation is not a good idea. If you need a segment with different attributes, just
    create a new one.
    '''

    a: float        # distance between inner face of the flange and center of the bolt hole
    b: float        # distance between center of the bolt hole and center-line of the shell
    s: float        # shell thickness
    t: float        # flange thickness
    R: float        # shell outer curvature radius
    central_angle: float     # angle subtended by the flange segment

    Zg: float       # load applied to the flange segment shell at rest (normally dead weight
                    # of tower + RNA, divided by the number of bolts). Negative if compression.

    bolt: Bolt      # Bolt object representing the flange segment bolt
    Fv: float       # applied bolt preload

    Do: float       # Bolt hole diameter
    washer: Washer  # Bolt washer
    nut: Nut        # Bolt nut

    gap_height: float               # maximum longitudinal gap height
    gap_angle: float                # angle subtended by the gap arc from the flange center
    gap_shape_factor: float = 1.0   # Factor accounting for a shape different than sinusoidal

    tilt_angle: float = 0.0         # angle of flange tilt

    E: float = 210e9        # Young modulus of the flange
    G: float = 80.77e9      # Shear modulus of the flange
    s_ratio: float = 1.0    # Ratio of bottom shell thickness over s. Default s_botom = s.
    r: float = 0.01         # Rounding between flange and shell
    
    k_shell: float = None       # optional initial shell stiffness in [N/m/m].


    def failure_mode (self, fy_sh, fy_fl, gamma_0=1.1):
        ''' Determine the failure mode of this flange.

        Args:
            fy_sh (float): Yield stress of the shell material.

            fy_fl (float): Yield stress of the flange material.

            gamma_0 (float): Material factor.

        Returns:
            mode (str): failure mode string (eiter "A", "B", "D" or "E").
            limits (list): The list [Zu_A, Zu_B, Zu_D, Zu_E] of the tower shell force values
                at which each failure mode occurs.
        '''

        from scipy.optimize import fsolve

        fd_sh = fy_sh / gamma_0
        fd_fl = fy_fl / gamma_0
        
        Dw = self.washer.outer_diameter if self.washer else self.nut.bearing_diameter
        a_red = self.b / (self._prying_lever_ratio - 1) #Tobinaga reduction
        b_red = self.b-self.s/2-0.8*self.r

        c_shell = self.central_angle * (self.R - self.s/2)
        c_hole = self.central_angle * (self.R - self.s/2 - self.b) - self.bolt.nominal_diameter
        c_washer = self.central_angle * (self.R - self.s/2 - self.b + (self.Do/2 + Dw/2)/2)

        # Failure mode A
        F_tRd = self.bolt.ultimate_tensile_capacity()   # Bolt ultimate tensile capacity
        Zu_A = F_tRd                                    # Ultimate tower shell force for failure mode A

        # Shell cross-section ultimate capacities
        Nu_sh = fd_sh * c_shell * self.s                 # Pure axial ultimate capacity
        Mu_sh = fd_sh * c_shell * self.s**2 / 4          # Pure bending ultimate capacity
        MNu_sh = lambda N: Mu_sh * (1 - (N / Nu_sh)**2) if N < Nu_sh else 0 # Bending ultimate capacity, concurrent with axial force

        # Flange cross-section ultimate capacity (at hole)
        Vu_fl = fd_fl * c_washer * self.t / 3**0.5                # Pure shear ultimate capacity
        Mu_fl = fd_fl * c_washer * self.t**2 / 4                  # Pure bending ultimate capacity
        MVu_fl = lambda V: Mu_fl * (1 - (V / Vu_fl)**2)**0.5 if V < Vu_fl else 0    # Bending ultimate capacity, concurrent with shear

        # Iterative calculation of the ultimate shell force, given the two functions:
        # - Zu_sh(Mu_pl3), returning the shell force at shell axial ULS, for a given value of Mu_pl3
        # - Zu_fl(Mu_pl3), returning the shell force at slange shear ULS, for a given value of Mu_pl3
        # Ref. [2], eq. G.11.
        def find_Zu (Zu_sh, Zu_fl):
            target_Zu_sh = fsolve(lambda Z: Zu_sh(MNu_sh(Z)) - Z, Zu_sh(Mu_sh))[0]
            target_Zu_fl = fsolve(lambda Z: Zu_fl(MVu_fl(Z)) - Z, Zu_fl(Mu_fl))[0]
            return min(target_Zu_sh, target_Zu_fl)

        # Failure mode B
        Zu_sh_B = lambda Mu_pl3: (F_tRd * a_red + Mu_pl3) / (a_red + self.b)
        Zu_fl_B = lambda Mu_pl3: (F_tRd * a_red + Mu_pl3) / (a_red + b_red)
        Zu_B = find_Zu(Zu_sh_B, Zu_fl_B) 

        # Failure mode D
        Mu_pl2 = fd_fl * c_hole * self.t**2 / 4
        DMu_pl2 = F_tRd/2 * (self.Do/2 + Dw/2)/2
        Zu_sh_D = lambda Mu_pl3: (Mu_pl2 + DMu_pl2 + Mu_pl3) / self.b
        Zu_fl_D = lambda Mu_pl3: (Mu_pl2 + DMu_pl2 + Mu_pl3) / b_red
        Zu_D = find_Zu(Zu_sh_D, Zu_fl_D) 

        # Failure mode E
        b_E = self.b - (self.Do+Dw)/4
        b_E_red = b_E - self.s/2 - 0.8*self.r
        Zu_sh_E = lambda Mu_pl3: (Mu_fl + Mu_pl3) / b_E
        Zu_fl_E = lambda Mu_pl3: (Mu_fl + Mu_pl3) / b_E_red
        Zu_E = find_Zu(Zu_sh_E, Zu_fl_E) 

        # Determine the governing failure mode
        Zu_min = min(Zu_A, Zu_B, Zu_D, Zu_E)

        if Zu_min == Zu_A:
            return "A",[Zu_A, Zu_B, Zu_D, Zu_E]
        elif Zu_min == Zu_B:
            return "B",[Zu_A, Zu_B, Zu_D, Zu_E]
        elif Zu_min == Zu_D:
            return "D",[Zu_A, Zu_B, Zu_D, Zu_E]
        elif Zu_min == Zu_E:
            return "E",[Zu_A, Zu_B, Zu_D, Zu_E]


    def validate (self, fy_sh, fy_fl, gamma_0=1.1):
        ''' Verifies the applicability of the polynomial model.

        Check if this L-Flange Segment matches the polynomial model assumptions,
        that is, if it fails according to failure mode B. If not, it will throw
        an exceptions.

        Args:
            fy_sh (float): Yield stress of the shell material.

            fy_fl (float): Yield stress of the flange material.

            gamma_0 (float): Material factor.

        Returns:
            (None): If successfull.

        Raises:
            ValueError: if the failure mode is not B.
        '''

        failure_mode, failure_shellforces = self.failure_mode(fy_sh, fy_fl, gamma_0=gamma_0)

        if failure_mode != "B":
            raise ValueError(f"Failure mode {failure_mode} detected, while only failure mode B is supported.")


    @cached_property
    def _bolt_axial_stiffness (self):
        tw = self.washer.thickness if self.washer else 0
        return self.bolt.axial_stiffness(2*self.t + 2*tw)


    @cached_property
    def _bolt_bending_stiffness (self):
        tw = self.washer.thickness if self.washer else 0
        return self.bolt.bending_stiffness(2*self.t + 2*tw)


    @cached_property
    def _flange_axial_stiffness (self):
        # Stiffnes of flange w.r.t. compression in thickness direction,
        # when no gap is present. Calculated according to ref. [3] and [4].
        from math import pi, inf
        Dw = self.washer.outer_diameter if self.washer else self.nut.bearing_diameter
        Do = self.Do
        h = self.t * 2
        A = pi * ((Dw + h/10)**2 - Do**2) / 4
        Kf = self.E * A / h
        Kw = self.washer.axial_stiffness if self.washer else inf
        return 1 / (1/Kf + 2 * 1/Kw)


    def _bolt_moment (self, Z, Fs):
        a_red = self.b / (self._prying_lever_ratio - 1)
        a_star = max(0.4, min((self.t / (a_red + self.b))**2 , 1)) * a_red
        s_avg = self.s * (1 + self.s_ratio) / 2
        c = self.central_angle * (self.R - s_avg/2)
        I_tg = c * self.t**3 / 12
        ak = self._stiffness_correction_factor
        bolt_rotation = Z*self.b*a_star / (3*self.E*I_tg*ak) + (Fs - self.Fv) / (2*a_star*self._bolt_axial_stiffness)

        log_data(self, a_star=a_star, I_tg=I_tg)

        return bolt_rotation * 2*self._bolt_bending_stiffness


    @cached_property
    def shell_force_at_rest (self):
        ''' Shell force when no external loads are applied

        The shell loads at rest are normally the self-weights of
        the structure supported by the flange.
        '''
        return self.Zg


    @cached_property
    def bolt_force_at_rest (self):
        ''' Bolt axial force when no external loads are applied.

        The bolt force at rest is just the bolt pretension.
        '''
        return self.Fv


    @cached_property
    def bolt_moment_at_rest (self):
        ''' Bolt bending moment when no external loads are applied.'''

        Z1 = self.shell_force_at_rest
        Fs1 = self.bolt_force_at_rest
        return self._bolt_moment(Z1, Fs1)


    @cached_property
    def shell_force_at_small_displacement (self):
        ''' Intermediate tower shell force, between rest and tensile failure.

        This is an auxiliary point that gives the polynomial the right
        value of initial slope. It is evaluated according to ref. [1],
        sec.8.2.2.3 and to ref. [2], section G.4.2.
        '''

        # Retrieve point 2A (called point 0 in [1]) and determine Z as
        # a low pecentage of the theoretical pull Z0.
        Z0 = self._ideal_shell_force_at_tensile_ULS
        return 0.05 * self._stiffness_correction_factor * Z0


    @cached_property
    def bolt_force_at_small_displacement (self):
        ''' Intermediate bolt pull, between rest and tensile failuse.

        This is an auxiliary point that gives the polynomial the right
        value of initial slope. It is evaluated according to ref. [1],
        sec.8.2.2.3 and to ref. [2], section G.4.2.
        '''

        # The slope between points P1 and P3 should match the
        # theoretical value of stiffness of the system.
        Z = self.shell_force_at_small_displacement
        return self.Fv + self._polynomial_initial_slope * (Z - self.Zg)


    @cached_property
    def bolt_moment_at_small_displacement (self):
        ''' Intermediate bolt moment, between rest and tensile failuse.

        This is the bolt bending moment corresponding to the tower shell force
        Z3 (`.shell_force_at_small_displacement`).
        '''

        Z3 = self.shell_force_at_small_displacement
        Fs3 = self.bolt_force_at_small_displacement
        return self._bolt_moment(Z3, Fs3)


    @cached_property
    def shell_force_at_tensile_ULS (self):
        ''' Ultimate Limit State tower shell force.

        This is tower shell force that brings the flange segment system in
        its tensile ultimate limit state. It is evaluated according
        to ref. [1], sec.8.2.2.2 and to ref. [2], section G.4.2, where
        it is referred to as Z2.
        '''

        Z0 = self._ideal_shell_force_at_tensile_ULS
        Z2 = self._stiffness_correction_factor * max(
            Z0 + self._total_gap_neutralization_shell_force,
            0.2 * Z0)
        return min(Z0, Z2)


    @cached_property
    def bolt_force_at_tensile_ULS (self):
        ''' Bolt axial force at tensile failure.

        This is the bolt tensile force corresponding to the ultimate
        tower shell force (`.shell_force_at_rensile_ULS`).

        Assuming the failure mode B, in the ULS, the bolt is subjected
        to its maximum tensile capacity.

        In refs. [1] and [2], this value is colled Fs2.
        '''

        # Bolt force at tensile ULS for sinusoidal gap shape
        Fs2 = self._ideal_bolt_force_at_tensile_ULS

        # Scale Fs2 based on the gap shape
        Fs1 = self.bolt_force_at_rest
        return Fs1 + (Fs2 - Fs1) * self.gap_shape_factor


    @cached_property
    def bolt_moment_at_tensile_ULS (self):
        ''' Bolt bending moment at tensile failure.

        This is the bolt bending moment corresponding to the ultimate
        tower shell force (`.shell_force_at_rensile_ULS`).

        In refs. [1] and [2], this value is colled Ms2.
        '''

        Z2 = self.shell_force_at_tensile_ULS
        Fs2 = self.bolt_force_at_tensile_ULS
        return self._bolt_moment(Z2, Fs2)


    @cached_property
    def shell_force_at_closed_gap (self):
        ''' Shell force necessary to completely close the imperfection gap.'''
        return self.shell_force_at_rest + self._total_gap_neutralization_shell_force


    @cached_property
    def _total_gap_neutralization_shell_force (self):
        # Incremental force necessary to completely close the imperfection gap
        # This is the `delta-Z_gap,total` variable defined in ref. [1].
        MAXIMUM_GAP_NEUTRALIZATION_SHELL_FORCE = -1000 # 1 kN
        return min(self._parallel_gap_neutralization_shell_force - self._tilt_neutralization_shell_force,
                   MAXIMUM_GAP_NEUTRALIZATION_SHELL_FORCE)


    @cached_property
    def _parallel_gap_neutralization_shell_force (self):
        ''' Force necessary to completely close the imperfection gap '''
        s_avg = self.s * (1 + self.s_ratio) / 2
        c = self.central_angle * (self.R - s_avg/2)
        return -0.5 * self._gap_stiffness * self.gap_height * c


    @cached_property
    def _tilt_neutralization_shell_force (self):
        ''' Forces that neutralized the flange tilt

        This function solves equation (G.64) of ref. [2] to determine
        the force DZ_gap,incl that neutralizes the initial tilt.
        '''

        # The equation to be solved is A*[inv(B)*C]*M = D,
        # where A and B are 2x2 matrices, C and D are 2x1 matrices
        # and M is the scalar to be determined

        # General parameters
        s_mean = self.s * (1+self.s_ratio)/2
        w = self.a + self.b + self.s/2
        Af = w * self.t
        If = w * self.t**3 / 12
        R_sh = self.R - s_mean/2
        R_fl = self.R - w/2
        nu = self.E / (2*self.G) - 1
        k = self.E * s_mean**3 / (12*(1-nu**2))
        n = (3*(1-nu**2))**0.25 / (R_sh * s_mean)**0.5

        # Matrix A
        a11 = 1 / (2*k*n**3)
        a12 = 1 / (2*k*n**2)
        a21 = a12
        a22 = 1 / (k*n)
        A = np.array([[a11, a12],
                    [a21, a22]])

        # Matrix B
        b11 = a11 + R_fl * R_sh / (self.E * Af)
        b12 = a12
        b21 = a12
        b22 = a22 + R_fl * R_sh / (self.E * If)
        B = np.array([[b11, b12],
                    [b21, b22]])

        # Matrix C
        c1 = 0
        c2 = R_fl**2 / (self.E * If)
        C = np.array([c1, c2])

        # Matrix D
        d1 = 0.001    # ux: dummy value, sice irrelevant
        d2 = self.tilt_angle
        D = np.array([d1, d2])

        # Reduce matrix equation to H*M = D
        H = A @ (np.linalg.inv(B) @ C)

        # The last equation of the system H*M = D is h2*M = d2 and
        # we can therefore determine M from it as d2/h2:
        M = d2 / H[1]

        # Return the tower shell force force corresponding to M
        c = self.central_angle * R_sh
        b_mean = self.b + self.s/2 - s_mean/2
        return -c * M / (s_mean/2 + b_mean)

    
    @cached_property
    def _ideal_bolt_force_at_tensile_ULS (self):
        ''' Bolt axial force at tensile failure for sinusoidal gap shape

        Assuming the failure mode B, in the ULS, the bolt is subjected
        to its maximum tensile capacity.
        '''
        return max(self.bolt.ultimate_tensile_capacity(), 1.25*self.bolt_force_at_rest)


    @cached_property
    def _ideal_shell_force_at_tensile_ULS (self):
        ''' Tower shell force force at the theoretical state of full prying

        This property represents the tower shell force forces when the flange segment
        is in tensile ULS and in the ideal situation of no gap.

        This variable is indicated as Z0 in refs. [1] and [2].
        '''
        return self._ideal_bolt_force_at_tensile_ULS / self._prying_lever_ratio


    @cached_property
    def _prying_lever_ratio (self):
        ''' Lever ratio A, as defined in [9]'''

        # Ref. [9] uses different symbolts than ref. [1].
        # This getter uses the symbols defined in ref. [9].
        e = self.a
        g = self.b

        # The flange is considered rigid if e <= 1.25*g.
        # In a rigid flange, the pivid point is the edge, therefore e_reduced = e.
        if e/g <= 1.25:
            return (e + g) / e

        # For e > 2.25*g, the model defined in ref. [9] has not been
        # validated. A warning is thrown, but then the model is applied
        # anyways.
        if e/g > 2.25:
            logger.warning("Flange geometry out of validity range for Tobinaga & Ishihara lever ratio formulation: e/g > 2.25.")

        # Coefficient a, expressing the slenderness of the longitudinal
        # cross-section of this flange-segment as tatio between thickness
        # and length.
        a = min(self.t / (e+g), 1.0)
        if a < 0.55 - 0.12 * (e/g):
            # When outside the boundary of validations, throw a warning, but then
            # apply the model anyways.
            logger.warning("Flange geometry out of validity range for Tobinaga & Ishihara lever ratio formulation: a < 0.55 - 0.12 * (e/g).")

        # Evaluate the ratio between distance e (pivit point location for rigid body rotation)
        # and the acctual center of reaction at the prying contact location.
        b = (e/g - 1.25)**0.32 + 0.45
        actionpoint_correction_factor = min(1 - (1 - a**b)**5, 1.0)

        # Distance from the center of reaction at prying contact location, form
        # the center of bolt hole.
        e_reduced = actionpoint_correction_factor * e

        # Lever ratio
        return (e_reduced + g) / e_reduced


    @cached_property
    def _gap_stiffness (self):
        ''' Stiffness of the design gap.

        Returns the gap stiffnes as a spring constant per unit of flange-segment
        arc length. This is calculated according to ref.[1], sec.8.1 and to
        ref.[2], eq.G.35.
        '''

        # Calculate the shell stiffness
        s_avg = (self.s + self.s_ratio * self.s) / 2    # Average shell thickness
        L_gap = self.R * self.gap_angle                 # Gap lenght at mid-line of shell with average thickness
        k_fac = max(1.8, 1.3 + (8.0e-4 - 1.6e-7 * (self.R*1000)) * (L_gap*1000))    # ref. [1], eq.48A
        try:
            k_shell = float(self.k_shell)
        except Exception:
            k_shell = self.k_shell(self) if callable(self.k_shell) else self.E * s_avg / (k_fac * L_gap)

        # Calculate the flange stiffness
        w = self.a + self.b + self.s/2      # flange segment length
        A = w * self.t                      # flange segment longitudinal cross-section area
        I = w * self.t**3 / 12              # flange segment longitudinal corss-section second moment of area
        EI = self.E * I
        GA = self.G * A
        L2 = L_gap**2
        k_flange = 384 * EI * GA / (L2 * (GA*L2 + 48*EI))   # ref. [1], eq.49

        # Stiffness correction factor
        f_tot = min(1.0 + 1.5 * self.gap_angle/(pi/2), 2.5) * min(self.gap_angle/(pi/6), 1)**2

        log_data(self, L_gap=L_gap, k_fac=k_fac, k_shell_ini=k_shell, A_cf=A, I_cf=I, k_fl=k_flange, f_tot=f_tot)

        # Total gap stiffness according to ref. [1], eq.53
        return f_tot * (k_shell + k_flange)


    @cached_property
    def _stiffness_correction_factor (self):
        ''' Stiffness corrections factor.

        This factor, modifies the segment force to accorunt for the
        effect of the gap spring. It is evaluate according to ref. [1],
        sec.8.2.2.2 and ref. [2], eq.G.46,  where it goes by the symbol alpha-k.
        '''

        from math import pi

        # Retrieve point P0
        Z0 = self._ideal_shell_force_at_tensile_ULS
        Fs0 = self._ideal_bolt_force_at_tensile_ULS

        # Evaluate the displacement u in the ultimate prying state.
        a_red = self.b / (self._prying_lever_ratio - 1)
        s_avg = self.s * (1 + self.s_ratio) / 2
        c = self.central_angle * (self.R - s_avg/2)
        I = c * self.t**3 / 12
        u = (Z0 * self.b**2 / (3 * self.E * I) + (Fs0 - self.Fv) / (2 * self._bolt_axial_stiffness * a_red)) * (a_red + self.b)   # ref. [1], eq.72

        # Evaluate the segment stiffness
        s_avg = (self.s + self.s_ratio * self.s) / 2
        c = self.central_angle * (self.R - s_avg/2)
        k_seg = Z0 / (u * c)

        log_data(self, u=u, k_seg=k_seg)

        # Return the stiffness correction factor, acc. [1], eq.75
        return min(1 + self._gap_stiffness / k_seg,
                   4 * pi/3 / self.gap_angle)


    @cached_property
    def _polynomial_initial_slope (self):
        ''' Initial slope of the polynomial Fs(Z).

        This slope is calculated according to ref. [1], section 8.2.2.3
        and ref. [2], eq.G.53.
        '''

        # Load factor of the tension spring
        Ks = self._bolt_axial_stiffness
        Kp = self._flange_axial_stiffness
        p = Ks / (Ks + Kp)

        # Initial slope correction factor
        scf = -self._total_gap_neutralization_shell_force / (0.5 * self.Fv)

        # Maximum allowable value of p
        p_max = (self.bolt_force_at_tensile_ULS - self.bolt_force_at_rest) / (self.shell_force_at_tensile_ULS - self.shell_force_at_rest)

        # Initial slope
        return min(scf*p, p_max) * self.gap_shape_factor



@dataclass
class PolynomialTFlangeSegment (PolynomialFlangeSegment):
    ''' A `PolynomialFlangeSegment` implementation for T-Flanges.

    The ploynomial model implemented in this class is based on ref. [1] and
    ref. [2].

    For this particular case of flange, this class defines the polynomial
    reference points `P1`, `P2`, `P3`, `P4`, `Q1`, `Q2`, `Q3`, `Q4` and
    inherits the polynomial functions `.bolt_axial_force(Z)` and
    `.bolt_bending_moment(Z)` from the parent class.

    Args:
        a: Distance between inner face of the flange and center of the bolt hole.

        b: Distance between center of the bolt hole and center-line of the shell.

        s: Shell thickness.

        t: Flange thickness.

        R: Shell outer curvature radius.

        central_angle: Angle subtended by the flange segment arc.

        Zg: Load applied to the flange segment shell at rest (normally dead weight
            of tower + RNA, divided by the number of bolts). Negative if compression.

        bolt: Bolt object representing the flange segment bolt.

        Fv: Design value of the preload, calculated as per ref. [2], eq. 23 or 25

        Do: Bolt hole diameter.

        washer: Washer object representing the fastener wahsers. If this parameter
            is `None`, then no washer is considered to be present.

        nut: Nut object representing the fastenrr nut.

        gap_height: Maximum longitudinal gap height.

        gap_angle: Angle subtended by the gap arc from the flange center.

        gap_shape_factor: A correction factor that applies to `Fs2-Fs1` and to
            `Fs3-Fs1` to account for gap shape different that the default sinusoidal
            shape. If omitted, it defaults to 1.0 (sinusoida shape).

        tilt_angle: Flange tilt angle, in radians.

        E: Young modulus of the flange. If omitted, it will be taken equal to 210 GPa.

        G: Shear modulus of the flange. If omitted, it will be taken equal to 80.77 GPa.

        s_ratio: Ratio of bottom shell thickness over s. If omitted, it will be taken
            equal to 1.0, threfore, by default, s_botom = s.

        r: Radius of the rouding between the shell and the flange.

        k_shell: Optional individual initial shell stiffness value. This value can be
            calculated in a separate FE analysis. The unit must be [N/m/m]. If omitted,
            the interpolated formula from [1] will be used.

    The given parameters are also available as attributes (e.g. `fseg.a`, `fseg.Fv`, etc.).

    This class is designed to be immutable, therefore modifying the attributes after
    instantiation is not a good idea. If you need a segment with different attributes, just
    create a new one.
    '''

    a: float        # distance between inner face of the flange and center of the bolt hole
    b: float        # distance between center of the bolt hole and center-line of the shell
    s: float        # shell thickness
    t: float        # flange thickness
    R: float        # shell outer curvature radius
    central_angle: float     # angle subtended by the flange segment

    Zg: float       # load applied to the flange segment shell at rest (normally dead weight
                    # of tower + RNA, divided by the number of bolts). Negative if compression.

    bolt: Bolt      # Bolt object representing the flange segment bolt
    Fv: float       # applied bolt preload

    Do: float       # Bolt hole diameter
    washer: Washer  # Bolt washer
    nut: Nut        # Bolt nut

    gap_height: float   # maximum longitudinal gap height
    gap_angle: float    # angle subtended by the gap arc from the flange center
    gap_shape_factor: float = 1.0   # Factor accounting for a shape different than sinusoidal
    
    tilt_angle : float = 0.0    # angle of flange tilt

    E: float = 210e9    # Young modulus of the flange
    G: float = 80.77e9  # Shear modulus of the flange
    s_ratio: float = 1.0    # Ratio of bottom shell thickness over s. Default s_botom = s.

    r: float = 0.01 #rounding between flange and shell
    
    k_shell: float = None       # optional initial shell stiffness in [N/m/m].

    def failure_mode (self, fy_sh, fy_fl,gamma_0 = 1.1):
        ''' Determine the failure mode of this flange.

        Args:
            fy_sh (float): Yield stress of the shell material.

            fy_fl (float): Yield stress of the flange material.

            gamma_0 (float): Material factor.

        Returns:
            mode (str): failure mode string (eiter "A", "B", "D" or "E").
            limits (list): The list [Zu_A, Zu_B, Zu_D, Zu_E] of the tower shell force values
                at which each failure mode occurs.
        '''

        from scipy.optimize import fsolve

        fd_fl = fy_fl / gamma_0
        
        Dw = self.washer.outer_diameter if self.washer else self.nut.bearing_diameter
        a_red = self.b / (self._prying_lever_ratio - 1) #Tobinaga reduction
        b_E = self.b-(self.Do+Dw)/4
        b_red = self.b-self.s/2-0.8*self.r
        
        c_hole = self.central_angle * (self.R - self.s/2 - self.b) - self.bolt.nominal_diameter
        c_washer = self.central_angle * (self.R - self.s/2 - self.b + (self.Do/2 + Dw/2)/2)

        # Failure mode A
        F_tRd = self.bolt.ultimate_tensile_capacity()   # Bolt ultimate tensile capacity
        Zu_A = 2*F_tRd                                    # Ultimate tower shell force for failure mode A

        # Flange cross-section ultimate capacity (at hole)
        Vu_fl = fd_fl * c_washer * self.t / 3**0.5                # Pure shear ultimate capacity
        Mu_fl = fd_fl * c_washer * self.t**2 / 4                  # Pure bending ultimate capacity
        MVu_fl = lambda V: Mu_fl * (1 - (V / Vu_fl)**2)**0.5 if V < Vu_fl else 0    # Bending ultimate capacity, concurrent with shear

        # Failure mode B
        Zu_fl_B = lambda Mu_pl3: (F_tRd * a_red + Mu_pl3) / (a_red + b_red)
        Zu_B = 2 * fsolve(lambda Z: Zu_fl_B(MVu_fl(Z)) - Z, Zu_fl_B(Mu_fl))[0]

        # Failure mode D
        Mu_pl2 = fd_fl * c_hole * self.t**2 / 4
        DMu_pl2 = F_tRd/2 * (self.Do/2 + Dw/2)/2
        Zu_fl_D = lambda Mu_pl3: 2*(Mu_pl2 + DMu_pl2 + Mu_pl3) / b_red
        Zu_D = 2 * fsolve(lambda Z: Zu_fl_D(MVu_fl(Z)) - Z, Zu_fl_D(Mu_fl))[0]

        # Failure mode E
        Zu_fl_E = lambda Mu_pl3: 2*(Mu_fl + Mu_pl3) / b_E
        Zu_E = 2 * fsolve(lambda Z: Zu_fl_E(MVu_fl(Z)) - Z, Zu_fl_E(Mu_fl))[0]

        # Determine the governing failure mode
        Zu_min = min(Zu_A, Zu_B, Zu_D, Zu_E)

        if Zu_min == Zu_A:
            return "A",(Zu_A, Zu_B, Zu_D, Zu_E)
        elif Zu_min == Zu_B:
            return "B",(Zu_A, Zu_B, Zu_D, Zu_E)
        elif Zu_min == Zu_D:
            return "D",(Zu_A, Zu_B, Zu_D, Zu_E)
        elif Zu_min == Zu_E:
            return "E",(Zu_A, Zu_B, Zu_D, Zu_E)

    def validate (self, fy_sh, fy_fl,gamma_0 = 1.1):
        ''' Verifies the applicability of the polynomial model.

        Check if this L-Flange Segment matches the polynomial model assumptions,
        that is, if it fails according to failure mode B. If not, it will throw
        an exceptions.

        Args:
            fy_sh (float): Yield stress of the shell material.

            fy_fl (float): Yield stress of the flange material.

            gamma_0 (float): Material factor.

        Returns:
            (None): If successfull.

        Raises:
            ValueError: if the failure mode is not B.
        '''

        failure_mode,failure_shellforces = self.failure_mode(fy_sh, fy_fl,gamma_0=gamma_0)

        if failure_mode != "A":
            raise ValueError(f"Failure mode {failure_mode} detected, while only failure mode A is supported.")


    @cached_property
    def _bolt_axial_stiffness (self):
        tw = self.washer.thickness if self.washer else 0
        return self.bolt.axial_stiffness(2*self.t + 2*tw)


    @cached_property
    def _bolt_bending_stiffness (self):
        tw = self.washer.thickness if self.washer else 0
        return self.bolt.bending_stiffness(2*self.t + 2*tw)
    

    @cached_property
    def _flange_axial_stiffness (self):
        # Stiffnes of flange w.r.t. compression in thickness direction,
        # when no gap is present. Calculated according to ref. [3] and [4].
        from math import pi, inf
        Dw = self.washer.outer_diameter if self.washer else self.nut.bearing_diameter
        Do = self.Do
        h = self.t * 2
        A = pi * ((Dw + h/10)**2 - Do**2) / 4
        Kf = self.E * A / h
        Kw = self.washer.axial_stiffness if self.washer else inf
        return 1 / (1/Kf + 2 * 1/Kw)


    def _bolt_moment (self, Z, Fs):
        a_red = self.b / (self._prying_lever_ratio - 1)
        a_star = max(0.4, min((self.t / (a_red + self.b))**2 , 1)) * a_red

        s_avg = self.s * (1 + self.s_ratio) / 2
        c = self.central_angle * (self.R - s_avg/2)
        A_tg= c *self.t
        I_tg = c * self.t**3 / 12

        ak = self._stiffness_correction_factor

        phi_T_low=(Fs-self.Fv)*( self.b**2/(2*self.E*I_tg) + 1/(0.85*self.G*A_tg) )
        phi_T_high=Z*( self.b**2/(ak*4*self.E*I_tg) + 1/(0.85*self.G*A_tg) )

        Z0 = self._ideal_shell_force_at_tensile_ULS
        Z_close=self.shell_force_at_closed_gap
        
        bolt_rotation=phi_T_low+(phi_T_high-phi_T_low)/(Z0-Z_close)*(Z-Z_close)

        log_data(self, a_star=a_star)

        return bolt_rotation * 2*self._bolt_bending_stiffness

    @cached_property
    def shell_force_at_rest (self):
        ''' Shell force when no external loads are applied.

        The shell loads at rest are normally the self-weights of the structure
        supported by the flange.
        '''
        return self.Zg

    @cached_property
    def bolt_force_at_rest (self):
        ''' Bolt axial force when no external loads are applied.

        The bolt force at rest is just the bolt pretension.
        '''
        return self.Fv

    @cached_property
    def bolt_moment_at_rest (self):
        ''' Bolt bending moment when no external loads are applied. '''

        Z1 = self.shell_force_at_rest
        Fs1 = self.bolt_force_at_rest
        return self._bolt_moment(Z1, Fs1)

    @cached_property
    def shell_force_at_small_displacement (self):
        ''' Intermediate tower shell force, between rest and tensile failure.

        This is an auxiliary point that gives the polynomial the right
        value of initial slope. It is evaluated according to ref. [1],
        sec.8.2.2.3 and to ref. [2], section G.4.2.
        '''

        # Retrieve point 2A (called point 0 in [1]) and determine Z as
        # a low pecentage of the theoretical pull Z0.
        Z0 = self._ideal_shell_force_at_tensile_ULS
        return 0.05 * self._stiffness_correction_factor * Z0

    @cached_property
    def bolt_force_at_small_displacement (self):
        ''' Intermediate bolt pull, between rest and tensile failuse.

        This is an auxiliary point that gives the polynomial the right
        value of initial slope. It is evaluated according to ref. [1],
        sec.8.2.2.3 and to ref. [2], section G.4.2.
        '''

        # The slope between points P1 and P3 should match the
        # theoretical value of stiffness of the system.
        Z = self.shell_force_at_small_displacement
        Fs3 = self.Fv + self._polynomial_initial_slope * (Z - self.Zg)

        # Scale Fs3 based on the gap shape
        Fs1 = self.bolt_force_at_rest
        return Fs1 + (Fs3 - Fs1)

    @cached_property
    def bolt_moment_at_small_displacement (self):
        ''' Intermediate bolt moment, between rest and tensile failuse.

        This is the bolt bending moment corresponding to the tower shell force
        Z3 (`.shell_force_at_small_displacement`).
        '''

        Z3 = self.shell_force_at_small_displacement
        Fs3 = self.bolt_force_at_small_displacement
        return self._bolt_moment(Z3, Fs3)

    @cached_property
    def shell_force_at_tensile_ULS (self):
        ''' Ultimate Limit State tower shell force.

        This is the tower shell force that brings the flange segment system in
        its tensile ultimate limit state. It is evaluated according
        to ref. [1], sec.8.2.2.2 and to ref. [2], section G.4.2, where
        it is referred to as Z2.
        '''

        Z0 = self._ideal_shell_force_at_tensile_ULS
        Z2 = self._stiffness_correction_factor * max(
            Z0 + self._total_gap_neutralization_shell_force,
            0.2 * Z0)
        return min(Z0, Z2)
    
    @cached_property
    def bolt_force_at_tensile_ULS (self):
        ''' Bolt axial force at tensile failure.

        This is the bolt tensile force corresponding to the ultimate
        tower shell force (`.shell_force_at_rensile_ULS`).

        Assuming the failure mode B, in the ULS, the bolt is subjected
        to its maximum tensile capacity.

        In refs. [1] and [2], this value is colled Fs2.
        '''

        # Bolt force at tensile ULS for sinusoidal gap shape
        Fs2 = self._ideal_bolt_force_at_tensile_ULS

        # Scale Fs2 based on the gap shape
        Fs1 = self.bolt_force_at_rest
        return Fs1 + (Fs2 - Fs1) * self.gap_shape_factor

    @cached_property
    def bolt_moment_at_tensile_ULS (self):
        ''' Bolt bending moment at tensile failure.

        This is the bolt bending moment corresponding to the ultimate
        tower shell force (`.shell_force_at_rensile_ULS`).

        In refs. [1] and [2], this value is colled Ms2.
        '''

        Z2 = self.shell_force_at_tensile_ULS
        Fs2 = self.bolt_force_at_tensile_ULS
        return self._bolt_moment(Z2, Fs2)

    @cached_property
    def shell_force_at_closed_gap (self):
        ''' Shell force necessary to completely close the imperfection gap. '''
        return self.shell_force_at_rest + self._total_gap_neutralization_shell_force

    @cached_property
    def _total_gap_neutralization_shell_force (self):
        
        delta_Z_gap=self._parallel_gap_neutralization_shell_force
        delta_Z_gap_c=self._tilt_neutralization_shell_force
        delta_Z_gap_incl=self._early_prying_neutralization_shell_force
        
        #total shell force at closed gap
        delta_Z_gap_tot=delta_Z_gap+delta_Z_gap_c+delta_Z_gap_incl

        return delta_Z_gap_tot
    
    @cached_property
    def _parallel_gap_neutralization_shell_force (self):
        ''' Force necessary to completely close the imperfection gap '''
        s_avg = self.s * (1 + self.s_ratio) / 2
        c = self.central_angle * (self.R - s_avg/2)
        return -0.5 * self._gap_stiffness * self.gap_height * c
    
    @cached_property
    def _tilt_neutralization_shell_force (self):
        # Calculate geometric properties               
        Rm= self.R - self.s/2
        c_m=self.central_angle*Rm
        w=2*(self.a+self.b)

        #Reduction due to inclination (58)
        #shell parameters (56) & (57)
        K=self.E*self.s**3/(12*(1-0.3**2))
        n=((3*(1-0.3**2))**0.25)/((Rm*self.s)**0.5)

        d11=1/(2*K*n**3)+Rm**2/(self.E*w*self.t)
        d22=1/(K*n)+12*Rm**2/(self.E*w*self.t**3)
        c12=1/(2*K*n**2)
        c22=1/(K*n)

        d02=self.tilt_angle * (d11*d22-c12**2)/(c22*d11-c12**2)
        M_tilt=d02*(self.E*w*self.t**3)/(12*Rm**2)
        delta_Z_gap_incl=-M_tilt*c_m/(w/2+self.b)
        
        log_data(self, M_tilt=M_tilt)
        
        return delta_Z_gap_incl
    
    @cached_property
    def _early_prying_neutralization_shell_force (self):
        '''Increase of the gap closing force to consider the reduced efficiency 
        of the preload due to early prying at the edges. This needs only to
        be considered for T-Flanges
        '''
        # Calculate geometric properties                
        Rm= self.R - self.s/2
        c_m=self.central_angle*Rm
        A_tg= c_m *self.t
        I_tg = c_m * self.t**3 / 12
       
        # Calculate the gap stiffness
        alpha_gap=self.gap_angle*180/pi
        f_tot= min(1 + alpha_gap/90 *1.5,2.5)
        k_gap=self._gap_stiffness/f_tot                 #total gap stiffness, without the adjustment factor of 2.2 acc. to [1] eq.26

        #Preload force at which edge contact occurs (31)
        Fv_c=0.5*self.gap_height/( self.b**3/(3*self.E*I_tg) + self.b**2*self.a/(2*self.E*I_tg) + 1.2*self.b/(self.G*A_tg) + 1/(c_m*(k_gap)) )

        #Reduction due to early prying (30)
        delta_Z_gap_c=-max((self.Fv-Fv_c) * ((3*self.a+2*self.b)*self.b**2/(2*(self.a+self.b)**3)),0)
        
        log_data(self, Fv_c=Fv_c, A_tg=A_tg, I_tg=I_tg)
        
        return delta_Z_gap_c
    
    @cached_property
    def _ideal_bolt_force_at_tensile_ULS (self):
        # The bolt is loaded with the ultimate capacity, by definition.
        # If the pretension Fv is too close to the ultimate capacity Fsu, the polynomial
        # function may get too steep, therefore we make sure that Fs2 is at list 125% of Fv.
        return max(self.bolt.ultimate_tensile_capacity(), 1.25*self.bolt_force_at_rest)
    
    @cached_property
    def _ideal_shell_force_at_tensile_ULS (self):
        return self._ideal_bolt_force_at_tensile_ULS * 2

    @cached_property
    def _prying_lever_ratio (self):
        ''' Lever ratio A, as defined in [9]'''

        # Ref. [9] uses different symbolts than ref. [1].
        # This getter uses the symbols defined in ref. [9].
        e = self.a
        g = self.b

        # The flange is considered rigid if e <= 1.25*g.
        # In a rigid flange, the pivid point is the edge, therefore e_reduced = e.
        if e/g <= 1.25:
            return (e + g) / e

        # For e > 2.25*g, the model defined in ref. [9] has not been
        # validated. A warning is thrown, but then the model is applied
        # anyways.
        if e/g > 2.25:
            logger.warning("Flange geometry out of validity range for Tobinaga & Ishihara lever ratio formulation: e/g > 2.25.")

        # Coefficient a, expressing the slenderness of the longitudinal
        # cross-section of this flange-segment as tatio between thickness
        # and length.
        a = min(self.t / (e+g), 1.0)
        if a < 0.55 - 0.12 * (e/g):
            # When outside the boundary of validations, throw a warning, but then
            # apply the model anyways.
            logger.warning("Flange geometry out of validity range for Tobinaga & Ishihara lever ratio formulation: a < 0.55 - 0.12 * (e/g).")

        # Evaluate the ratio between distance e (pivit point location for rigid body rotation)
        # and the acctual center of reaction at the prying contact location.
        b = (e/g - 1.25)**0.32 + 0.45
        actionpoint_correction_factor = min(1 - (1 - a**b)**5, 1.0)

        # Distance from the center of reaction at prying contact location, form
        # the center of bolt hole.
        e_reduced = actionpoint_correction_factor * e

        # Lever ratio
        return (e_reduced + g) / e_reduced

    @cached_property
    def _gap_stiffness (self):
        ''' Stiffness of the design gap.

        Returns the gap stiffnes as a spring constant per unit of flange-segment
        arc length. This is calculated according to ref.[1], sec.9.1.
        '''

        # Calculate the shell stiffness
        #Rm = self.R - self.s/2   # radius of the shell midline
        #L_gap = Rm * self.gap_angle
        L_gap = self.R * self.gap_angle
        #k_fac = max(1.8, 1.3 + (8.0e-4 - 1.6e-7 * (Rm*1000)) * (L_gap*1000))    # ref. [1], eq.48
        k_fac = max(1.8, 1.3 + (8.0e-4 - 1.6e-7 * (self.R*1000)) * (L_gap*1000))    # ref. [1], eq.48
        s_avg = (self.s + self.s_ratio * self.s) / 2
        k_shell = self.k_shell or self.E * s_avg / (k_fac * L_gap)                   # ref. [1], eq.47

        # Calculate the flange stiffness
        w = (self.a + self.b)*2      # flange segment length
        A = w * self.t                      # flange segment longitudinal cross-section area
        I = w * self.t**3 / 12              # flange segment longitudinal corss-section second moment of area
        EI = self.E * I
        GA = self.G * A
        L2 = L_gap**2
        k_flange = 384 * EI * GA / (L2 * (GA*L2 + 48*EI))   # ref. [1], eq.49
        
        alpha_gap=self.gap_angle*180/pi
        f_tot= min(1 + alpha_gap/90 *1.5,2.5)
        
        log_data(self, L_gap=L_gap, k_fac=k_fac, k_shell_ini=k_shell, A_cf=A, I_cf=I, k_fl=k_flange, f_tot=f_tot)

        # Total gap stiffness according to ref. [1], eq.53
        return f_tot * (k_shell + k_flange)

    @cached_property
    def _stiffness_correction_factor (self):
        ''' Stiggness corrections factor.

        This factor, modifies the segment force to accorunt for the
        effect of the gap spring. It is evaluate according to ref. [1],
        sec.9.2.2.2, where it goes by the symbol alpha-k.
        '''

        from math import pi

        Rm= self.R - self.s/2
        cm=self.central_angle*Rm

        # Retrieve point 2B
        Z0 = self._ideal_shell_force_at_tensile_ULS
        # Z2B=max(Z0 + self._parallel_gap_neutralization_shell_force,
        #         0.2 * Z0)

        Fs0 = self._ideal_bolt_force_at_tensile_ULS

        # Evaluate the displacement u in the ultimate prying state.
        Cs=self._bolt_axial_stiffness

        u = (Fs0-self.Fv)/(2*Cs)   # (40)

        # Evaluate the segment stiffness
        k_seg = Z0 / (u * cm)
        
        log_data(self, u=u, k_seg=k_seg)
        
        # Return the stiffness correction factor, acc. [1], eq.75
        return min(1 + self._gap_stiffness / k_seg,
                   4 * pi/3 / self.gap_angle)

    @cached_property
    def _polynomial_initial_slope (self):
        ''' Initial slope of the polynomial Fs(Z).

        This slope is calculated according to ref. [1], eq.80.
        '''

        # Load factor of the tension spring
        p = self._bolt_axial_stiffness / (self._bolt_axial_stiffness + self._flange_axial_stiffness)
        p_max=(self.bolt_force_at_tensile_ULS - self.bolt_force_at_rest) / (self.shell_force_at_tensile_ULS - self.shell_force_at_rest)
        
        # Initial slope correction factor
        #scf = min(0.5 , 0.5*(-self._total_gap_neutralization_shell_force / (0.2 * self.Fv))**2)
        
        #gap closing ratio
        gap_closing_ratio=self._total_gap_neutralization_shell_force/(self.Fv)
        
        # Initial slope
        xi_ini=min(gap_closing_ratio*p*0.5,p_max)*self.gap_shape_factor
        
        return -xi_ini




def bolt_markov_matrix (fseg, flange_markov_matrix, bending_factor=0.0, macro_geometric_factor=1.0, mean_factor=1.0, range_factor=1.0):
    ''' **Evaluates the bolt Markov matrix, given the shell Markov matix.**

    **Args:**

    - `fseg : pyflange.flangesegments.PolynomialFlangeSegment` 
      The flange segment object that contains the force and moment transfer 
      function that convert shell forces to bolt forces.

      **WARNING:** Notice that currently this function works only with
      PolynomialFlangeSegments, while it should be extended to work with any
      FlangeSegment object.

    - `flange_markov_matrix : pyflange.fatigue.MarkovMatrix`
      The Markov matrix of the bending moments transferred to the flange.

    - `bending_factor : float` 
      The factor that considers the bending portion of the total stress range.

    - `macro_geometric_factor : float`
      The factor that considers macro geometric influences. The factor affects 
      the dead-weigt of the tower, the mean values of the markov matrix and the 
      range values of the markov matrix.

    - `mean_factor : float` 
      The factor that multiplies the mean values of the bending moments of the tower.

    - `range_factor : float` 
      The factor that multiplies the range of the bending moments of the tower.

    **Returns:**

    - `bolt_markov_matrix : pythagoras.fatigue.MarkovMatrix`
      The bolt markov matrix representing the stress history in the bolt due to 
      the applied flange markov matrix.
    '''
    from .fatigue import MarkovMatrix

    #Flange Geometry
    Rm = fseg.R - fseg.s/2
    flange_W = pi/4 * (fseg.R**4 - (fseg.R-fseg.s)**4) / Rm
    shell_A = fseg.s * fseg.central_angle * Rm

    # Bolt Geometry
    bolt_A = fseg.bolt.thread_cross_section.area
    bolt_W = fseg.bolt.thread_cross_section.elastic_section_modulus

    # Shell Markov Matrix
    Z_cycles = flange_markov_matrix.cycles
    Z_mean   = flange_markov_matrix.mean / flange_W * shell_A * mean_factor * macro_geometric_factor
    Z_ranges = flange_markov_matrix.range / flange_W * shell_A * range_factor * macro_geometric_factor
    Z_min = Z_mean - Z_ranges/2 + fseg.Zg * macro_geometric_factor
    Z_max = Z_mean + Z_ranges/2 + fseg.Zg * macro_geometric_factor

    # Bolt ess Markov Matrix
    S_min = fseg.bolt_axial_force(Z_min)/bolt_A + bending_factor * fseg.bolt_bending_moment(Z_min)/bolt_W
    S_max = fseg.bolt_axial_force(Z_max)/bolt_A + bending_factor * fseg.bolt_bending_moment(Z_max)/bolt_W
    return MarkovMatrix(range = np.abs(S_max - S_min),
                        mean = (S_min + S_max) / 2,
                        cycles = Z_cycles,
                        duration = flange_markov_matrix.duration)



def shell_stiffness (shell_radius, shell_thickness, gap_angle):
    ''' Axial stiffness of a flange-segment shell.

    This function will return the linear interpolation of the flange stiffnesses
    measured in 2160 different FEA analyses with several values of shell radius,
    shell thickness and gap angle.

    Args:
        shell_radius (float): outer radius of the shell.

        shell_thickness (float): thickness of the shell.

        gap_angle (float): angular length of the flange gap.

    Returns:
        K_sh (float): shell stiffness.
    '''
    interpolate_shell_stiffness = _load_shell_stiffness_interpolator()
    return interpolate_shell_stiffness(shell_radius, shell_thickness, gap_angle)


@cache
def _load_shell_stiffness_interpolator ():
    from math import pi
    from .utils import load_csv_database
    from scipy.interpolate import LinearNDInterpolator
    ssdf = load_csv_database("flangesegments.shell_stiffness", index_col=None)
    return LinearNDInterpolator(list(zip(ssdf['shell_radius'], ssdf['shell_thickness'], ssdf['gap_angle']/180*pi)), ssdf['shell_stiffness'])


