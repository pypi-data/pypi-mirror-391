"use strict";(self.webpackChunk_datalayer_ui=self.webpackChunk_datalayer_ui||[]).push([[5850],{65850:(e,t,r)=>{r.r(t),r.d(t,{UnauthorizedError:()=>fe,auth:()=>Ye,experimental_createMCPClient:()=>Ie});var o=r(82134),n=r(82100),s=r(11408),a=r(66097);let i;async function c(e){const t=await(await i).subtle.digest("SHA-256",(new TextEncoder).encode(e));return btoa(String.fromCharCode(...new Uint8Array(t))).replace(/\//g,"_").replace(/\+/g,"-").replace(/=/g,"")}async function l(e){if(e||(e=43),e<43||e>128)throw`Expected a length between 43 and 128. Received ${e}.`;const t=await async function(e){return await async function(e){let t="";const r=await async function(e){return(await i).getRandomValues(new Uint8Array(e))}(e);for(let o=0;o<e;o++)t+="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~"[r[o]%66];return t}(e)}(e);return{code_verifier:t,code_challenge:await c(t)}}i=globalThis.crypto;var u,h,d,p,m=r(99802),w="vercel.ai.error.AI_MCPClientError",f=Symbol.for(w),_=class extends(h=n.bD,u=f,h){constructor({name:e="MCPClientError",message:t,cause:r,data:o,code:n}){super({name:e,message:t,cause:r}),this[u]=!0,this.data=o,this.code=n}static isInstance(e){return n.bD.hasMarker(e,w)}},g="2025-06-18",v=[g,"2025-03-26","2024-11-05"],y=a._H({name:a.Yj(),version:a.Yj()}),b=a._H({_meta:a.lq(a.Ik({}).loose())}),C=b,Y=a.Ik({method:a.Yj(),params:a.lq(b)}),j=a._H({experimental:a.lq(a.Ik({}).loose()),logging:a.lq(a.Ik({}).loose()),prompts:a.lq(a._H({listChanged:a.lq(a.zM())})),resources:a.lq(a._H({subscribe:a.lq(a.zM()),listChanged:a.lq(a.zM())})),tools:a.lq(a._H({listChanged:a.lq(a.zM())}))}),k=C.extend({protocolVersion:a.Yj(),capabilities:j,serverInfo:y,instructions:a.lq(a.Yj())}),T=C.extend({nextCursor:a.lq(a.Yj())}),I=a.Ik({name:a.Yj(),description:a.lq(a.Yj()),inputSchema:a.Ik({type:a.eu("object"),properties:a.lq(a.Ik({}).loose())}).loose(),annotations:a.lq(a.Ik({title:a.lq(a.Yj())}).loose())}).loose(),R=T.extend({tools:a.YO(I)}),U=a.Ik({type:a.eu("text"),text:a.Yj()}).loose(),P=a.Ik({type:a.eu("image"),data:a.K3(),mimeType:a.Yj()}).loose(),E=a.Ik({uri:a.Yj(),name:a.Yj(),title:a.lq(a.Yj()),description:a.lq(a.Yj()),mimeType:a.lq(a.Yj()),size:a.lq(a.ai())}).loose(),S=T.extend({resources:a.YO(E)}),O=a.Ik({uri:a.Yj(),name:a.lq(a.Yj()),title:a.lq(a.Yj()),mimeType:a.lq(a.Yj())}).loose(),q=O.extend({text:a.Yj()}),x=O.extend({blob:a.K3()}),A=a.Ik({type:a.eu("resource"),resource:a.KC([q,x])}).loose(),M=C.extend({content:a.YO(a.KC([U,P,A])),isError:a.zM().default(!1).optional()}).or(C.extend({toolResult:a.L5()})),$=a.Ik({uriTemplate:a.Yj(),name:a.Yj(),title:a.lq(a.Yj()),description:a.lq(a.Yj()),mimeType:a.lq(a.Yj())}).loose(),H=C.extend({resourceTemplates:a.YO($)}),L=C.extend({contents:a.YO(a.KC([q,x]))}),z=a.Ik({name:a.Yj(),description:a.lq(a.Yj()),required:a.lq(a.zM())}).loose(),D=a.Ik({name:a.Yj(),title:a.lq(a.Yj()),description:a.lq(a.Yj()),arguments:a.lq(a.YO(z))}).loose(),V=T.extend({prompts:a.YO(D)}),F=a.Ik({role:a.KC([a.eu("user"),a.eu("assistant")]),content:a.KC([U,P,A])}).loose(),N=C.extend({description:a.lq(a.Yj()),messages:a.YO(F)}),K="2.0",Z=a.Ik({jsonrpc:a.eu(K),id:a.KC([a.Yj(),a.ai().int()])}).merge(Y).strict(),J=a.Ik({jsonrpc:a.eu(K),id:a.KC([a.Yj(),a.ai().int()]),result:C}).strict(),W=a.Ik({jsonrpc:a.eu(K),id:a.KC([a.Yj(),a.ai().int()]),error:a.Ik({code:a.ai().int(),message:a.Yj(),data:a.lq(a.L5())})}).strict(),G=a.Ik({jsonrpc:a.eu(K)}).merge(a.Ik({method:a.Yj(),params:a.lq(b)})).strict(),B=a.KC([Z,G,J,W]),Q="undefined"!=typeof __PACKAGE_VERSION__?__PACKAGE_VERSION__:"0.0.0-test",X=a.Ik({access_token:a.Yj(),id_token:a.Yj().optional(),token_type:a.Yj(),expires_in:a.ai().optional(),scope:a.Yj().optional(),refresh_token:a.Yj().optional()}).strip(),ee=a.Yj().url().superRefine((e,t)=>{if(!URL.canParse(e))return t.addIssue({code:"custom",message:"URL must be parseable",fatal:!0}),m.tm}).refine(e=>{const t=new URL(e);return"javascript:"!==t.protocol&&"data:"!==t.protocol&&"vbscript:"!==t.protocol},{message:"URL cannot use javascript:, data:, or vbscript: scheme"}),te=a.Ik({resource:a.Yj().url(),authorization_servers:a.YO(ee).optional(),jwks_uri:a.Yj().url().optional(),scopes_supported:a.YO(a.Yj()).optional(),bearer_methods_supported:a.YO(a.Yj()).optional(),resource_signing_alg_values_supported:a.YO(a.Yj()).optional(),resource_name:a.Yj().optional(),resource_documentation:a.Yj().optional(),resource_policy_uri:a.Yj().url().optional(),resource_tos_uri:a.Yj().url().optional(),tls_client_certificate_bound_access_tokens:a.zM().optional(),authorization_details_types_supported:a.YO(a.Yj()).optional(),dpop_signing_alg_values_supported:a.YO(a.Yj()).optional(),dpop_bound_access_tokens_required:a.zM().optional()}).passthrough(),re=a.Ik({issuer:a.Yj(),authorization_endpoint:ee,token_endpoint:ee,registration_endpoint:ee.optional(),scopes_supported:a.YO(a.Yj()).optional(),response_types_supported:a.YO(a.Yj()),grant_types_supported:a.YO(a.Yj()).optional(),code_challenge_methods_supported:a.YO(a.Yj()),token_endpoint_auth_methods_supported:a.YO(a.Yj()).optional(),token_endpoint_auth_signing_alg_values_supported:a.YO(a.Yj()).optional()}).passthrough(),oe=a.Ik({issuer:a.Yj(),authorization_endpoint:ee,token_endpoint:ee,userinfo_endpoint:ee.optional(),jwks_uri:ee,registration_endpoint:ee.optional(),scopes_supported:a.YO(a.Yj()).optional(),response_types_supported:a.YO(a.Yj()),grant_types_supported:a.YO(a.Yj()).optional(),subject_types_supported:a.YO(a.Yj()),id_token_signing_alg_values_supported:a.YO(a.Yj()),claims_supported:a.YO(a.Yj()).optional(),token_endpoint_auth_methods_supported:a.YO(a.Yj()).optional()}).passthrough().merge(re.pick({code_challenge_methods_supported:!0})),ne=a.Ik({client_id:a.Yj(),client_secret:a.Yj().optional(),client_id_issued_at:a.ai().optional(),client_secret_expires_at:a.ai().optional()}).strip(),se=a.Ik({redirect_uris:a.YO(ee),token_endpoint_auth_method:a.Yj().optional(),grant_types:a.YO(a.Yj()).optional(),response_types:a.YO(a.Yj()).optional(),client_name:a.Yj().optional(),client_uri:ee.optional(),logo_uri:ee.optional(),scope:a.Yj().optional(),contacts:a.YO(a.Yj()).optional(),tos_uri:ee.optional(),policy_uri:a.Yj().optional(),jwks_uri:ee.optional(),jwks:a.bz().optional(),software_id:a.Yj().optional(),software_version:a.Yj().optional(),software_statement:a.Yj().optional()}).strip(),ae=a.Ik({error:a.Yj(),error_description:a.Yj().optional(),error_uri:a.Yj().optional()}),ie=se.merge(ne),ce="vercel.ai.error.AI_MCPClientOAuthError",le=Symbol.for(ce),ue=class extends(p=n.bD,d=le,p){constructor({name:e="MCPClientOAuthError",message:t,cause:r}){super({name:e,message:t,cause:r}),this[d]=!0}static isInstance(e){return n.bD.hasMarker(e,ce)}},he=class extends ue{};he.errorCode="server_error";var de=class extends ue{};de.errorCode="invalid_client";var pe=class extends ue{};pe.errorCode="invalid_grant";var me=class extends ue{};me.errorCode="unauthorized_client";var we={[he.errorCode]:he,[de.errorCode]:de,[pe.errorCode]:pe,[me.errorCode]:me},fe=class extends Error{constructor(e="Unauthorized"){super(e),this.name="UnauthorizedError"}};function _e(e){var t;const r=null!=(t=e.headers.get("www-authenticate"))?t:e.headers.get("WWW-Authenticate");if(!r)return;const[o,n]=r.split(" ");if("bearer"!==o.toLowerCase()||!n)return;const s=r.match(/resource_metadata="([^"]*)"/);if(s)try{return new URL(s[1])}catch(e){return}}async function ge(e,t,r=fetch){try{return await r(e,{headers:t})}catch(o){if(o instanceof TypeError)return t?ge(e,void 0,r):void 0;throw o}}async function ve(e,t,r=fetch){const o={"MCP-Protocol-Version":t};return await ge(e,o,r)}function ye(e,t){const r=void 0!==e.client_secret;return 0===t.length?r?"client_secret_post":"none":r&&t.includes("client_secret_basic")?"client_secret_basic":r&&t.includes("client_secret_post")?"client_secret_post":t.includes("none")?"none":r?"client_secret_post":"none"}function be(e,t,r,o){const{client_id:n,client_secret:s}=t;switch(e){case"client_secret_basic":return void function(e,t,r){if(!t)throw new Error("client_secret_basic authentication requires a client_secret");const o=btoa(`${e}:${t}`);r.set("Authorization",`Basic ${o}`)}(n,s,r);case"client_secret_post":return void function(e,t,r){r.set("client_id",e),t&&r.set("client_secret",t)}(n,s,o);case"none":return void function(e,t){t.set("client_id",e)}(n,o);default:throw new Error(`Unsupported client authentication method: ${e}`)}}async function Ce(e){const t=e instanceof Response?e.status:void 0,r=e instanceof Response?await e.text():e;try{const e=ae.parse(JSON.parse(r)),{error:t,error_description:o,error_uri:n}=e;return new(we[t]||he)({message:o||"",cause:n})}catch(e){return new he({message:`${t?`HTTP ${t}: `:""}Invalid OAuth error response: ${e}. Raw body: ${r}`})}}async function Ye(e,t){var r,o;try{return await je(e,t)}catch(n){if(n instanceof de||n instanceof me)return await(null==(r=e.invalidateCredentials)?void 0:r.call(e,"all")),await je(e,t);if(n instanceof pe)return await(null==(o=e.invalidateCredentials)?void 0:o.call(e,"tokens")),await je(e,t);throw n}}async function je(e,{serverUrl:t,authorizationCode:r,scope:o,resourceMetadataUrl:n,fetchFn:s}){let a,i;try{a=await async function(e,t,r=fetch){const o=await async function(e,t,r,o){var n,s;const a=new URL(e),i=null!=(n=null==o?void 0:o.protocolVersion)?n:g;let c;if(null==o?void 0:o.metadataUrl)c=new URL(o.metadataUrl);else{const e=function(e,t="",r={}){return t.endsWith("/")&&(t=t.slice(0,-1)),r.prependPathname?`${t}/.well-known/${e}`:`/.well-known/${e}${t}`}(t,a.pathname);c=new URL(e,null!=(s=null==o?void 0:o.metadataServerUrl)?s:a),c.search=a.search}let l=await ve(c,i,r);if(!(null==o?void 0:o.metadataUrl)&&function(e,t){return!e||e.status>=400&&e.status<500&&"/"!==t}(l,a.pathname)){const e=new URL(`/.well-known/${t}`,a);l=await ve(e,i,r)}return l}(e,"oauth-protected-resource",r,{protocolVersion:null==t?void 0:t.protocolVersion,metadataUrl:null==t?void 0:t.resourceMetadataUrl});if(!o||404===o.status)throw new Error("Resource server does not implement OAuth 2.0 Protected Resource Metadata.");if(!o.ok)throw new Error(`HTTP ${o.status} trying to load well-known OAuth protected resource metadata.`);return te.parse(await o.json())}(t,{resourceMetadataUrl:n},s),a.authorization_servers&&a.authorization_servers.length>0&&(i=a.authorization_servers[0])}catch(e){}i||(i=t);const c=await async function(e,t,r){const o=function(e){const t="string"==typeof e?new URL(e):new URL(e.href);return t.hash="",t}(e);if(t.validateResourceURL)return await t.validateResourceURL(o,null==r?void 0:r.resource);if(r){if(!function({requestedResource:e,configuredResource:t}){const r="string"==typeof e?new URL(e):new URL(e.href),o="string"==typeof t?new URL(t):new URL(t.href);if(r.origin!==o.origin)return!1;if(r.pathname.length<o.pathname.length)return!1;const n=r.pathname.endsWith("/")?r.pathname:r.pathname+"/",s=o.pathname.endsWith("/")?o.pathname:o.pathname+"/";return n.startsWith(s)}({requestedResource:o,configuredResource:r.resource}))throw new Error(`Protected resource ${r.resource} does not match expected ${o} (or origin)`);return new URL(r.resource)}}(t,e,a),u=await async function(e,{fetchFn:t=fetch,protocolVersion:r=g}={}){var o;const n={"MCP-Protocol-Version":r},s=function(e){const t="string"==typeof e?new URL(e):e,r=[];if("/"===t.pathname)return r.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),r.push({url:new URL("/.well-known/openid-configuration",t.origin),type:"oidc"}),r;let o=t.pathname;return o.endsWith("/")&&(o=o.slice(0,-1)),r.push({url:new URL(`/.well-known/oauth-authorization-server${o}`,t.origin),type:"oauth"}),r.push({url:new URL("/.well-known/oauth-authorization-server",t.origin),type:"oauth"}),r.push({url:new URL(`/.well-known/openid-configuration${o}`,t.origin),type:"oidc"}),r.push({url:new URL(`${o}/.well-known/openid-configuration`,t.origin),type:"oidc"}),r}(e);for(const{url:e,type:r}of s){const s=await ge(e,n,t);if(s){if(!s.ok){if(s.status>=400&&s.status<500)continue;throw new Error(`HTTP ${s.status} trying to load ${"oauth"===r?"OAuth":"OpenID provider"} metadata from ${e}`)}if("oauth"===r)return re.parse(await s.json());{const t=oe.parse(await s.json());if(!(null==(o=t.code_challenge_methods_supported)?void 0:o.includes("S256")))throw new Error(`Incompatible OIDC provider at ${e}: does not support S256 code challenge method required by MCP specification`);return t}}}}(i,{fetchFn:s});let h=await Promise.resolve(e.clientInformation());if(!h){if(void 0!==r)throw new Error("Existing OAuth client information is required when exchanging an authorization code");if(!e.saveClientInformation)throw new Error("OAuth client information must be saveable for dynamic registration");const t=await async function(e,{metadata:t,clientMetadata:r,fetchFn:o}){let n;if(t){if(!t.registration_endpoint)throw new Error("Incompatible auth server: does not support dynamic client registration");n=new URL(t.registration_endpoint)}else n=new URL("/register",e);const s=await(null!=o?o:fetch)(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(r)});if(!s.ok)throw await Ce(s);return ie.parse(await s.json())}(i,{metadata:u,clientMetadata:e.clientMetadata,fetchFn:s});await e.saveClientInformation(t),h=t}if(void 0!==r){const t=await e.codeVerifier(),o=await async function(e,{metadata:t,clientInformation:r,authorizationCode:o,codeVerifier:n,redirectUri:s,resource:a,addClientAuthentication:i,fetchFn:c}){var l;const u="authorization_code",h=(null==t?void 0:t.token_endpoint)?new URL(t.token_endpoint):new URL("/token",e);if((null==t?void 0:t.grant_types_supported)&&!t.grant_types_supported.includes(u))throw new Error(`Incompatible auth server: does not support grant type ${u}`);const d=new Headers({"Content-Type":"application/x-www-form-urlencoded",Accept:"application/json"}),p=new URLSearchParams({grant_type:u,code:o,code_verifier:n,redirect_uri:String(s)});i?i(d,p,e,t):be(ye(r,null!=(l=null==t?void 0:t.token_endpoint_auth_methods_supported)?l:[]),r,d,p),a&&p.set("resource",a.href);const m=await(null!=c?c:fetch)(h,{method:"POST",headers:d,body:p});if(!m.ok)throw await Ce(m);return X.parse(await m.json())}(i,{metadata:u,clientInformation:h,authorizationCode:r,codeVerifier:t,redirectUri:e.redirectUrl,resource:c,addClientAuthentication:e.addClientAuthentication,fetchFn:s});return await e.saveTokens(o),"AUTHORIZED"}const d=await e.tokens();if(null==d?void 0:d.refresh_token)try{const t=await async function(e,{metadata:t,clientInformation:r,refreshToken:o,resource:n,addClientAuthentication:s,fetchFn:a}){var i;const c="refresh_token";let l;if(t){if(l=new URL(t.token_endpoint),t.grant_types_supported&&!t.grant_types_supported.includes(c))throw new Error(`Incompatible auth server: does not support grant type ${c}`)}else l=new URL("/token",e);const u=new Headers({"Content-Type":"application/x-www-form-urlencoded"}),h=new URLSearchParams({grant_type:c,refresh_token:o});s?s(u,h,e,t):be(ye(r,null!=(i=null==t?void 0:t.token_endpoint_auth_methods_supported)?i:[]),r,u,h),n&&h.set("resource",n.href);const d=await(null!=a?a:fetch)(l,{method:"POST",headers:u,body:h});if(!d.ok)throw await Ce(d);return X.parse({refresh_token:o,...await d.json()})}(i,{metadata:u,clientInformation:h,refreshToken:d.refresh_token,resource:c,addClientAuthentication:e.addClientAuthentication,fetchFn:s});return await e.saveTokens(t),"AUTHORIZED"}catch(e){if(e instanceof ue&&!(e instanceof he))throw e}const p=e.state?await e.state():void 0,{authorizationUrl:m,codeVerifier:w}=await async function(e,{metadata:t,clientInformation:r,redirectUrl:o,scope:n,state:s,resource:a}){const i="code",c="S256";let u;if(t){if(u=new URL(t.authorization_endpoint),!t.response_types_supported.includes(i))throw new Error(`Incompatible auth server: does not support response type ${i}`);if(!t.code_challenge_methods_supported||!t.code_challenge_methods_supported.includes(c))throw new Error(`Incompatible auth server: does not support code challenge method ${c}`)}else u=new URL("/authorize",e);const h=await l(),d=h.code_verifier,p=h.code_challenge;return u.searchParams.set("response_type",i),u.searchParams.set("client_id",r.client_id),u.searchParams.set("code_challenge",p),u.searchParams.set("code_challenge_method",c),u.searchParams.set("redirect_uri",String(o)),s&&u.searchParams.set("state",s),n&&u.searchParams.set("scope",n),(null==n?void 0:n.includes("offline_access"))&&u.searchParams.append("prompt","consent"),a&&u.searchParams.set("resource",a.href),{authorizationUrl:u,codeVerifier:d}}(i,{metadata:u,clientInformation:h,state:p,redirectUrl:e.redirectUrl,scope:o||e.clientMetadata.scope,resource:c});return await e.saveCodeVerifier(w),await e.redirectToAuthorization(m),"REDIRECT"}var ke=class{constructor({url:e,headers:t,authProvider:r}){this.connected=!1,this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":g};if(this.authProvider){const e=await this.authProvider.tokens();(null==e?void 0:e.access_token)&&(t.Authorization=`Bearer ${e.access_token}`)}return(0,o.withUserAgentSuffix)(t,`ai-sdk/${Q}`,(0,o.getRuntimeEnvironmentUserAgent)())}async start(){return new Promise((e,t)=>{if(this.connected)return e();this.abortController=new AbortController;const r=async(o=!1)=>{var n,a,i,c,l;try{const l=await this.commonHeaders({Accept:"text/event-stream"}),u=await fetch(this.url.href,{headers:l,signal:null==(n=this.abortController)?void 0:n.signal});if(401===u.status&&this.authProvider&&!o){this.resourceMetadataUrl=_e(u);try{if("AUTHORIZED"!==await Ye(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const e=new fe;return null==(a=this.onerror)||a.call(this,e),t(e)}}catch(e){return null==(i=this.onerror)||i.call(this,e),t(e)}return r(!0)}if(!u.ok||!u.body){let e=`MCP SSE Transport Error: ${u.status} ${u.statusText}`;405===u.status&&(e+=". This server does not support SSE transport. Try using `http` transport instead");const r=new _({message:e});return null==(c=this.onerror)||c.call(this,r),t(r)}const h=u.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader(),d=async()=>{var r,o,n;try{for(;;){const{done:t,value:n}=await h.read();if(t){if(this.connected)throw this.connected=!1,new _({message:"MCP SSE Transport Error: Connection closed unexpectedly"});return}const{event:s,data:a}=n;if("endpoint"===s){if(this.endpoint=new URL(a,this.url),this.endpoint.origin!==this.url.origin)throw new _({message:`MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`});this.connected=!0,e()}else if("message"===s)try{const e=B.parse(JSON.parse(a));null==(r=this.onmessage)||r.call(this,e)}catch(e){const t=new _({message:"MCP SSE Transport Error: Failed to parse message",cause:e});null==(o=this.onerror)||o.call(this,t)}}}catch(e){if(e instanceof Error&&"AbortError"===e.name)return;null==(n=this.onerror)||n.call(this,e),t(e)}};this.sseConnection={close:()=>h.cancel()},d()}catch(e){if(e instanceof Error&&"AbortError"===e.name)return;null==(l=this.onerror)||l.call(this,e),t(e)}};r()})}async close(){var e,t,r;this.connected=!1,null==(e=this.sseConnection)||e.close(),null==(t=this.abortController)||t.abort(),null==(r=this.onclose)||r.call(this)}async send(e){if(!this.endpoint||!this.connected)throw new _({message:"MCP SSE Transport Error: Not connected"});const t=this.endpoint,r=async(o=!1)=>{var n,s,a,i,c;try{const c={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json"}),body:JSON.stringify(e),signal:null==(n=this.abortController)?void 0:n.signal},l=await fetch(t,c);if(401===l.status&&this.authProvider&&!o){this.resourceMetadataUrl=_e(l);try{if("AUTHORIZED"!==await Ye(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const e=new fe;return void(null==(s=this.onerror)||s.call(this,e))}}catch(e){return void(null==(a=this.onerror)||a.call(this,e))}return r(!0)}if(!l.ok){const e=await l.text().catch(()=>null),t=new _({message:`MCP SSE Transport Error: POSTing to endpoint (HTTP ${l.status}): ${e}`});return void(null==(i=this.onerror)||i.call(this,t))}}catch(e){return void(null==(c=this.onerror)||c.call(this,e))}};await r()}},Te=class{constructor({url:e,headers:t,authProvider:r}){this.inboundReconnectAttempts=0,this.reconnectionOptions={initialReconnectionDelay:1e3,maxReconnectionDelay:3e4,reconnectionDelayGrowFactor:1.5,maxRetries:2},this.url=new URL(e),this.headers=t,this.authProvider=r}async commonHeaders(e){const t={...this.headers,...e,"mcp-protocol-version":g};if(this.sessionId&&(t["mcp-session-id"]=this.sessionId),this.authProvider){const e=await this.authProvider.tokens();(null==e?void 0:e.access_token)&&(t.Authorization=`Bearer ${e.access_token}`)}return(0,o.withUserAgentSuffix)(t,`ai-sdk/${Q}`,(0,o.getRuntimeEnvironmentUserAgent)())}async start(){if(this.abortController)throw new _({message:"MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically."});this.abortController=new AbortController,this.openInboundSse()}async close(){var e,t,r;null==(e=this.inboundSseConnection)||e.close();try{if(this.sessionId&&this.abortController&&!this.abortController.signal.aborted){const e=await this.commonHeaders({});await fetch(this.url,{method:"DELETE",headers:e,signal:this.abortController.signal}).catch(()=>{})}}catch(e){}null==(t=this.abortController)||t.abort(),null==(r=this.onclose)||r.call(this)}async send(e){const t=async(r=!1)=>{var o,n,a,i,c,l,u;try{const u={method:"POST",headers:await this.commonHeaders({"Content-Type":"application/json",Accept:"application/json, text/event-stream"}),body:JSON.stringify(e),signal:null==(o=this.abortController)?void 0:o.signal},h=await fetch(this.url,u),d=h.headers.get("mcp-session-id");if(d&&(this.sessionId=d),401===h.status&&this.authProvider&&!r){this.resourceMetadataUrl=_e(h);try{if("AUTHORIZED"!==await Ye(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl}))throw new fe}catch(e){throw null==(n=this.onerror)||n.call(this,e),e}return t(!0)}if(202===h.status)return void(this.inboundSseConnection||this.openInboundSse());if(!h.ok){const e=await h.text().catch(()=>null);let t=`MCP HTTP Transport Error: POSTing to endpoint (HTTP ${h.status}): ${e}`;404===h.status&&(t+=". This server does not support HTTP transport. Try using `sse` transport instead");const r=new _({message:t});throw null==(a=this.onerror)||a.call(this,r),r}const p=h.headers.get("content-type")||"";if(p.includes("application/json")){const e=await h.json(),t=Array.isArray(e)?e.map(e=>B.parse(e)):[B.parse(e)];for(const e of t)null==(i=this.onmessage)||i.call(this,e);return}if(p.includes("text/event-stream")){if(!h.body){const e=new _({message:"MCP HTTP Transport Error: text/event-stream response without body"});throw null==(c=this.onerror)||c.call(this,e),e}const e=h.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader();return void(async()=>{var t,r,o;try{for(;;){const{done:o,value:n}=await e.read();if(o)return;const{event:s,data:a}=n;if("message"===s)try{const e=B.parse(JSON.parse(a));null==(t=this.onmessage)||t.call(this,e)}catch(e){const t=new _({message:"MCP HTTP Transport Error: Failed to parse message",cause:e});null==(r=this.onerror)||r.call(this,t)}}}catch(e){if(e instanceof Error&&"AbortError"===e.name)return;null==(o=this.onerror)||o.call(this,e)}})()}const m=new _({message:`MCP HTTP Transport Error: Unexpected content type: ${p}`});throw null==(l=this.onerror)||l.call(this,m),m}catch(e){throw null==(u=this.onerror)||u.call(this,e),e}};await t()}getNextReconnectionDelay(e){const{initialReconnectionDelay:t,reconnectionDelayGrowFactor:r,maxReconnectionDelay:o}=this.reconnectionOptions;return Math.min(t*Math.pow(r,e),o)}scheduleInboundSseReconnection(){var e;const{maxRetries:t}=this.reconnectionOptions;if(t>0&&this.inboundReconnectAttempts>=t)return void(null==(e=this.onerror)||e.call(this,new _({message:`MCP HTTP Transport Error: Maximum reconnection attempts (${t}) exceeded.`})));const r=this.getNextReconnectionDelay(this.inboundReconnectAttempts);this.inboundReconnectAttempts+=1,setTimeout(async()=>{var e;(null==(e=this.abortController)?void 0:e.signal.aborted)||await this.openInboundSse(!1,this.lastInboundEventId)},r)}async openInboundSse(e=!1,t){var r,o,n,a,i,c;try{const i=await this.commonHeaders({Accept:"text/event-stream"});t&&(i["last-event-id"]=t);const c=await fetch(this.url.href,{method:"GET",headers:i,signal:null==(r=this.abortController)?void 0:r.signal}),l=c.headers.get("mcp-session-id");if(l&&(this.sessionId=l),401===c.status&&this.authProvider&&!e){this.resourceMetadataUrl=_e(c);try{if("AUTHORIZED"!==await Ye(this.authProvider,{serverUrl:this.url,resourceMetadataUrl:this.resourceMetadataUrl})){const e=new fe;return void(null==(o=this.onerror)||o.call(this,e))}}catch(e){return void(null==(n=this.onerror)||n.call(this,e))}return this.openInboundSse(!0,t)}if(405===c.status)return;if(!c.ok||!c.body){const e=new _({message:`MCP HTTP Transport Error: GET SSE failed: ${c.status} ${c.statusText}`});return void(null==(a=this.onerror)||a.call(this,e))}const u=c.body.pipeThrough(new TextDecoderStream).pipeThrough(new s.Z).getReader(),h=async()=>{var e,t,r,o;try{for(;;){const{done:r,value:o}=await u.read();if(r)return;const{event:n,data:s,id:a}=o;if(a&&(this.lastInboundEventId=a),"message"===n)try{const t=B.parse(JSON.parse(s));null==(e=this.onmessage)||e.call(this,t)}catch(e){const r=new _({message:"MCP HTTP Transport Error: Failed to parse message",cause:e});null==(t=this.onerror)||t.call(this,r)}}}catch(e){if(e instanceof Error&&"AbortError"===e.name)return;null==(r=this.onerror)||r.call(this,e),(null==(o=this.abortController)?void 0:o.signal.aborted)||this.scheduleInboundSseReconnection()}};this.inboundSseConnection={close:()=>u.cancel()},this.inboundReconnectAttempts=0,h()}catch(e){if(e instanceof Error&&"AbortError"===e.name)return;null==(i=this.onerror)||i.call(this,e),(null==(c=this.abortController)?void 0:c.signal.aborted)||this.scheduleInboundSseReconnection()}}};async function Ie(e){const t=new Re(e);return await t.init(),t}var Re=class{constructor({transport:e,name:t="ai-sdk-mcp-client",onUncaughtError:r}){var o;this.requestMessageId=0,this.responseHandlers=new Map,this.serverCapabilities={},this.isClosed=!0,this.onUncaughtError=r,"start"in(o=e)&&"function"==typeof o.start&&"send"in o&&"function"==typeof o.send&&"close"in o&&"function"==typeof o.close?this.transport=e:this.transport=function(e){switch(e.type){case"sse":return new ke(e);case"http":return new Te(e);default:throw new _({message:"Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface."})}}(e),this.transport.onclose=()=>this.onClose(),this.transport.onerror=e=>this.onError(e),this.transport.onmessage=e=>{"method"in e?this.onError(new _({message:"Unsupported message type"})):this.onResponse(e)},this.clientInfo={name:t,version:"1.0.0"}}async init(){try{await this.transport.start(),this.isClosed=!1;const e=await this.request({request:{method:"initialize",params:{protocolVersion:g,capabilities:{},clientInfo:this.clientInfo}},resultSchema:k});if(void 0===e)throw new _({message:"Server sent invalid initialize result"});if(!v.includes(e.protocolVersion))throw new _({message:`Server's protocol version is not supported: ${e.protocolVersion}`});return this.serverCapabilities=e.capabilities,await this.notification({method:"notifications/initialized"}),this}catch(e){throw await this.close(),e}}async close(){var e;this.isClosed||(await(null==(e=this.transport)?void 0:e.close()),this.onClose())}assertCapability(e){switch(e){case"initialize":break;case"tools/list":case"tools/call":if(!this.serverCapabilities.tools)throw new _({message:"Server does not support tools"});break;case"resources/list":case"resources/read":case"resources/templates/list":if(!this.serverCapabilities.resources)throw new _({message:"Server does not support resources"});break;case"prompts/list":case"prompts/get":if(!this.serverCapabilities.prompts)throw new _({message:"Server does not support prompts"});break;default:throw new _({message:`Unsupported method: ${e}`})}}async request({request:e,resultSchema:t,options:r}){return new Promise((o,n)=>{if(this.isClosed)return n(new _({message:"Attempted to send a request from a closed client"}));this.assertCapability(e.method);const s=null==r?void 0:r.signal;null==s||s.throwIfAborted();const a=this.requestMessageId++,i={...e,jsonrpc:"2.0",id:a},c=()=>{this.responseHandlers.delete(a)};this.responseHandlers.set(a,e=>{if(null==s?void 0:s.aborted)return n(new _({message:"Request was aborted",cause:s.reason}));if(e instanceof Error)return n(e);try{const r=t.parse(e.result);o(r)}catch(e){const t=new _({message:"Failed to parse server response",cause:e});n(t)}}),this.transport.send(i).catch(e=>{c(),n(e)})})}async listTools({params:e,options:t}={}){try{return this.request({request:{method:"tools/list",params:e},resultSchema:R,options:t})}catch(e){throw e}}async callTool({name:e,args:t,options:r}){try{return this.request({request:{method:"tools/call",params:{name:e,arguments:t}},resultSchema:M,options:{signal:null==r?void 0:r.abortSignal}})}catch(e){throw e}}async listResourcesInternal({params:e,options:t}={}){try{return this.request({request:{method:"resources/list",params:e},resultSchema:S,options:t})}catch(e){throw e}}async readResourceInternal({uri:e,options:t}){try{return this.request({request:{method:"resources/read",params:{uri:e}},resultSchema:L,options:t})}catch(e){throw e}}async listResourceTemplatesInternal({options:e}={}){try{return this.request({request:{method:"resources/templates/list"},resultSchema:H,options:e})}catch(e){throw e}}async listPromptsInternal({params:e,options:t}={}){try{return this.request({request:{method:"prompts/list",params:e},resultSchema:V,options:t})}catch(e){throw e}}async getPromptInternal({name:e,args:t,options:r}){try{return this.request({request:{method:"prompts/get",params:{name:e,arguments:t}},resultSchema:N,options:r})}catch(e){throw e}}async notification(e){const t={...e,jsonrpc:"2.0"};await this.transport.send(t)}async tools({schemas:e="automatic"}={}){var t;const r={};try{const n=await this.listTools();for(const{name:s,description:a,inputSchema:i,annotations:c}of n.tools){const n=null==c?void 0:c.title;if("automatic"!==e&&!(s in e))continue;const l=this,u=async(e,t)=>{var r;return null==(r=null==t?void 0:t.abortSignal)||r.throwIfAborted(),l.callTool({name:s,args:e,options:t})},h="automatic"===e?(0,o.dynamicTool)({description:a,title:n,inputSchema:(0,o.jsonSchema)({...i,properties:null!=(t=i.properties)?t:{},additionalProperties:!1}),execute:u}):(0,o.tool)({description:a,title:n,inputSchema:e[s].inputSchema,execute:u});r[s]=h}return r}catch(e){throw e}}listResources({params:e,options:t}={}){return this.listResourcesInternal({params:e,options:t})}readResource({uri:e,options:t}){return this.readResourceInternal({uri:e,options:t})}listResourceTemplates({options:e}={}){return this.listResourceTemplatesInternal({options:e})}listPrompts({params:e,options:t}={}){return this.listPromptsInternal({params:e,options:t})}getPrompt({name:e,arguments:t,options:r}){return this.getPromptInternal({name:e,args:t,options:r})}onClose(){if(this.isClosed)return;this.isClosed=!0;const e=new _({message:"Connection closed"});for(const t of this.responseHandlers.values())t(e);this.responseHandlers.clear()}onError(e){this.onUncaughtError&&this.onUncaughtError(e)}onResponse(e){const t=Number(e.id),r=this.responseHandlers.get(t);if(void 0===r)throw new _({message:`Protocol error: Received a response for an unknown message ID: ${JSON.stringify(e)}`});this.responseHandlers.delete(t),r("result"in e?e:new _({message:e.error.message,code:e.error.code,data:e.error.data,cause:e.error}))}}}}]);