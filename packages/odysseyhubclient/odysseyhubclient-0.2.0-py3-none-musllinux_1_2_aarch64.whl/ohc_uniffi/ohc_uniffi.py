

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform
from .odyssey_hub_common import Transport
from .odyssey_hub_common import _UniffiConverterTypeTransport
from .odyssey_hub_common import _UniffiRustBuffer as _UniffiRustBufferTransport

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_ohc_uniffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_ohc_uniffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_ohc_uniffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("ohc_uniffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_ohc_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_ohc_uniffi_checksum_method_accessorymapstream_next() != 41573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_anyhowerror_anyhow_message() != 64925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_connect() != 63815:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_get_accessory_map() != 36672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_get_device_list() != 41679:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_get_screen_info_by_id() != 23552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_get_shot_delay() != 36221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_reset_shot_delay() != 57428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_reset_zero() != 58662:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_save_shot_delay() != 13386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_set_shot_delay() != 15193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_subscribe_accessory_map() != 10121:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_subscribe_device_list() != 26882:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_subscribe_events() != 8368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_subscribe_shot_delay() != 13809:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_update_accessory_info_map() != 52687:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_write_vendor() != 6690:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_client_zero() != 4376:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_deviceliststream_next() != 45906:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_eventstream_next() != 38568:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_shotdelaystream_next() != 33061:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_trackinghistory_get_closest() != 53852:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_method_trackinghistory_push() != 36184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_constructor_client_new() != 65051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_ohc_uniffi_checksum_constructor_trackinghistory_new() != 38207:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_accessorymapstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_accessorymapstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_accessorymapstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_accessorymapstream.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_method_accessorymapstream_next.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_accessorymapstream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_clone_anyhowerror.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_anyhowerror.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_anyhowerror.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_anyhowerror.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_method_anyhowerror_anyhow_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_anyhowerror_anyhow_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ohc_uniffi_fn_clone_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_client.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_client.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_client.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_constructor_client_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_constructor_client_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_connect.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_connect.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_accessory_map.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_accessory_map.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_device_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_device_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_screen_info_by_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_screen_info_by_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_shot_delay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_shot_delay.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_shot_delay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_shot_delay.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_zero.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_zero.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_save_shot_delay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_save_shot_delay.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_set_shot_delay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint16,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_set_shot_delay.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_accessory_map.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_accessory_map.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_device_list.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_device_list.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_events.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_shot_delay.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_shot_delay.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_update_accessory_info_map.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_update_accessory_info_map.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_write_vendor.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint8,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_write_vendor.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_zero.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_client_zero.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_clone_deviceliststream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_deviceliststream.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_deviceliststream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_deviceliststream.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_method_deviceliststream_next.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_deviceliststream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_clone_eventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_eventstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_eventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_eventstream.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_method_eventstream_next.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_eventstream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_clone_shotdelaystream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_shotdelaystream.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_shotdelaystream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_shotdelaystream.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_method_shotdelaystream_next.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_shotdelaystream_next.restype = ctypes.c_uint64
_UniffiLib.uniffi_ohc_uniffi_fn_clone_trackinghistory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_clone_trackinghistory.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_free_trackinghistory.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_free_trackinghistory.restype = None
_UniffiLib.uniffi_ohc_uniffi_fn_constructor_trackinghistory_new.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_constructor_trackinghistory_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_get_closest.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_get_closest.restype = _UniffiRustBuffer
_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_push.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_push.restype = None
_UniffiLib.ffi_ohc_uniffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_ohc_uniffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_ohc_uniffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rustbuffer_free.restype = None
_UniffiLib.ffi_ohc_uniffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_ohc_uniffi_rust_future_free_void.restype = None
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_ohc_uniffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_ohc_uniffi_checksum_method_accessorymapstream_next.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_accessorymapstream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_anyhowerror_anyhow_message.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_anyhowerror_anyhow_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_connect.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_connect.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_accessory_map.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_accessory_map.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_device_list.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_device_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_screen_info_by_id.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_screen_info_by_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_shot_delay.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_get_shot_delay.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_reset_shot_delay.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_reset_shot_delay.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_reset_zero.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_reset_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_save_shot_delay.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_save_shot_delay.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_set_shot_delay.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_set_shot_delay.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_accessory_map.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_accessory_map.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_device_list.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_device_list.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_events.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_shot_delay.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_subscribe_shot_delay.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_update_accessory_info_map.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_update_accessory_info_map.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_write_vendor.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_write_vendor.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_zero.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_client_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_deviceliststream_next.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_deviceliststream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_eventstream_next.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_eventstream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_shotdelaystream_next.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_shotdelaystream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_trackinghistory_get_closest.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_trackinghistory_get_closest.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_method_trackinghistory_push.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_method_trackinghistory_push.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_constructor_client_new.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_constructor_client_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_ohc_uniffi_checksum_constructor_trackinghistory_new.argtypes = (
)
_UniffiLib.uniffi_ohc_uniffi_checksum_constructor_trackinghistory_new.restype = ctypes.c_uint16
_UniffiLib.ffi_ohc_uniffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_ohc_uniffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterFloat(_UniffiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.read_float()

    @staticmethod
    def write(value, buf):
        buf.write_float(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)



class AccessoryMapStreamProtocol(typing.Protocol):
    def next(self, ):
        raise NotImplementedError


class AccessoryMapStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_accessorymapstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_accessorymapstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def next(self, ) -> "typing.List[AccessoryMapEntry]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_accessorymapstream_next(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeAccessoryMapEntry.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )





class _UniffiConverterTypeAccessoryMapStream:

    @staticmethod
    def lift(value: int):
        return AccessoryMapStream._make_instance_(value)

    @staticmethod
    def check_lower(value: AccessoryMapStream):
        if not isinstance(value, AccessoryMapStream):
            raise TypeError("Expected AccessoryMapStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AccessoryMapStreamProtocol):
        if not isinstance(value, AccessoryMapStream):
            raise TypeError("Expected AccessoryMapStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AccessoryMapStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class AnyhowErrorProtocol(typing.Protocol):
    def anyhow_message(self, ):
        raise NotImplementedError


class AnyhowError(Exception):
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_anyhowerror, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_anyhowerror, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def anyhow_message(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_method_anyhowerror_anyhow_message,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAnyhowError__as_error(_UniffiConverterRustBuffer):
    @classmethod
    def read(cls, buf):
        raise NotImplementedError()

    @classmethod
    def write(cls, value, buf):
        raise NotImplementedError()

    @staticmethod
    def lift(value):
        # Errors are always a rust buffer holding a pointer - which is a "read"
        with value.consume_with_stream() as stream:
            return _UniffiConverterTypeAnyhowError.read(stream)

    @staticmethod
    def lower(value):
        raise NotImplementedError()

class _UniffiConverterTypeAnyhowError:

    @staticmethod
    def lift(value: int):
        return AnyhowError._make_instance_(value)

    @staticmethod
    def check_lower(value: AnyhowError):
        if not isinstance(value, AnyhowError):
            raise TypeError("Expected AnyhowError instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AnyhowErrorProtocol):
        if not isinstance(value, AnyhowError):
            raise TypeError("Expected AnyhowError instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AnyhowErrorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ClientProtocol(typing.Protocol):
    def connect(self, ):
        raise NotImplementedError
    def get_accessory_map(self, ):
        raise NotImplementedError
    def get_device_list(self, ):
        raise NotImplementedError
    def get_screen_info_by_id(self, screen_id: "int"):
        raise NotImplementedError
    def get_shot_delay(self, device: "Device"):
        raise NotImplementedError
    def reset_shot_delay(self, device: "Device"):
        raise NotImplementedError
    def reset_zero(self, device: "Device"):
        raise NotImplementedError
    def save_shot_delay(self, device: "Device"):
        raise NotImplementedError
    def set_shot_delay(self, device: "Device",delay_ms: "int"):
        raise NotImplementedError
    def subscribe_accessory_map(self, ):
        raise NotImplementedError
    def subscribe_device_list(self, ):
        raise NotImplementedError
    def subscribe_events(self, ):
        raise NotImplementedError
    def subscribe_shot_delay(self, device: "Device"):
        raise NotImplementedError
    def update_accessory_info_map(self, entries: "typing.List[AccessoryInfoMapEntry]"):
        raise NotImplementedError
    def write_vendor(self, device: "Device",tag: "int",data: "bytes"):
        raise NotImplementedError
    def zero(self, device: "Device",translation: "Vector3f32",target: "Vector2f32"):
        raise NotImplementedError


class Client:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_constructor_client_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_client, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_client, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def connect(self, ) -> None:

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_connect(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeAnyhowError__as_error,

        )



    async def get_accessory_map(self, ) -> "typing.List[AccessoryMapEntry]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_accessory_map(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeAccessoryMapEntry.lift,
            
    # Error FFI converter
_UniffiConverterTypeAnyhowError__as_error,

        )



    async def get_device_list(self, ) -> "typing.List[Device]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_device_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeDevice.lift,
            
    # Error FFI converter
_UniffiConverterTypeAnyhowError__as_error,

        )



    async def get_screen_info_by_id(self, screen_id: "int") -> "ScreenInfo":
        _UniffiConverterUInt8.check_lower(screen_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_screen_info_by_id(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt8.lower(screen_id)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeScreenInfo.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def get_shot_delay(self, device: "Device") -> "int":
        _UniffiConverterTypeDevice.check_lower(device)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_get_shot_delay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_u16,
            # lift function
            _UniffiConverterUInt16.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def reset_shot_delay(self, device: "Device") -> "int":
        _UniffiConverterTypeDevice.check_lower(device)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_shot_delay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_u16,
            # lift function
            _UniffiConverterUInt16.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def reset_zero(self, device: "Device") -> None:

        _UniffiConverterTypeDevice.check_lower(device)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_reset_zero(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def save_shot_delay(self, device: "Device") -> None:

        _UniffiConverterTypeDevice.check_lower(device)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_save_shot_delay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def set_shot_delay(self, device: "Device",delay_ms: "int") -> None:

        _UniffiConverterTypeDevice.check_lower(device)
        
        _UniffiConverterUInt16.check_lower(delay_ms)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_set_shot_delay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device),
        _UniffiConverterUInt16.lower(delay_ms)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def subscribe_accessory_map(self, ) -> "AccessoryMapStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_accessory_map(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeAccessoryMapStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def subscribe_device_list(self, ) -> "DeviceListStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_device_list(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeDeviceListStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def subscribe_events(self, ) -> "EventStream":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_events(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeEventStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def subscribe_shot_delay(self, device: "Device") -> "ShotDelayStream":
        _UniffiConverterTypeDevice.check_lower(device)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_subscribe_shot_delay(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_pointer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeShotDelayStream.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def update_accessory_info_map(self, entries: "typing.List[AccessoryInfoMapEntry]") -> None:

        _UniffiConverterSequenceTypeAccessoryInfoMapEntry.check_lower(entries)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_update_accessory_info_map(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeAccessoryInfoMapEntry.lower(entries)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def write_vendor(self, device: "Device",tag: "int",data: "bytes") -> None:

        _UniffiConverterTypeDevice.check_lower(device)
        
        _UniffiConverterUInt8.check_lower(tag)
        
        _UniffiConverterBytes.check_lower(data)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_write_vendor(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device),
        _UniffiConverterUInt8.lower(tag),
        _UniffiConverterBytes.lower(data)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )



    async def zero(self, device: "Device",translation: "Vector3f32",target: "Vector2f32") -> None:

        _UniffiConverterTypeDevice.check_lower(device)
        
        _UniffiConverterTypeVector3f32.check_lower(translation)
        
        _UniffiConverterTypeVector2f32.check_lower(target)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_client_zero(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDevice.lower(device),
        _UniffiConverterTypeVector3f32.lower(translation),
        _UniffiConverterTypeVector2f32.lower(target)
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_void,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )





class _UniffiConverterTypeClient:

    @staticmethod
    def lift(value: int):
        return Client._make_instance_(value)

    @staticmethod
    def check_lower(value: Client):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientProtocol):
        if not isinstance(value, Client):
            raise TypeError("Expected Client instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DeviceListStreamProtocol(typing.Protocol):
    def next(self, ):
        raise NotImplementedError


class DeviceListStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_deviceliststream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_deviceliststream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def next(self, ) -> "typing.List[Device]":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_deviceliststream_next(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterSequenceTypeDevice.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )





class _UniffiConverterTypeDeviceListStream:

    @staticmethod
    def lift(value: int):
        return DeviceListStream._make_instance_(value)

    @staticmethod
    def check_lower(value: DeviceListStream):
        if not isinstance(value, DeviceListStream):
            raise TypeError("Expected DeviceListStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DeviceListStreamProtocol):
        if not isinstance(value, DeviceListStream):
            raise TypeError("Expected DeviceListStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DeviceListStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EventStreamProtocol(typing.Protocol):
    def next(self, ):
        raise NotImplementedError


class EventStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_eventstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_eventstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def next(self, ) -> "Event":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_eventstream_next(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEvent.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )





class _UniffiConverterTypeEventStream:

    @staticmethod
    def lift(value: int):
        return EventStream._make_instance_(value)

    @staticmethod
    def check_lower(value: EventStream):
        if not isinstance(value, EventStream):
            raise TypeError("Expected EventStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EventStreamProtocol):
        if not isinstance(value, EventStream):
            raise TypeError("Expected EventStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EventStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ShotDelayStreamProtocol(typing.Protocol):
    def next(self, ):
        raise NotImplementedError


class ShotDelayStream:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_shotdelaystream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_shotdelaystream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def next(self, ) -> "int":
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_ohc_uniffi_fn_method_shotdelaystream_next(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_ohc_uniffi_rust_future_poll_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_complete_u16,
            _UniffiLib.ffi_ohc_uniffi_rust_future_free_u16,
            # lift function
            _UniffiConverterUInt16.lift,
            
    # Error FFI converter
_UniffiConverterTypeClientError,

        )





class _UniffiConverterTypeShotDelayStream:

    @staticmethod
    def lift(value: int):
        return ShotDelayStream._make_instance_(value)

    @staticmethod
    def check_lower(value: ShotDelayStream):
        if not isinstance(value, ShotDelayStream):
            raise TypeError("Expected ShotDelayStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ShotDelayStreamProtocol):
        if not isinstance(value, ShotDelayStream):
            raise TypeError("Expected ShotDelayStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ShotDelayStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TrackingHistoryProtocol(typing.Protocol):
    def get_closest(self, timestamp: "int"):
        raise NotImplementedError
    def push(self, event: "TrackingEvent"):
        raise NotImplementedError


class TrackingHistory:
    _pointer: ctypes.c_void_p
    def __init__(self, capacity: "int"):
        _UniffiConverterUInt32.check_lower(capacity)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_constructor_trackinghistory_new,
        _UniffiConverterUInt32.lower(capacity))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_free_trackinghistory, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_clone_trackinghistory, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_closest(self, timestamp: "int") -> "typing.Optional[TrackingEvent]":
        _UniffiConverterUInt32.check_lower(timestamp)
        
        return _UniffiConverterOptionalTypeTrackingEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_get_closest,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(timestamp))
        )





    def push(self, event: "TrackingEvent") -> None:
        _UniffiConverterTypeTrackingEvent.check_lower(event)
        
        _uniffi_rust_call(_UniffiLib.uniffi_ohc_uniffi_fn_method_trackinghistory_push,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTrackingEvent.lower(event))







class _UniffiConverterTypeTrackingHistory:

    @staticmethod
    def lift(value: int):
        return TrackingHistory._make_instance_(value)

    @staticmethod
    def check_lower(value: TrackingHistory):
        if not isinstance(value, TrackingHistory):
            raise TypeError("Expected TrackingHistory instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TrackingHistoryProtocol):
        if not isinstance(value, TrackingHistory):
            raise TypeError("Expected TrackingHistory instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TrackingHistoryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AccelerometerEvent:
    timestamp: "int"
    accel: "Vector3f32"
    gyro: "Vector3f32"
    euler_angles: "Vector3f32"
    def __init__(self, *, timestamp: "int", accel: "Vector3f32", gyro: "Vector3f32", euler_angles: "Vector3f32"):
        self.timestamp = timestamp
        self.accel = accel
        self.gyro = gyro
        self.euler_angles = euler_angles

    def __str__(self):
        return "AccelerometerEvent(timestamp={}, accel={}, gyro={}, euler_angles={})".format(self.timestamp, self.accel, self.gyro, self.euler_angles)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.accel != other.accel:
            return False
        if self.gyro != other.gyro:
            return False
        if self.euler_angles != other.euler_angles:
            return False
        return True

class _UniffiConverterTypeAccelerometerEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccelerometerEvent(
            timestamp=_UniffiConverterUInt32.read(buf),
            accel=_UniffiConverterTypeVector3f32.read(buf),
            gyro=_UniffiConverterTypeVector3f32.read(buf),
            euler_angles=_UniffiConverterTypeVector3f32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.timestamp)
        _UniffiConverterTypeVector3f32.check_lower(value.accel)
        _UniffiConverterTypeVector3f32.check_lower(value.gyro)
        _UniffiConverterTypeVector3f32.check_lower(value.euler_angles)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.timestamp, buf)
        _UniffiConverterTypeVector3f32.write(value.accel, buf)
        _UniffiConverterTypeVector3f32.write(value.gyro, buf)
        _UniffiConverterTypeVector3f32.write(value.euler_angles, buf)


class AccessoryEvent:
    info: "AccessoryInfo"
    kind: "AccessoryEventKind"
    def __init__(self, *, info: "AccessoryInfo", kind: "AccessoryEventKind"):
        self.info = info
        self.kind = kind

    def __str__(self):
        return "AccessoryEvent(info={}, kind={})".format(self.info, self.kind)

    def __eq__(self, other):
        if self.info != other.info:
            return False
        if self.kind != other.kind:
            return False
        return True

class _UniffiConverterTypeAccessoryEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccessoryEvent(
            info=_UniffiConverterTypeAccessoryInfo.read(buf),
            kind=_UniffiConverterTypeAccessoryEventKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAccessoryInfo.check_lower(value.info)
        _UniffiConverterTypeAccessoryEventKind.check_lower(value.kind)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessoryInfo.write(value.info, buf)
        _UniffiConverterTypeAccessoryEventKind.write(value.kind, buf)


class AccessoryInfo:
    name: "str"
    ty: "AccessoryType"
    assignment: "typing.Optional[int]"
    def __init__(self, *, name: "str", ty: "AccessoryType", assignment: "typing.Optional[int]"):
        self.name = name
        self.ty = ty
        self.assignment = assignment

    def __str__(self):
        return "AccessoryInfo(name={}, ty={}, assignment={})".format(self.name, self.ty, self.assignment)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.ty != other.ty:
            return False
        if self.assignment != other.assignment:
            return False
        return True

class _UniffiConverterTypeAccessoryInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccessoryInfo(
            name=_UniffiConverterString.read(buf),
            ty=_UniffiConverterTypeAccessoryType.read(buf),
            assignment=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterTypeAccessoryType.check_lower(value.ty)
        _UniffiConverterOptionalUInt64.check_lower(value.assignment)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterTypeAccessoryType.write(value.ty, buf)
        _UniffiConverterOptionalUInt64.write(value.assignment, buf)


class AccessoryInfoMapEntry:
    key: "int"
    info: "AccessoryInfo"
    def __init__(self, *, key: "int", info: "AccessoryInfo"):
        self.key = key
        self.info = info

    def __str__(self):
        return "AccessoryInfoMapEntry(key={}, info={})".format(self.key, self.info)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.info != other.info:
            return False
        return True

class _UniffiConverterTypeAccessoryInfoMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccessoryInfoMapEntry(
            key=_UniffiConverterUInt64.read(buf),
            info=_UniffiConverterTypeAccessoryInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.key)
        _UniffiConverterTypeAccessoryInfo.check_lower(value.info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.key, buf)
        _UniffiConverterTypeAccessoryInfo.write(value.info, buf)


class AccessoryMapEntry:
    key: "int"
    status: "AccessoryStatus"
    def __init__(self, *, key: "int", status: "AccessoryStatus"):
        self.key = key
        self.status = status

    def __str__(self):
        return "AccessoryMapEntry(key={}, status={})".format(self.key, self.status)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.status != other.status:
            return False
        return True

class _UniffiConverterTypeAccessoryMapEntry(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccessoryMapEntry(
            key=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeAccessoryStatus.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.key)
        _UniffiConverterTypeAccessoryStatus.check_lower(value.status)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.key, buf)
        _UniffiConverterTypeAccessoryStatus.write(value.status, buf)


class AccessoryStatus:
    info: "AccessoryInfo"
    connected: "bool"
    def __init__(self, *, info: "AccessoryInfo", connected: "bool"):
        self.info = info
        self.connected = connected

    def __str__(self):
        return "AccessoryStatus(info={}, connected={})".format(self.info, self.connected)

    def __eq__(self, other):
        if self.info != other.info:
            return False
        if self.connected != other.connected:
            return False
        return True

class _UniffiConverterTypeAccessoryStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AccessoryStatus(
            info=_UniffiConverterTypeAccessoryInfo.read(buf),
            connected=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAccessoryInfo.check_lower(value.info)
        _UniffiConverterBool.check_lower(value.connected)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAccessoryInfo.write(value.info, buf)
        _UniffiConverterBool.write(value.connected, buf)


class Device:
    uuid: "bytes"
    transport: "Transport"
    def __init__(self, *, uuid: "bytes", transport: "Transport"):
        self.uuid = uuid
        self.transport = transport

    def __str__(self):
        return "Device(uuid={}, transport={})".format(self.uuid, self.transport)

    def __eq__(self, other):
        if self.uuid != other.uuid:
            return False
        if self.transport != other.transport:
            return False
        return True

class _UniffiConverterTypeDevice(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Device(
            uuid=_UniffiConverterBytes.read(buf),
            transport=_UniffiConverterTypeTransport.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.uuid)
        _UniffiConverterTypeTransport.check_lower(value.transport)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.uuid, buf)
        _UniffiConverterTypeTransport.write(value.transport, buf)


class DeviceEvent:
    device: "Device"
    kind: "DeviceEventKind"
    def __init__(self, *, device: "Device", kind: "DeviceEventKind"):
        self.device = device
        self.kind = kind

    def __str__(self):
        return "DeviceEvent(device={}, kind={})".format(self.device, self.kind)

    def __eq__(self, other):
        if self.device != other.device:
            return False
        if self.kind != other.kind:
            return False
        return True

class _UniffiConverterTypeDeviceEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DeviceEvent(
            device=_UniffiConverterTypeDevice.read(buf),
            kind=_UniffiConverterTypeDeviceEventKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeDevice.check_lower(value.device)
        _UniffiConverterTypeDeviceEventKind.check_lower(value.kind)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDevice.write(value.device, buf)
        _UniffiConverterTypeDeviceEventKind.write(value.kind, buf)


class ImpactEvent:
    timestamp: "int"
    def __init__(self, *, timestamp: "int"):
        self.timestamp = timestamp

    def __str__(self):
        return "ImpactEvent(timestamp={})".format(self.timestamp)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        return True

class _UniffiConverterTypeImpactEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ImpactEvent(
            timestamp=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.timestamp)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.timestamp, buf)


class Matrix3f32:
    m11: "float"
    m12: "float"
    m13: "float"
    m21: "float"
    m22: "float"
    m23: "float"
    m31: "float"
    m32: "float"
    m33: "float"
    def __init__(self, *, m11: "float", m12: "float", m13: "float", m21: "float", m22: "float", m23: "float", m31: "float", m32: "float", m33: "float"):
        self.m11 = m11
        self.m12 = m12
        self.m13 = m13
        self.m21 = m21
        self.m22 = m22
        self.m23 = m23
        self.m31 = m31
        self.m32 = m32
        self.m33 = m33

    def __str__(self):
        return "Matrix3f32(m11={}, m12={}, m13={}, m21={}, m22={}, m23={}, m31={}, m32={}, m33={})".format(self.m11, self.m12, self.m13, self.m21, self.m22, self.m23, self.m31, self.m32, self.m33)

    def __eq__(self, other):
        if self.m11 != other.m11:
            return False
        if self.m12 != other.m12:
            return False
        if self.m13 != other.m13:
            return False
        if self.m21 != other.m21:
            return False
        if self.m22 != other.m22:
            return False
        if self.m23 != other.m23:
            return False
        if self.m31 != other.m31:
            return False
        if self.m32 != other.m32:
            return False
        if self.m33 != other.m33:
            return False
        return True

class _UniffiConverterTypeMatrix3f32(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Matrix3f32(
            m11=_UniffiConverterFloat.read(buf),
            m12=_UniffiConverterFloat.read(buf),
            m13=_UniffiConverterFloat.read(buf),
            m21=_UniffiConverterFloat.read(buf),
            m22=_UniffiConverterFloat.read(buf),
            m23=_UniffiConverterFloat.read(buf),
            m31=_UniffiConverterFloat.read(buf),
            m32=_UniffiConverterFloat.read(buf),
            m33=_UniffiConverterFloat.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterFloat.check_lower(value.m11)
        _UniffiConverterFloat.check_lower(value.m12)
        _UniffiConverterFloat.check_lower(value.m13)
        _UniffiConverterFloat.check_lower(value.m21)
        _UniffiConverterFloat.check_lower(value.m22)
        _UniffiConverterFloat.check_lower(value.m23)
        _UniffiConverterFloat.check_lower(value.m31)
        _UniffiConverterFloat.check_lower(value.m32)
        _UniffiConverterFloat.check_lower(value.m33)

    @staticmethod
    def write(value, buf):
        _UniffiConverterFloat.write(value.m11, buf)
        _UniffiConverterFloat.write(value.m12, buf)
        _UniffiConverterFloat.write(value.m13, buf)
        _UniffiConverterFloat.write(value.m21, buf)
        _UniffiConverterFloat.write(value.m22, buf)
        _UniffiConverterFloat.write(value.m23, buf)
        _UniffiConverterFloat.write(value.m31, buf)
        _UniffiConverterFloat.write(value.m32, buf)
        _UniffiConverterFloat.write(value.m33, buf)


class Matrix3x1f32:
    x: "float"
    y: "float"
    z: "float"
    def __init__(self, *, x: "float", y: "float", z: "float"):
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        return "Matrix3x1f32(x={}, y={}, z={})".format(self.x, self.y, self.z)

    def __eq__(self, other):
        if self.x != other.x:
            return False
        if self.y != other.y:
            return False
        if self.z != other.z:
            return False
        return True

class _UniffiConverterTypeMatrix3x1f32(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Matrix3x1f32(
            x=_UniffiConverterFloat.read(buf),
            y=_UniffiConverterFloat.read(buf),
            z=_UniffiConverterFloat.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterFloat.check_lower(value.x)
        _UniffiConverterFloat.check_lower(value.y)
        _UniffiConverterFloat.check_lower(value.z)

    @staticmethod
    def write(value, buf):
        _UniffiConverterFloat.write(value.x, buf)
        _UniffiConverterFloat.write(value.y, buf)
        _UniffiConverterFloat.write(value.z, buf)


class PacketEvent:
    ty: "int"
    data: "PacketData"
    def __init__(self, *, ty: "int", data: "PacketData"):
        self.ty = ty
        self.data = data

    def __str__(self):
        return "PacketEvent(ty={}, data={})".format(self.ty, self.data)

    def __eq__(self, other):
        if self.ty != other.ty:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypePacketEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PacketEvent(
            ty=_UniffiConverterUInt8.read(buf),
            data=_UniffiConverterTypePacketData.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt8.check_lower(value.ty)
        _UniffiConverterTypePacketData.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.ty, buf)
        _UniffiConverterTypePacketData.write(value.data, buf)


class Pose:
    rotation: "Matrix3f32"
    translation: "Matrix3x1f32"
    def __init__(self, *, rotation: "Matrix3f32", translation: "Matrix3x1f32"):
        self.rotation = rotation
        self.translation = translation

    def __str__(self):
        return "Pose(rotation={}, translation={})".format(self.rotation, self.translation)

    def __eq__(self, other):
        if self.rotation != other.rotation:
            return False
        if self.translation != other.translation:
            return False
        return True

class _UniffiConverterTypePose(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Pose(
            rotation=_UniffiConverterTypeMatrix3f32.read(buf),
            translation=_UniffiConverterTypeMatrix3x1f32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeMatrix3f32.check_lower(value.rotation)
        _UniffiConverterTypeMatrix3x1f32.check_lower(value.translation)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeMatrix3f32.write(value.rotation, buf)
        _UniffiConverterTypeMatrix3x1f32.write(value.translation, buf)


class ScreenInfo:
    id: "int"
    tl: "Vector2f32"
    tr: "Vector2f32"
    bl: "Vector2f32"
    br: "Vector2f32"
    def __init__(self, *, id: "int", tl: "Vector2f32", tr: "Vector2f32", bl: "Vector2f32", br: "Vector2f32"):
        self.id = id
        self.tl = tl
        self.tr = tr
        self.bl = bl
        self.br = br

    def __str__(self):
        return "ScreenInfo(id={}, tl={}, tr={}, bl={}, br={})".format(self.id, self.tl, self.tr, self.bl, self.br)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.tl != other.tl:
            return False
        if self.tr != other.tr:
            return False
        if self.bl != other.bl:
            return False
        if self.br != other.br:
            return False
        return True

class _UniffiConverterTypeScreenInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScreenInfo(
            id=_UniffiConverterUInt8.read(buf),
            tl=_UniffiConverterTypeVector2f32.read(buf),
            tr=_UniffiConverterTypeVector2f32.read(buf),
            bl=_UniffiConverterTypeVector2f32.read(buf),
            br=_UniffiConverterTypeVector2f32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt8.check_lower(value.id)
        _UniffiConverterTypeVector2f32.check_lower(value.tl)
        _UniffiConverterTypeVector2f32.check_lower(value.tr)
        _UniffiConverterTypeVector2f32.check_lower(value.bl)
        _UniffiConverterTypeVector2f32.check_lower(value.br)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.id, buf)
        _UniffiConverterTypeVector2f32.write(value.tl, buf)
        _UniffiConverterTypeVector2f32.write(value.tr, buf)
        _UniffiConverterTypeVector2f32.write(value.bl, buf)
        _UniffiConverterTypeVector2f32.write(value.br, buf)


class TrackingEvent:
    timestamp: "int"
    aimpoint: "Vector2f32"
    pose: "Pose"
    distance: "float"
    screen_id: "int"
    def __init__(self, *, timestamp: "int", aimpoint: "Vector2f32", pose: "Pose", distance: "float", screen_id: "int"):
        self.timestamp = timestamp
        self.aimpoint = aimpoint
        self.pose = pose
        self.distance = distance
        self.screen_id = screen_id

    def __str__(self):
        return "TrackingEvent(timestamp={}, aimpoint={}, pose={}, distance={}, screen_id={})".format(self.timestamp, self.aimpoint, self.pose, self.distance, self.screen_id)

    def __eq__(self, other):
        if self.timestamp != other.timestamp:
            return False
        if self.aimpoint != other.aimpoint:
            return False
        if self.pose != other.pose:
            return False
        if self.distance != other.distance:
            return False
        if self.screen_id != other.screen_id:
            return False
        return True

class _UniffiConverterTypeTrackingEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TrackingEvent(
            timestamp=_UniffiConverterUInt32.read(buf),
            aimpoint=_UniffiConverterTypeVector2f32.read(buf),
            pose=_UniffiConverterTypePose.read(buf),
            distance=_UniffiConverterFloat.read(buf),
            screen_id=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.timestamp)
        _UniffiConverterTypeVector2f32.check_lower(value.aimpoint)
        _UniffiConverterTypePose.check_lower(value.pose)
        _UniffiConverterFloat.check_lower(value.distance)
        _UniffiConverterUInt32.check_lower(value.screen_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.timestamp, buf)
        _UniffiConverterTypeVector2f32.write(value.aimpoint, buf)
        _UniffiConverterTypePose.write(value.pose, buf)
        _UniffiConverterFloat.write(value.distance, buf)
        _UniffiConverterUInt32.write(value.screen_id, buf)


class Vector2f32:
    x: "float"
    y: "float"
    def __init__(self, *, x: "float", y: "float"):
        self.x = x
        self.y = y

    def __str__(self):
        return "Vector2f32(x={}, y={})".format(self.x, self.y)

    def __eq__(self, other):
        if self.x != other.x:
            return False
        if self.y != other.y:
            return False
        return True

class _UniffiConverterTypeVector2f32(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Vector2f32(
            x=_UniffiConverterFloat.read(buf),
            y=_UniffiConverterFloat.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterFloat.check_lower(value.x)
        _UniffiConverterFloat.check_lower(value.y)

    @staticmethod
    def write(value, buf):
        _UniffiConverterFloat.write(value.x, buf)
        _UniffiConverterFloat.write(value.y, buf)


class Vector3f32:
    x: "float"
    y: "float"
    z: "float"
    def __init__(self, *, x: "float", y: "float", z: "float"):
        self.x = x
        self.y = y
        self.z = z

    def __str__(self):
        return "Vector3f32(x={}, y={}, z={})".format(self.x, self.y, self.z)

    def __eq__(self, other):
        if self.x != other.x:
            return False
        if self.y != other.y:
            return False
        if self.z != other.z:
            return False
        return True

class _UniffiConverterTypeVector3f32(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Vector3f32(
            x=_UniffiConverterFloat.read(buf),
            y=_UniffiConverterFloat.read(buf),
            z=_UniffiConverterFloat.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterFloat.check_lower(value.x)
        _UniffiConverterFloat.check_lower(value.y)
        _UniffiConverterFloat.check_lower(value.z)

    @staticmethod
    def write(value, buf):
        _UniffiConverterFloat.write(value.x, buf)
        _UniffiConverterFloat.write(value.y, buf)
        _UniffiConverterFloat.write(value.z, buf)


class VendorEventPacketData:
    len: "int"
    data: "bytes"
    def __init__(self, *, len: "int", data: "bytes"):
        self.len = len
        self.data = data

    def __str__(self):
        return "VendorEventPacketData(len={}, data={})".format(self.len, self.data)

    def __eq__(self, other):
        if self.len != other.len:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeVendorEventPacketData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return VendorEventPacketData(
            len=_UniffiConverterUInt8.read(buf),
            data=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt8.check_lower(value.len)
        _UniffiConverterBytes.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt8.write(value.len, buf)
        _UniffiConverterBytes.write(value.data, buf)





class AccessoryEventKind:
    def __init__(self):
        raise RuntimeError("AccessoryEventKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONNECT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], typing.Optional[int]):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'typing.Optional[int]', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AccessoryEventKind.CONNECT{self._values!r}"

        def __eq__(self, other):
            if not other.is_connect():
                return False
            return self._values == other._values
    class DISCONNECT:

        def __init__(self,):
            pass

        def __str__(self):
            return "AccessoryEventKind.DISCONNECT()".format()

        def __eq__(self, other):
            if not other.is_disconnect():
                return False
            return True
    
    class ASSIGNMENT_CHANGE:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], typing.Optional[int]):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'typing.Optional[int]', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"AccessoryEventKind.ASSIGNMENT_CHANGE{self._values!r}"

        def __eq__(self, other):
            if not other.is_assignment_change():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_connect(self) -> bool:
        return isinstance(self, AccessoryEventKind.CONNECT)
    def is_disconnect(self) -> bool:
        return isinstance(self, AccessoryEventKind.DISCONNECT)
    def is_assignment_change(self) -> bool:
        return isinstance(self, AccessoryEventKind.ASSIGNMENT_CHANGE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
AccessoryEventKind.CONNECT = type("AccessoryEventKind.CONNECT", (AccessoryEventKind.CONNECT, AccessoryEventKind,), {})  # type: ignore
AccessoryEventKind.DISCONNECT = type("AccessoryEventKind.DISCONNECT", (AccessoryEventKind.DISCONNECT, AccessoryEventKind,), {})  # type: ignore
AccessoryEventKind.ASSIGNMENT_CHANGE = type("AccessoryEventKind.ASSIGNMENT_CHANGE", (AccessoryEventKind.ASSIGNMENT_CHANGE, AccessoryEventKind,), {})  # type: ignore




class _UniffiConverterTypeAccessoryEventKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccessoryEventKind.CONNECT(
                _UniffiConverterOptionalUInt64.read(buf),
            )
        if variant == 2:
            return AccessoryEventKind.DISCONNECT(
            )
        if variant == 3:
            return AccessoryEventKind.ASSIGNMENT_CHANGE(
                _UniffiConverterOptionalUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_connect():
            _UniffiConverterOptionalUInt64.check_lower(value._values[0])
            return
        if value.is_disconnect():
            return
        if value.is_assignment_change():
            _UniffiConverterOptionalUInt64.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_connect():
            buf.write_i32(1)
            _UniffiConverterOptionalUInt64.write(value._values[0], buf)
        if value.is_disconnect():
            buf.write_i32(2)
        if value.is_assignment_change():
            buf.write_i32(3)
            _UniffiConverterOptionalUInt64.write(value._values[0], buf)







class AccessoryType(enum.Enum):
    DRY_FIRE_MAG = 0
    


class _UniffiConverterTypeAccessoryType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AccessoryType.DRY_FIRE_MAG
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == AccessoryType.DRY_FIRE_MAG:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == AccessoryType.DRY_FIRE_MAG:
            buf.write_i32(1)




# ClientError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ClientError(Exception):
    pass

_UniffiTempClientError = ClientError

class ClientError:  # type: ignore
    class NotConnected(_UniffiTempClientError):

        def __repr__(self):
            return "ClientError.NotConnected({})".format(repr(str(self)))
    _UniffiTempClientError.NotConnected = NotConnected # type: ignore
    class StreamEnd(_UniffiTempClientError):

        def __repr__(self):
            return "ClientError.StreamEnd({})".format(repr(str(self)))
    _UniffiTempClientError.StreamEnd = StreamEnd # type: ignore

ClientError = _UniffiTempClientError # type: ignore
del _UniffiTempClientError


class _UniffiConverterTypeClientError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ClientError.NotConnected(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ClientError.StreamEnd(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ClientError.NotConnected):
            return
        if isinstance(value, ClientError.StreamEnd):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ClientError.NotConnected):
            buf.write_i32(1)
        if isinstance(value, ClientError.StreamEnd):
            buf.write_i32(2)





class DeviceEventKind:
    def __init__(self):
        raise RuntimeError("DeviceEventKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCELEROMETER_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], AccelerometerEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'AccelerometerEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.ACCELEROMETER_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_accelerometer_event():
                return False
            return self._values == other._values
    class TRACKING_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], TrackingEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'TrackingEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.TRACKING_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_tracking_event():
                return False
            return self._values == other._values
    class IMPACT_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], ImpactEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'ImpactEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.IMPACT_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_impact_event():
                return False
            return self._values == other._values
    class CONNECT_EVENT:

        def __init__(self,):
            pass

        def __str__(self):
            return "DeviceEventKind.CONNECT_EVENT()".format()

        def __eq__(self, other):
            if not other.is_connect_event():
                return False
            return True
    
    class DISCONNECT_EVENT:

        def __init__(self,):
            pass

        def __str__(self):
            return "DeviceEventKind.DISCONNECT_EVENT()".format()

        def __eq__(self, other):
            if not other.is_disconnect_event():
                return False
            return True
    
    class ZERO_RESULT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], bool):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'bool', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.ZERO_RESULT{self._values!r}"

        def __eq__(self, other):
            if not other.is_zero_result():
                return False
            return self._values == other._values
    class SAVE_ZERO_RESULT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], bool):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'bool', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.SAVE_ZERO_RESULT{self._values!r}"

        def __eq__(self, other):
            if not other.is_save_zero_result():
                return False
            return self._values == other._values
    class PACKET_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], PacketEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'PacketEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"DeviceEventKind.PACKET_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_packet_event():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_accelerometer_event(self) -> bool:
        return isinstance(self, DeviceEventKind.ACCELEROMETER_EVENT)
    def is_tracking_event(self) -> bool:
        return isinstance(self, DeviceEventKind.TRACKING_EVENT)
    def is_impact_event(self) -> bool:
        return isinstance(self, DeviceEventKind.IMPACT_EVENT)
    def is_connect_event(self) -> bool:
        return isinstance(self, DeviceEventKind.CONNECT_EVENT)
    def is_disconnect_event(self) -> bool:
        return isinstance(self, DeviceEventKind.DISCONNECT_EVENT)
    def is_zero_result(self) -> bool:
        return isinstance(self, DeviceEventKind.ZERO_RESULT)
    def is_save_zero_result(self) -> bool:
        return isinstance(self, DeviceEventKind.SAVE_ZERO_RESULT)
    def is_packet_event(self) -> bool:
        return isinstance(self, DeviceEventKind.PACKET_EVENT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
DeviceEventKind.ACCELEROMETER_EVENT = type("DeviceEventKind.ACCELEROMETER_EVENT", (DeviceEventKind.ACCELEROMETER_EVENT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.TRACKING_EVENT = type("DeviceEventKind.TRACKING_EVENT", (DeviceEventKind.TRACKING_EVENT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.IMPACT_EVENT = type("DeviceEventKind.IMPACT_EVENT", (DeviceEventKind.IMPACT_EVENT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.CONNECT_EVENT = type("DeviceEventKind.CONNECT_EVENT", (DeviceEventKind.CONNECT_EVENT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.DISCONNECT_EVENT = type("DeviceEventKind.DISCONNECT_EVENT", (DeviceEventKind.DISCONNECT_EVENT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.ZERO_RESULT = type("DeviceEventKind.ZERO_RESULT", (DeviceEventKind.ZERO_RESULT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.SAVE_ZERO_RESULT = type("DeviceEventKind.SAVE_ZERO_RESULT", (DeviceEventKind.SAVE_ZERO_RESULT, DeviceEventKind,), {})  # type: ignore
DeviceEventKind.PACKET_EVENT = type("DeviceEventKind.PACKET_EVENT", (DeviceEventKind.PACKET_EVENT, DeviceEventKind,), {})  # type: ignore




class _UniffiConverterTypeDeviceEventKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DeviceEventKind.ACCELEROMETER_EVENT(
                _UniffiConverterTypeAccelerometerEvent.read(buf),
            )
        if variant == 2:
            return DeviceEventKind.TRACKING_EVENT(
                _UniffiConverterTypeTrackingEvent.read(buf),
            )
        if variant == 3:
            return DeviceEventKind.IMPACT_EVENT(
                _UniffiConverterTypeImpactEvent.read(buf),
            )
        if variant == 4:
            return DeviceEventKind.CONNECT_EVENT(
            )
        if variant == 5:
            return DeviceEventKind.DISCONNECT_EVENT(
            )
        if variant == 6:
            return DeviceEventKind.ZERO_RESULT(
                _UniffiConverterBool.read(buf),
            )
        if variant == 7:
            return DeviceEventKind.SAVE_ZERO_RESULT(
                _UniffiConverterBool.read(buf),
            )
        if variant == 8:
            return DeviceEventKind.PACKET_EVENT(
                _UniffiConverterTypePacketEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_accelerometer_event():
            _UniffiConverterTypeAccelerometerEvent.check_lower(value._values[0])
            return
        if value.is_tracking_event():
            _UniffiConverterTypeTrackingEvent.check_lower(value._values[0])
            return
        if value.is_impact_event():
            _UniffiConverterTypeImpactEvent.check_lower(value._values[0])
            return
        if value.is_connect_event():
            return
        if value.is_disconnect_event():
            return
        if value.is_zero_result():
            _UniffiConverterBool.check_lower(value._values[0])
            return
        if value.is_save_zero_result():
            _UniffiConverterBool.check_lower(value._values[0])
            return
        if value.is_packet_event():
            _UniffiConverterTypePacketEvent.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_accelerometer_event():
            buf.write_i32(1)
            _UniffiConverterTypeAccelerometerEvent.write(value._values[0], buf)
        if value.is_tracking_event():
            buf.write_i32(2)
            _UniffiConverterTypeTrackingEvent.write(value._values[0], buf)
        if value.is_impact_event():
            buf.write_i32(3)
            _UniffiConverterTypeImpactEvent.write(value._values[0], buf)
        if value.is_connect_event():
            buf.write_i32(4)
        if value.is_disconnect_event():
            buf.write_i32(5)
        if value.is_zero_result():
            buf.write_i32(6)
            _UniffiConverterBool.write(value._values[0], buf)
        if value.is_save_zero_result():
            buf.write_i32(7)
            _UniffiConverterBool.write(value._values[0], buf)
        if value.is_packet_event():
            buf.write_i32(8)
            _UniffiConverterTypePacketEvent.write(value._values[0], buf)







class Event:
    def __init__(self):
        raise RuntimeError("Event cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class ACCESSORY_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], AccessoryEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'AccessoryEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"Event.ACCESSORY_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_accessory_event():
                return False
            return self._values == other._values
    class DEVICE_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], DeviceEvent):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'DeviceEvent', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"Event.DEVICE_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_device_event():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_accessory_event(self) -> bool:
        return isinstance(self, Event.ACCESSORY_EVENT)
    def is_device_event(self) -> bool:
        return isinstance(self, Event.DEVICE_EVENT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
Event.ACCESSORY_EVENT = type("Event.ACCESSORY_EVENT", (Event.ACCESSORY_EVENT, Event,), {})  # type: ignore
Event.DEVICE_EVENT = type("Event.DEVICE_EVENT", (Event.DEVICE_EVENT, Event,), {})  # type: ignore




class _UniffiConverterTypeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Event.ACCESSORY_EVENT(
                _UniffiConverterTypeAccessoryEvent.read(buf),
            )
        if variant == 2:
            return Event.DEVICE_EVENT(
                _UniffiConverterTypeDeviceEvent.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_accessory_event():
            _UniffiConverterTypeAccessoryEvent.check_lower(value._values[0])
            return
        if value.is_device_event():
            _UniffiConverterTypeDeviceEvent.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_accessory_event():
            buf.write_i32(1)
            _UniffiConverterTypeAccessoryEvent.write(value._values[0], buf)
        if value.is_device_event():
            buf.write_i32(2)
            _UniffiConverterTypeDeviceEvent.write(value._values[0], buf)







class PacketData:
    def __init__(self):
        raise RuntimeError("PacketData cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNSUPPORTED:

        def __init__(self,):
            pass

        def __str__(self):
            return "PacketData.UNSUPPORTED()".format()

        def __eq__(self, other):
            if not other.is_unsupported():
                return False
            return True
    
    class VENDOR_EVENT:
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], VendorEventPacketData):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'VendorEventPacketData', got '{type(values[0])}'")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"PacketData.VENDOR_EVENT{self._values!r}"

        def __eq__(self, other):
            if not other.is_vendor_event():
                return False
            return self._values == other._values
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_unsupported(self) -> bool:
        return isinstance(self, PacketData.UNSUPPORTED)
    def is_vendor_event(self) -> bool:
        return isinstance(self, PacketData.VENDOR_EVENT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PacketData.UNSUPPORTED = type("PacketData.UNSUPPORTED", (PacketData.UNSUPPORTED, PacketData,), {})  # type: ignore
PacketData.VENDOR_EVENT = type("PacketData.VENDOR_EVENT", (PacketData.VENDOR_EVENT, PacketData,), {})  # type: ignore




class _UniffiConverterTypePacketData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PacketData.UNSUPPORTED(
            )
        if variant == 2:
            return PacketData.VENDOR_EVENT(
                _UniffiConverterTypeVendorEventPacketData.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_unsupported():
            return
        if value.is_vendor_event():
            _UniffiConverterTypeVendorEventPacketData.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_unsupported():
            buf.write_i32(1)
        if value.is_vendor_event():
            buf.write_i32(2)
            _UniffiConverterTypeVendorEventPacketData.write(value._values[0], buf)





class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTrackingEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTrackingEvent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTrackingEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTrackingEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceTypeAccessoryInfoMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAccessoryInfoMapEntry.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAccessoryInfoMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAccessoryInfoMapEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAccessoryMapEntry(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAccessoryMapEntry.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAccessoryMapEntry.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAccessoryMapEntry.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDevice(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDevice.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDevice.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDevice.read(buf) for i in range(count)
        ]

# External type Transport is in namespace "odyssey_hub_common", crate odyssey_hub_common




# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

__all__ = [
    "InternalError",
    "AccessoryEventKind",
    "AccessoryType",
    "ClientError",
    "DeviceEventKind",
    "Event",
    "PacketData",
    "AccelerometerEvent",
    "AccessoryEvent",
    "AccessoryInfo",
    "AccessoryInfoMapEntry",
    "AccessoryMapEntry",
    "AccessoryStatus",
    "Device",
    "DeviceEvent",
    "ImpactEvent",
    "Matrix3f32",
    "Matrix3x1f32",
    "PacketEvent",
    "Pose",
    "ScreenInfo",
    "TrackingEvent",
    "Vector2f32",
    "Vector3f32",
    "VendorEventPacketData",
    "AccessoryMapStream",
    "AnyhowError",
    "Client",
    "DeviceListStream",
    "EventStream",
    "ShotDelayStream",
    "TrackingHistory",
]

