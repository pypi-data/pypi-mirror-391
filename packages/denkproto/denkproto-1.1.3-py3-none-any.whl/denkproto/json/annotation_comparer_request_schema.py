# generated by datamodel-codegen:
#   filename:  annotation_comparer_request.schema.json
#   timestamp: 2025-11-12T11:48:57+00:00

from __future__ import annotations

from typing import Annotated, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from . import (
    classification_markup_schema,
    object_detection_markup_schema,
    ocr_markup_schema,
    segmentation_markup_schema,
)


class ClassLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    idx: int


class NetworkExperiment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    network_typename: str
    flavor: str
    class_labels: list[ClassLabel]


class Image(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    height: Annotated[int, Field(ge=0)]
    width: Annotated[int, Field(ge=0)]
    owned_by_group_id: UUID
    blob_id: UUID


class Blob(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    owned_by_group_id: UUID


class SegmentationMap(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    blob: Blob
    class_label: ClassLabel


class SegmentationMarkupMaps(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    segmentation_maps: list[SegmentationMap]


class AnnotationMarkup1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classification_markup: classification_markup_schema.ClassificationMarkup
    segmentation_markup: Optional[
        Union[segmentation_markup_schema.SegmentationMarkup, SegmentationMarkupMaps]
    ] = None
    object_detection_markup: Optional[
        object_detection_markup_schema.ObjectDetectionMarkup
    ] = None
    ocr_markup: Optional[ocr_markup_schema.OcrMarkup] = None


class AnnotationMarkup2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classification_markup: Optional[
        classification_markup_schema.ClassificationMarkup
    ] = None
    segmentation_markup: Union[
        segmentation_markup_schema.SegmentationMarkup, SegmentationMarkupMaps
    ]
    object_detection_markup: Optional[
        object_detection_markup_schema.ObjectDetectionMarkup
    ] = None
    ocr_markup: Optional[ocr_markup_schema.OcrMarkup] = None


class AnnotationMarkup3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classification_markup: Optional[
        classification_markup_schema.ClassificationMarkup
    ] = None
    segmentation_markup: Optional[
        Union[segmentation_markup_schema.SegmentationMarkup, SegmentationMarkupMaps]
    ] = None
    object_detection_markup: object_detection_markup_schema.ObjectDetectionMarkup
    ocr_markup: Optional[ocr_markup_schema.OcrMarkup] = None


class AnnotationMarkup4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classification_markup: Optional[
        classification_markup_schema.ClassificationMarkup
    ] = None
    segmentation_markup: Optional[
        Union[segmentation_markup_schema.SegmentationMarkup, SegmentationMarkupMaps]
    ] = None
    object_detection_markup: Optional[
        object_detection_markup_schema.ObjectDetectionMarkup
    ] = None
    ocr_markup: ocr_markup_schema.OcrMarkup


class AnnotationComparerRequest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    user1_id: Optional[UUID] = None
    user2_id: Optional[UUID] = None
    owned_by_group_id: UUID
    hasura_url: str
    created_by_user_id: UUID
    network_experiment: NetworkExperiment
    image: Image
    source: Union[
        AnnotationMarkup1, AnnotationMarkup2, AnnotationMarkup3, AnnotationMarkup4
    ]
    target: Union[
        AnnotationMarkup1, AnnotationMarkup2, AnnotationMarkup3, AnnotationMarkup4
    ]
