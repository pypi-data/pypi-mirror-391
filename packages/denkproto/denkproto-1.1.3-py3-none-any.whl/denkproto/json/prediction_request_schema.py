# generated by datamodel-codegen:
#   filename:  prediction_request.schema.json
#   timestamp: 2025-11-12T11:48:57+00:00

from __future__ import annotations

from enum import Enum
from typing import Annotated, Any, Literal, Optional, Union
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field, RootModel

from . import geometry_schema


class RequestType(Enum):
    standard = 'standard'
    ocr = 'ocr'


class Image(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    file_id: UUID
    height: Annotated[int, Field(ge=0)]
    width: Annotated[int, Field(ge=0)]
    owned_by_group_id: UUID
    blob_id: UUID


class ClassLabel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    idx: int


class NetworkConfig(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    uses_validation_tiling: bool
    metadata: Optional[dict[str, Any]] = None


class ModelBlob(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    owned_by_group_id: UUID
    blob_id: UUID


class OcrCharacterRestrictionPreset(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    value: str
    characters: str


class OcrCharacterRestriction(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    index: int
    allowed_characters: str
    number_of_characters: Annotated[int, Field(ge=0)]
    ocr_character_restriction_preset: OcrCharacterRestrictionPreset


class AnnotationType(Enum):
    POSITIVE = 'POSITIVE'
    NEGATIVE = 'NEGATIVE'
    IGNORE = 'IGNORE'
    ROI = 'ROI'


class OcrObject1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    label_id: UUID
    annotation_type: AnnotationType
    average_width: Annotated[float, Field(ge=0.0)]
    bounding_box: geometry_schema.BoundingBox
    polygon: Optional[geometry_schema.Polygon] = None


class OcrObject2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    label_id: UUID
    annotation_type: AnnotationType
    average_width: Annotated[float, Field(ge=0.0)]
    bounding_box: Optional[geometry_schema.BoundingBox] = None
    polygon: geometry_schema.Polygon


class Snapshot(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    onnx: ModelBlob
    pytorch: ModelBlob


class NetworkExperiment(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    id: UUID
    network_typename: str
    flavor: str
    class_labels: list[ClassLabel]
    config: NetworkConfig
    snapshot: Snapshot
    ocr_character_restrictions: Annotated[
        Optional[list[OcrCharacterRestriction]],
        Field(description='Only present for OCR prediction requests'),
    ] = None


class PredictionRequest1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_type: Annotated[
        Literal['standard'],
        Field(
            description='Discriminator field to identify the type of prediction request'
        ),
    ]
    id: UUID
    owned_by_group_id: UUID
    hasura_url: str
    created_by_user_id: UUID
    prediction_priority: int
    request_classification_interpretation: Annotated[
        bool, Field(description='Only present for standard prediction requests')
    ]
    network_experiment: NetworkExperiment
    image: Image
    objects: Annotated[
        Optional[list[Union[OcrObject1, OcrObject2]]],
        Field(description='Only present for OCR prediction requests'),
    ] = None


class PredictionRequest2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    request_type: Annotated[
        Literal['ocr'],
        Field(
            description='Discriminator field to identify the type of prediction request'
        ),
    ]
    id: UUID
    owned_by_group_id: UUID
    hasura_url: str
    created_by_user_id: UUID
    prediction_priority: int
    request_classification_interpretation: Annotated[
        Optional[bool],
        Field(description='Only present for standard prediction requests'),
    ] = None
    network_experiment: NetworkExperiment
    image: Image
    objects: Annotated[
        list[Union[OcrObject1, OcrObject2]],
        Field(description='Only present for OCR prediction requests'),
    ]


class PredictionRequest(RootModel[Union[PredictionRequest1, PredictionRequest2]]):
    root: Annotated[
        Union[PredictionRequest1, PredictionRequest2], Field(title='Prediction Request')
    ]
