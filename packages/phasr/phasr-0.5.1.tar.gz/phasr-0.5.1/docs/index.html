<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phasr Doc</title>
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="Documentation for the python package phasr">
    <meta name="author" content="Frederic Noël">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/stackoverflow-light.min.css"> <!-- Code highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script> <!-- Code highlighting -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <!-- Latex -->
    <link rel="stylesheet" href="style.css?">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:wght@400;700&family=Open+Sans:ital,wght@0,400;0,700;1,600&display=swap" rel="stylesheet">
    <script defer src="https://use.fontawesome.com/releases/v5.7.2/js/all.js" integrity="sha384-0pzryjIRos8mFBWMzSSZApWtPl/5++eIfzYmTgBBmXYdhvxPc+XcFEk+zJwDgWbP" crossorigin="anonymous"></script>
</head>
<body>

    <div class="navbar clear nav-top">
        <div class="row content">
            <a href="#"><img class="logo" src="phasr.svg"></a>
            <a class="nav-title" href="#"><b>phasr</b></a>
            <a class="right" style="text-decoration: underline;" href="#"><i class="fas fa-book"></i>&nbsp; Documentation</a>
            <a class="right" href="mailto:noel@itp.unibe.ch" target="_blank"><i class="fas fa-paper-plane"></i>&nbsp; noel@itp.unibe.ch</a>
        </div>
    </div>

    <div class="container clear">
        <div class="row wrapper">

            <div class="sidepanel">

                <a class="title" href="#intro">Introduction</a>
                
                <a class="section" href="#versions">Versions/Change-Log</a>
                <a class="section" href="#about">About this Package</a>
                <a class="section" href="#dependencies">Dependencies</a>

                <div class="divider left"></div>

                <a class="title" href="#gettingstarted">Getting Started</a>

                <a class="section" href="#installingapp">Installing the Package</a>
                 <a class="section" href="#openingapp">Using the Package</a>

                <div class="divider left"></div>

                <a class="title" href="#basicfeatures">Basic Modules</a>

                <a class="section" href="#nucleus">nucleus</a>
                <a class="section" href="#dirac_solver">dirac_solvers</a>
                <a class="section" href="#cross_section_fitter">cross_section_fitter</a>
                
                <div class="divider left"></div>

                <a class="title" href="#advanced">Common Use Cases</a>

                <a class="section" href="#ana">Cross section (analytic \(\rho_\text{ch}\))</a>
                <a class="section" href="#num">Cross section (numeric \(\rho_\text{ch}\))</a>
                <a class="section" href="#PV">Left-right Asymmetry (PVES)</a>
                <a class="section" href="#fit">Fit to Cross section data</a>
                
                <div class="divider left"></div>

                <a class="title" href="#moreinfo">More Info</a>
            
             <div class="space double"></div>

            </div>

            <div class="right-col">
            
                <!-- <h1 class="maintitle"> phasr </h1> -->

                <h1 id="intro">Introduction</h1>
                
                <p> <code> phasr </code> is a python package able to calculate scattering phase shifts for arbitrary radial potentials and calculate (elastic) electron nucleus scattering cross sections based on it. 
                    In combination with a fitting routine it can be used to fit elastic electron nucleus scattering data to extract charge density parameterizations. It is also possible to increase the precision sufficiently to quantitatively resolve parity violating electron scattering. 
                    Since Version 0.5.0 a module with fitting routines for the purpose of extracting charge distributions from elastic electron nucleus scattering is also part of the package. </p> 
            
                <h2 id="versions">Versions/Change-Log:</h2>
             
                <p>
                    <b>Version 0.5.1 :</b> Add cross_section_fitter module.<br>
                    <b>Version 0.4.0 :</b> Add left-right asymmetry.<br>
                    <b>Version 0.3.2 :</b> Extend docs.<br>
                    <b>Version 0.3.1 :</b> Add access to reference parameterizations.<br>
                    <b>Version 0.3.0 :</b> Add overlap integrals.<br>
                    <b>Version 0.2.2 :</b> Fix some dependencies.<br>
                    <b>Version 0.2.1 :</b> First PyPI Release.<br>
                    <b>Version 0.2.0 :</b> Basic features implemented.<br>
                    <b>Version 0.1.4 :</b> Build dirac_solvers module. <br>
                    <b>Version 0.1.3 :</b> Build nuclei module. <br>
                    <b>Version 0.1.2 :</b> Build skeleton. <br>
                    <b>Version 0.1.0 :</b> First init. Empty. 
                </p>
                
                <h2 id="about">About this Package</h2>
                
                <p> This package was developed with the goal of extracting charge density parameterizations based on (elastic) electron nucleus scattering cross section data while properly accounting for Coulomb corrections using the so called phase shift model. 
                While this procedure is known since the 60s, the documentation and availability of programs used back then, are very limited and hardly accessible. 
                Furthermore, for a majority of nuclei the extractions of model-independent parameterizations of their charge densities have not been updated since the 80s and do not provide any uncertainty estimates. 
                Since these also applied to the nuclei we were interested in, we build such a framework in Python, which calculates elastic electron nucleus scattering cross sections based on input charge densities using the phase shift model, from which this package evolved. 
                With such a more modern implementation and programming language, the calculations can become faster, broader accessible, easier to understand and easier to incorporate into existing programs. 
                The code leading up to this package has already been used successfully in the papers <a href="https://inspirehep.net/literature/2796887"> [Noël, Hoferichter - 2024] </a> and <a href="https://inspirehep.net/literature/2856799"> [Heinz, Hoferichter, Miyagi, Noël, Schwenk - 2024] </a> 
                to calculate and extract charge distributions for nuclei of interest to \( \mu \to e \) conversion, a beyond the Standard Model process of interest in particle physics as well as parity violating electron scattering. The package has been successfully employed for nuclei reaching from \(^{27}\)Al to \(^{208}\)Pb . 
                
                <h2 id="dependencies">Dependencies</h2>
                
                <p>This program is built with/for python 3. <br> <br>
                <u> It requires the following packages to operate properly: </u> <br>
                numpy <br> <!--(add Version?)-->
                scipy <br> <!--(add Version?)-->
                mpmath <br> <!--(add Version?)-->
                </p>
                 
        <div class="divider" style="width:24%; margin:30px 0;"></div>

                <h1 id="gettingstarted">Getting Started</h1>

                <h2 id="installingapp">Install the package</h2>
                
                <p> To install and use the program please follow the following steps for setup. We assume you already have a working python environment setup on your machine. <!--(add link to setup explanation?)--><br>
                The package is listed on <a href="https://pypi.org/project/phasr/">PyPI</a>, which is why it can be easily installed via:
                <pre><code> pip install phasr </code></pre>
                This should also install the required packages as listed <a href="#dependencies"> above </a>, if they are not already installed. <br> 
                If you want the latest (development) version, you can clone it from the <a href="https://github.com/Partynumbers42/phasr"> phasr GitHub repository </a>. <br> 
                Note that in this case you might need to install the required packages as listed <a href="#dependencies"> above </a> manually.  
                </p>

                <h2 id="openingapp">Use the package</h2>
                
                    <p>You can import the python package the same way as every other package, i.e.: 
                    <pre><code> import phasr as phr </code></pre>
                    You can then use the contained methods in the standard way. For example
                    <pre><code class="python"> nucleus_Al27 = phr.nucleus(name='Al27',Z=13,A=27,rc=5)
 mmu = phr.masses.mmu
 boundstates_Al27 = phr.boundstates(nucleus_Al27,kappa=-1,lepton_mass=mmu) 
 print('E_1s=',boundstates_Al27.energy_levels[0],'MeV') </code></pre>
                    will give you the groundstate energy of a muonic atom for the nucleus parameterization, described used a uniform charge distribution of charge 13 and a radius of 5 fm. 
                    We will assume the import with the alias <code>phr</code> throughout this manual. 
                    </p>
                    
            <div class="divider" style="width:24%; margin:30px 0;"></div>
            
                <h1 id="basicfeatures">Basic Modules</h1>
                
                <p> The code is structured into two main modules. 
                    The <code>nuclei</code> module is home of the <code>nucleus</code> class and manages all the relevant properties of a nucleus/isotope that is considered and calculates other properties based on the information it has available (e.g. the electric field from the charge density). 
                    The <code>dirac_solvers</code> module is home of the <code>boundstates</code> and <code>continuumstates</code> classes and manages solving the Dirac equation for a given nucleus based on its nucleus potential and returns the desired consequential quantities like for example electron wave functions, phase shifts or the crosssection. 
                    In all applicational scenarios one will first construct a <code>nucleus</code> object, which is then be used to construct a <code>boundstates</code> or <code>continuumstates</code> object. For calculating elastic scattering crosssections we supply the function <code>crosssection_lepton_nucleus_scattering</code>, 
                    which can be used to directly calculate the crosssection using the energy, the angle and a <code>nucleus</code> object. </p>

                <h2 id="nucleus">The <code>nucleus</code> class </h2>
                
                <p> To get a nucleus parameterization, use the <code>nucleus</code> class to construct a nucleus object. 
                    A nucleus object requires a few minimum parameters (e.g. a name, a charge \(Z\) and a nucleon number \(A\)) and and has a lot of optional parameters (e.g. some parameters for a specific parameterization). 
                    Based on the parameters supplied the class decides what kind of nucleus it is supposed to construct. You can check what parameterization was choosen based on the attribute <code>nucleus_type</code>
                    
                    <pre><code class="python"> phr.nucleus(name,Z,A,m=None,**args) </code></pre>
                    
                    General parameters are:

                    <ul>
                        <li>
                        <b>name</b> (<i>str</i>): Label for the nucleus, part of the filename if things about this nucleus are saved, should be unique.
                        <br>
                        <li>
                        <b>Z</b> (<i>int</i>): Nuclear charge number / proton number of the considered nucleus, necessary for the normalization. 
                        Will raise a warning if not consistent with the normalization of a provided charge density in **args. 
                        <li>
                        <b>A</b> (<i>int</i>): Atomic mass number / nucleon number of the considered nucleus, necessary for recoil, 
                        enables lookup of nucleon mass, spin, parity and isotope abundancy.
                        <li>
                        <b>m</b> (<i>float</i>,optional) mass of the nucleus, necessary for recoil, is looked up based on \(Z\), \(A\) if not supplied.
                        <br>
                        <li>
                        <b>abundance</b> (<i>float</i>,optional) natural abundance of the nucleus, stored for convencience, is looked up based on \(Z\), \(A\) if not supplied.
                        <br>
                        <li>
                        <b>spin</b> (<i>float</i>,optional) spin of the nucleus, restricts what multipoles can exist, is looked up based on \(Z\), \(A\) if not supplied.
                        <br>
                        <li>
                        <b>parity</b> (<i>float</i>,optional) parity of the nucleus, stored for convenience, is looked up based on \(Z\), \(A\) if not supplied.
                        <br>
                        <li>
                        <b>k_barrett</b> (<i>float</i>,optional) value of k used to calculate barrett moments.
                        <br>
                        <li>
                        <b>alpha_barrett</b> (<i>float</i>,optional) value of alpha used to calculate barrett moments.
                        <br>
                    </ul>
                    
                    Parameterization specific parameters are:

                    <table>
                        <tr>
                          <th>nucleus_type&emsp;&emsp;</th>
                          <th>Parameters / **args</th>
                        </tr>
                        <tr>
                            <td>'coulomb'</td>
                            <td> None</td>
                        </tr>
                        <tr>
                            <td>'fourier-bessel'</td>
                            <td><b>ai</b> (<i>1d-array</i>): Array of parameters \(a_i\) in fm\(^{-3}\). \(N\) given by length of a.  
                            <br><b>R</b> (<i>float</i>): Cutoff radius R in fm. </td>
                        </tr>
                        <tr>
                            <td>'oszillator-basis'</td>
                            <td><b>Ci_dict</b> (<i>dict</i>): dictionary of 1d-arrays \(C_i\), with multipole names as keys (see below). </td>
                        </tr>
                        <tr>
                            <td>'fermi'</td>
                            <td><b>c</b> (<i>float</i>): \(c\) parameter in fm for Fermi parameterization. 
                            <br><b>z</b> (<i>float</i>): \(z\) parameter in fm for Fermi parameterization.
                            <br><b>w</b> (<i>float</i>,optional): \(w\) parameter for Fermi parameterization (default: w=0). </td>
                        </tr>
                        <tr>
                            <td>'gauss'</td>
                            <td><b>b</b> (<i>float</i>): \(b\) parameter in fm for Gauss parameterization. </td>
                        </tr>
                        <tr>
                            <td>'uniform'</td>
                            <td><b>rc</b> (<i>float</i>): \(r_c\) parameter in fm for Uniform parameterization. </td>
                        </tr>
                        <tr>
                            <td>'numerical'</td>
                            <td> see below </td>
                        </tr>
                          
                      </table> 

                <br>The parameterizations are based on:
                \[ \rho_\text{FB}(r) = \begin{cases} \sum_{i=1}^N a_i ~ j_0(q_i r) & r \leq R \\ 0 & r > R \end{cases} \qquad q_i= \frac{i \pi}{R} \]
                \[ \rho_\text{Fermi}(r) = \rho_0 \frac{1+w \tfrac{r^2}{c^2}}{1 + e^{(r-c)/z}}<!--; \qquad \rho_0 = \frac{Z}{8\pi z^3} (-\text{Li}_3(-e^{c/z}) - 12 w \tfrac{z^2}{c^2} \text{Li}_5(-e^{c/z}) )^{-1} -->\]
                \[ \rho_\text{Gauss}(r) = \frac{Z}{\pi^{3/2} b^3} e^{-(r/b)^2} \]
                \[ \rho_\text{Uni}(r) = \begin{cases} \frac{3 Z}{4 \pi r_c^3} & r \leq r_c \\ 0 & r > r_c \end{cases} \]
                \[ F_\text{Osz}(q) = e^{-u(q)/2} \sum_i C_i ~ u(q)^i; \qquad u(q)=\frac{q^2 b^2}{2} \]
            
            Apart from storing the input parameters a <code> nucleus </code> object can have the following attributes (if the prerequisites are met), that you might want to access
            <ul>
                <li>
                <b>charge_density(r)</b> (<i>callable</i>): charge density in fm\(^{-3}\) for r in fm
                <br>    
                <li>
                <b>form_factor(q)</b> (<i>callable</i>): normalized form factor (\(F_\text{ch}(0)=1\)) for q in MeV
                <br>
                <li>
                <b>electric_field(r)</b> (<i>callable</i>): electric field in fm\(^{-2}\) for r in fm
                <br>
                <li>
                <b>electric_potential(r)</b> (<i>callable</i>): electric potential in fm\(^{-1}\) for r in fm
                <br>
                <li>
                <b>proton_density(r)</b> (<i>callable</i>): proton density in fm\(^{-3}\) for r in fm
                <br>
                <li>
                <b>neutron_density(r)</b> (<i>callable</i>): neutron density in fm\(^{-3}\) for r in fm
                <br>
                <li>    
                <b>weak_density(r)</b> (<i>callable</i>): weak density in fm\(^{-3}\) for r in fm
                <br>
                <li>
                <b>charge_radius</b> (<i>float</i>): charge radius in fm (also attribute charge_radius_sq in fm\(^2\) exists)
                <br>
                <li>
                <b>proton_radius</b> (<i>float</i>): proton radius in fm (also attribute proton_radius_sq in fm\(^2\) exists)
                <br>
                <li>
                <b>neutron_radius</b> (<i>float</i>): neutron radius in fm (also attribute neutron_radius_sq in fm\(^2\) exists)
                <br>
                <li>
                <b>weak_radius</b> (<i>float</i>): weak radius in fm (also attribute weak_radius_sq in fm\(^2\) exists)
                <br>
                <li>
                <b>total_charge</b> (<i>float</i>): total charge from the charge density. Generates warning if total_charge and Z differ significantly.
                <br> 
                <li>
                <b>weak_charge</b> (<i>float</i>): weak charge of the weak density 
                <br>     
            </ul>

            One can also supply general descriptions for charge_density, form_factor or the different multipoles. These get the label of nucleus_type 'numerical'. 
            Here the other quantities can be calculated based on the given ones using numerical methods. Possible parameters are:
                
                <table>
                <tr>
                    <th>Parameters/**args</th> <th></th>
                </tr>
                <tr>
                    <td><b>charge_density</b> (<i>callable,optional</i>):</td> <td>Function describing the charge density (see below).</td>
                </tr>
                <tr>
                    <td><b>form_factor</b> (<i>callable,optional</i>):</td> <td>Function describing the form factor (see below).</td>
                </tr>
                <tr>
                    <td><b>electric_field</b> (<i>callable,optional</i>):</td> <td>Function describing the electric field (see below).</td>
                </tr>
                <tr>
                    <td><b>electric_potential</b> (<i>callable,optional</i>):</td> <td>Function describing the electric potential (see below).</td>
                </tr>
                <tr>
                    <td><b>form_factor_dict</b> (<i>dict,optional</i>):</td> <td>Dictionary containing form factor functions for specific multipoles (keys are 'F'+multipole , see below).</td>
                </tr>
                <tr>
                    <td><b>density_dict</b> (<i>dict,optional</i>):</td> <td>Dictionary containing density functions for specific multipoles (keys are 'rho'+multipole , see below).</td>
                </tr>
                </table>

                To adjust the way in which the numerical calculations are happening there are three parameters (unique to the nucleus_type 'numcerial') which can be set:

                <table>
                <tr>
                    <td><b>rrange</b> (<i>list,optional</i>):</td> <td>Sets range parameters for the beginning of the integration and highenergy continuation (in fm, default: [0.,20.,0.02]).</td>
                </tr>
                <tr>
                    <td><b>qrange</b> (<i>list,optional</i>):</td> <td>Sets range parameters for the beginning of the integration and highenergy continuation (in MeV, default: [0.,1000.,1.]).</td>
                </tr>
                <tr>
                    <td><b>renew</b> (<i>bool,optional</i>):</td> <td>Says if numerical calculations should be done from scratch (aka renewed) or recovered from file if existent (default: False).</td>
                </tr>
                </table>
            
            
            For the 'numerical' nuclei type, related quantities first need to be calculated numerically. Scalar quantities like the total charge or charge radius are calculated by default, 
            but the construction of functions, requires the explicit call of one of the following attribute, due to their runtime. The resulting splines are saves and and can be recovered 

            <ul>
                <li>
                <b>fill_gasp()</b> (<i>callable</i>): Runs a combination of the functions below to calculate everything it can calculate base on the supplied quantities. 
                <br>    
                <li>
                <b>set_electric_field_from_charge_density()</b> (<i>callable</i>): Calculates the electric_field based of the charge_density. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_electric_potential_from_electric_field()</b> (<i>callable</i>): Calculates the electric_potential based of the electric_field. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_form_factor_from_charge_density()</b> (<i>callable</i>): Calculates the form_factor based of the charge_density. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_charge_density_from_electric_field()</b> (<i>callable</i>): Calculates the charge_density based of the electric_field. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_electric_field_from_electric_potential()</b> (<i>callable</i>): Calculates the electric_potential based of the electric_potential. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_charge_density_from_form_factor()</b> (<i>callable</i>): Calculates the charge_density based of the form_factor. Splines and saves the result. Includes highenergy continuation.
                <br>
                <li>
                <b>set_density_dict_from_form_factor_dict()</b> (<i>callable</i>): Calculates the multipole densities based of the multipole form factors (structure functions). 
                <br>
                <li>
                <b>set_form_factor_dict_from_density_dict()</b> (<i>callable</i>): Calculates the  multipole form factors (structure functions) based of the multipole densities. 
                <br>
            </ul>

            The 'fermi' nucleus_type also has a few of these attributes as not all quantities can be written in a simple closed analytic form (that would be faster to evaluate as the numerical integrals), for this parameterization.<br>
            If a form_factor_dict or density_dict is supplied the different multipoles also become attributes (as 'F'+multipole or 'rho'+multipole). <br>
            The multipoles follow the naming pattern of 
            multipole = multipole_name + L + N, which gives for example : 'M0p', 'M0n', 'M2p', 'M2n', ... , 'Phipp0p', 'Phipp0n', ... , 'Delta1p', ... , 'Sigmap1n', ... , which should be the way in which the keys of the dictionaries are written (as 'F'+multipole or 'rho'+multipole). 
            Existing multipoles are collected in the attribute <code>multipoles</code>. <br>
            Further attributes are <code>Fch(q,L=0)</code>, <code>Fw(q,L=0)</code>, <code>Fmag(q,L=1)</code>, which make it possible to also access the form factors for higher \(L\) if the necessary multipoles were supplied. 
            </p>

                <h2 id="dirac_solver">The <code>dirac_solvers</code> module</h2>

                    <p>The <code>dirac_solvers</code> module has two main duties, covered by two classes. 
                    The <code>boundstates</code> class calculates the boundstate solutions of a given nucleus by solving the Dirac equation in the presence of the nucleus potential, which includes finding the boundstate energy first.  
                    The <code>continuumstates</code> class calculates the continuumstate solution for a given energy of a given nucleus by solving the Dirac equation in the presence of the nucleus potential.  
                    Finally, there are some functions that make use of the boundstate and continuumstate solutions by calculating elastic electron nucleus scattering crosssections and overlap integrals for \(\mu \to e\) conversion.<br>
                    
                    The boundstate and continuumstate wavefunctions are both parameterized according to 
                    \[ \psi = \psi_\kappa^\mu(\vec{r})= \frac{1}{r} \Bigg(\begin{array}{c}
                     g_\kappa(r) \phi_\kappa^\mu(\hat{r}) \\ i f_\kappa(r) \phi_{-\kappa}^\mu(\hat{r}) \end{array} \Bigg), \]
                    separating off the angular degrees of freedom, which are the same for all radial symmetric potential. The \(\kappa\) label refers to the angular momentum quantum numbers and spin according to
                    \[j = |\kappa| - \frac{1}{2}; \quad l = \begin{cases} \kappa, & \quad \kappa > 0 \\ - \kappa - 1 , & \quad \kappa < 0 \end{cases}\]
                    The numerical calculations then provide descriptions for \(g_\kappa(r)\) and \(f_\kappa(r)\).  
                    </p>  
                
                    <u><p><b> The <code>boundstates</code> class: </b></u><br>
                    The <code>boundstates</code> class is used to calculate the boundstates for a given <code>nucleus</code> object, beginning from the ground state for the given partial wave. 
                    First the energy for the boundstate is found by iteratively scanning for flips in the asymptotic behaviour of the wave functions, which indicate a boundstate in between, until a set precision is reached. 
                    For this energy then the solution of the Dirac equation gives the dirac wavefunction for that state. 
                
                    <pre><code class="python"> phr.boundstates(nucleus,kappa,lepton_mass,**args) </code></pre> 
                    <ul>
                        <li>
                        <b>nucleus</b> (<i>nucleus object</i>): Nucleus, whose electric potential is used for the calculation. 
                        <br>
                        <li>
                        <b>kappa</b> (<i>int</i>): selects total spin and angular momentum quantum number. 
                        <br>
                        <li>
                        <b>lepton_mass</b> (<i>float</i>): mass of the lepton bound to the nucleus in MeV. Common choices are electron mass <code>phr.masses.me</code> or muon mass <code>phr.masses.mmu</code>. needs to be non-zero.
                        <br>
                        <li>
                        <b>bindingenergy_limit_lower</b> (<i>float,optional</i>): lower limit for the binding energy to look for boundstates. If not provided uses the potential at zero as the lower bound.  
                        <br>
                        <li>
                        <b>bindingenergy_limit_upper</b> (<i>float,optional</i>): upper limit for the binding energy to look for boundstates (default: 0). 
                        <br>
                        <li>
                        <b>**args</b> (<i>dict,optional</i>): Additional keywords can be used to pass parameters to the underlying numerical routine (including parameters for <code>scipy.integrate.solve_IVP</code>). Default values are set by <code>phr.default_boundstate_settings</code>. 
                        <br> 
                    </ul>

                    Apart from storing the input paramters the <code>boundstates</code> object has the following attributes, which you might want to access:

                    <ul>
                        <li>
                        <b>principal_quantum_numbers</b> (<i>list of int's</i>): principal quantum numbers of the calculated boundstates. 
                        <br>
                        <li>
                        <b>energy_levels</b> (<i>list of floats</i>): energy values of the calculated boundstates.   
                        <br>
                        <li>
                        <b>find_next_energy_level()</b> (<i>callable</i>): called to find the next boundstate energy (for that /(\kappa/)). The groundstate energy is always calculated at initialisation. 
                        <br>    
                        <li>
                        <b>solve_IVP_at_current_energy()</b> (<i>callable</i>): called to calculate the boundstate wavefunctions at the current boundstate energy. The groundstate wavefunction is always calculated at initialisation. 
                        <br>    
                        <li>
                        <b>find_next_solution(**args)</b> (<i>callable</i>): same as calling <code>find_next_energy_level</code> and <code>solve_IVP_at_current_energy</code> consecutively. Can be passed **args to change the <code>solver_setting</code>.  
                        <br>    
                        <li>
                        <b>wavefunction_g_&lt;state&gt;(r)</b> (<i>callable</i>): returns the upper radial component of the wavefunction evaluated at r in fm for the state &lt;state&gt;. Exists only if <code>find_next_solution()</code> was called enough times.
                        Example: Groundstate is wavefunction_g_1s12 (using \(\kappa=-1\))
                        <br>
                        <li>
                        <b>wavefunction_f_&lt;state&gt;(r)</b> (<i>callable</i>): returns the lower radial component of the wavefunction evaluated at r in fm  for the state &lt;state&gt;. Exists only if <code>find_next_solution()</code> was called enough times.
                        Example: Groundstate is wavefunction_f_1s12 (using \(\kappa=-1\))
                        <br> 
                    </ul>
                    
                    The states are labeled according to principal quantum numbers, angular momentum quantum number and total spin following the scheme of atomic orbitals here writte according to
                    &lt;state&gt;=1s12, 2s12, ..., 2p12, 2d12, ..., 2p32, 2d32, ... .<br> <br>

                    <u><b> The <code>continuumstate</code> class: </b></u><br>
                    
                    <pre><code class="python"> phr.continuumstates(nucleus,kappa,energy,lepton_mass=0,**args) </code></pre> 
                    <ul>
                        <li>
                        <b>nucleus</b> (<i>nucleus object</i>): Nucleus, whose electric potential is used for the calculation. 
                        <br>
                        <li>
                        <b>kappa</b> (<i>int</i>): selects total spin and angular momentum quantum number. 
                        <br>
                        <li>
                        <b>energy</b> (<i>float</i>): energy of the (initial) lepton in MeV. 
                        <br>
                        <li>
                        <b>lepton_mass</b> (<i>float,optional</i>): mass of the lepton bound to the nucleus in MeV (default: 0). Can be set to 0 if energy \(\gg\) lepton_mass, which gives significant runtime improvements.
                        <br>
                        <li>
                        <b>**args</b> (<i>dict,optional</i>): Additional keywords can be used to pass parameters to the underlying numerical routine (including parameters for <code>scipy.integrate.solve_IVP</code>). Default values are set by <code>phr.default_continuumstate_settings</code>. 
                        <br> 
                    </ul>

                    Apart from storing the input paramters the <code>continuumstates</code> object has the following attributes, which you might want to access:

                    <ul>
                        <li>
                        <b>solve_IVP()</b> (<i>callable</i>): called to calculate the continuumstate wavefunctions for the given energy. Needs to be called once explicitly, does not happen at initialisation. 
                        <br>    
                        <li>
                        <b>wavefunction_g(r)</b> (<i>callable</i>): returns the upper radial component of the wavefunction evaluated at r in fm for the given energy. exists only if <code>solve_IVP()</code> was called.
                        <br>
                        <li>
                        <b>wavefunction_f(r)</b> (<i>callable</i>): returns the upper radial component of the wavefunction evaluated at r in fm for the given energy. exists only if <code>solve_IVP()</code> was called.
                        <br>
                        <li>
                        <b>extract_phase_shift()</b> (<i>callable</i>): called to calculate the asymptotic phase shift for the given energy. Needs to be called once explicitly, does not happen at initialisation. Faster than calling <code>solve_IVP()</code>.
                        <br>
                        <li>
                        <b>phase_difference</b> (<i>float</i>): difference between the phase shift of a Coulomb potential and the considered nucleus potential. 
                        <br>
                        <li>
                        <b>phase_shift</b> (<i>float</i>): phase shift of the considered nucleus potential. Input for elastic scattering crosssection.
                        <br>        
                    </ul>

                    <u><b> The <code>crosssection_lepton_nucleus_scattering</code> function: </b></u><br>

                    Used to calculate the crosssection for elastic lepton nucleus scattering for specific intial lepton energys and scattering angles based on a given nucleus. 

                    <pre><code class="python"> phr.crosssection_lepton_nucleus_scattering(energy,theta,nucleus,lepton_mass=0,recoil=True,subtractions=3,**args) </code></pre> 
                    <ul>
                        <li>
                        <b>energy</b> (<i>float</i>): energy of the (initial) lepton in MeV. 
                        <br>
                        <li>
                        <b>theta</b> (<i>float / 1d-array</i>): elastic scattering angle in rad (\(\theta=0\) forward direction, \(\theta=2\pi\) backward direction). 
                        <br>
                        <li>
                        <b>nucleus</b> (<i>nucleus object</i>): nucleus against which the lepton is scattered. 
                        <br>
                        <li>
                        <b>lepton_mass</b> (<i>float,optional</i>): mass of the lepton bound to the nucleus in MeV (default: 0). Can be set to 0 if energy \(\gg\) lepton_mass, which gives significant runtime improvements. No convergent implementation for non-zero lepton_mass yet. 
                        <br>
                        <li>
                        <b>recoil</b> (<i>bool,optional</i>): if recoil of the nucleus at leading (kinematic) order should be considered (default: True). 
                        <br>
                        <li>
                        <b>subtractions</b> (<i>int, optional</i>): number of subtractions to make the partial wave sum convergent (default: 3). subtractions=0 will not converge. 
                        subtractions=3 seems to work most consistently.  
                        <br>    
                        <li>
                        <b>**args</b> (<i>dict,optional</i>): Additional keywords can be used to pass parameters to the underlying numerical routines. 
                        The time-optimal parameters for a given dataset can be accessed by calling <code>optimise_crosssection_precision()</code> (see below). 
                        <br> 
                        <br> 
                        <li>
                        <b>return</b>: crosssection for elastic lepton nucleus scattering of the given nucleus at the given energy and angles in MeV\(^{-2}\) 
                        <br>
                    </ul>
                    
                    Possible **args/ parameters for the underlying numerical routines are:

                    <table>
                        <tr>
                            <th>Parameters/**args</th> <th></th>
                        </tr>
                        <tr>
                            <td><b>N_partial_waves</b> (<i>int,optional</i>):</td> <td> angular momenutum of the partial wave at which the series is terminated. (default: 100)</td>
                        </tr>
                        <tr>
                            <td><b>phase_difference_limit</b> (<i>float,optional</i>):</td> <td>limit at which (numerical) value for the <code>phase_difference</code> attribute of a <code>continuumstates</code> all following partial waves are considered indistinguishable to the coulomb solution. (default:0).</td>
                        </tr>
                        <tr>
                            <td><b>energy_norm</b> (<i>float,optional</i>):</td> <td> scaling factor for the units while solving the inital value problem to increase speed (default: \( \hbar c\) fm\(^{-1}\)) </td>
                        </tr>
                        <tr>
                            <td><b>method</b> (<i>str,optional</i>):</td> <td>method keyword passed to <code>scipy.integrate.solve_IVP</code> (default: 'DOP853' / as set in <code>default_continuumstate_settings</code>)</td>
                        </tr>
                        <tr>
                            <td><b>atol</b> (<i>float,optional</i>):</td> <td>atol keyword passed to <code>scipy.integrate.solve_IVP</code> (default: 1e-12 / as set in <code>default_continuumstate_settings</code>)</td>
                        </tr>
                        <tr>
                            <td><b>rtol</b> (<i>float,optional</i>):</td> <td>rtol keyword passed to <code>scipy.integrate.solve_IVP</code> (default: 1e-9 / as set in <code>default_continuumstate_settings</code>)</td>
                        </tr>
                    </table>
                    
                    <br>
                    If you want to call <code>crosssection_lepton_nucleus_scattering</code> many times for the same energies and angles theta for similar nuclei (for example for a fit), 
                    it makes sense to assess the necessary precision for the numerical calculation using <code>optimise_crosssection_precision</code>.  
                    This functions can run a few minutes as it is scanning a large **args / parameter space, but can afterwards improve the runtime significantly. 
                    Unfortunately the necessary precision is very dependent on how large the energy and angles are (larger energies and angles require significantly more precision and runtime), 
                    which is why this is the best solution for a reasonable runtime. Of course you can always also try to finetune the parameters yourself, but note that the convergence might break down, 
                    and that you should always check if the calculated crosssection is still reasonable. 

                    <pre><code class="python"> phr.optimise_crosssection_precision(energy,theta,nucleus,lepton_mass=0,recoil=True,subtractions=3,crosssection_precision=1e-3,jump_forward_dist=1) </code></pre> 
                    <ul>
                        <li>
                        <b>energy</b> (<i>float</i>): energy of the (initial) lepton in MeV. 
                        <br>
                        <li>
                        <b>theta</b> (<i>float / 1d-array</i>): elastic scattering angle in rad (\(\theta=0\) forward direction, \(\theta=2\pi\) backward direction). 
                        <br>
                        <li>
                        <b>nucleus</b> (<i>nucleus object</i>): nucleus against which the lepton is scattered. 
                        <br>
                        <li>
                        <b>lepton_mass</b> (<i>float,optional</i>): mass of the lepton bound to the nucleus in MeV (default: 0). Can be set to 0 if energy \(\gg\) lepton_mass, which gives significant runtime improvements. No convergent implementation for non-zero lepton_mass yet. 
                        <br> 
                        <br> 
                        <li>
                        <b>return</b>: args with the quickest runtime for <code>crosssection_lepton_nucleus_scattering</code> which are still consistent with crosssection calculations with the maximum precision up to a relative precision of the value of crosssection_precision. 
                        <br> 
                    </ul>

                </p>
                
                <u><b> The <code>left_right_asymmetry_lepton_nucleus_scattering</code> function: </b></u><br>

                    Used to calculate the left-right asymmetry based on the difference in the elastic lepton nucleus scattering crosssection between left and right handed electrons.
                    Most of the parameters are the same as for <code>crosssection_lepton_nucleus_scattering</code>. 
                    Requires a nucleus with a weak_potential, usually derived based on a weak_density. The nucleus for the charge interaction and the weak interaction may be choosen independenly. 

                    <pre><code class="python"> left_right_asymmetry_lepton_nucleus_scattering(energy,theta,weak_nucleus,charge_nucleus=None,**args) </code></pre> 
                    <ul>
                        <li>
                        <b>energy</b> (<i>float</i>): energy of the (initial) lepton in MeV. 
                        <br>
                        <li>
                        <b>theta</b> (<i>float / 1d-array</i>): elastic scattering angle in rad (\(\theta=0\) forward direction, \(\theta=2\pi\) backward direction). 
                        <br>
                        <li>
                        <b>weak_nucleus</b> (<i>nucleus object</i>): nucleus whose weak_potential should be used for the scattering. 
                        <br>
                        <li>
                        <b>charge_nucleus</b> (<i>nucleus object</i>): nucleus whose electric_potential should be used for the scattering (default: weak_nucleus). 
                        <br>
                        <li>
                        <b>**args</b> (<i>dict,optional</i>): passed to <code>crosssection_lepton_nucleus_scattering</code>. <code>atol</code> and <code>rtol</code> are defaulted to 1e-13 / maximum precision 
                        The time-optimal parameters for a given dataset can be accessed by calling <code>optimise_left_right_asymmetry_precision()</code> (see below). 
                        <br> 
                        <br> 
                        <li>
                        <b>return</b>: Normalized left-right asymmetry for elastic lepton nucleus scattering of the given nucleus at the given energy and angles 
                        <br>
                    </ul>

                    <br>
                    The optimiser for <code>left_right_asymmetry_lepton_nucleus_scattering</code> works analogously to the <code>optimise_crosssection_precision</code>, with usually even longer runtimes.                     

                    <pre><code class="python"> phr.optimise_left_right_asymmetry_precision(energy,theta,nucleus,left_right_asymmetry_precision=1e-3,jump_forward_dist=1,N_processes=1) </code></pre> 
                    <ul>
                        <li>
                        <b>energy</b> (<i>float</i>): energy of the (initial) lepton in MeV. 
                        <br>
                        <li>
                        <b>theta</b> (<i>float / 1d-array</i>): elastic scattering angle in rad (\(\theta=0\) forward direction, \(\theta=2\pi\) backward direction). 
                        <br>
                        <li>
                        <b>nucleus</b> (<i>nucleus object</i>): nucleus used for weak_nucleus and charge_nucleus for the scattering crosssection 
                        <br> 
                        <br> 
                        <li>
                        <b>return</b>: args with the quickest runtime for <code>left_right_asymmetry_lepton_nucleus_scattering</code> which are still consistent with left-right asymmetry calculations with the maximum precision up to a relative precision of the value of left_right_asymmetry_precision. 
                        <br> 
                    </ul>
                
                <h2 id="cross_section_fitter">The <code>cross_section_fitter</code> module</h2>
                    
                    <p>The <code>cross_section_fitter</code> module contains fitting routines to semi-automatically extract charge distrobutions including uncertainty bands from elestic electron nucleus scattering. For an example of how to employ these functions see <a href="#fit"> below </a> and the there discussed example notebook</p>


                <div class="divider" style="width:24%; margin:30px 0;"></div>
                
                <h1 id="advanced">Common use cases</h1>
                
                For common use cases we also refer to the two Python notebooks <a href="./examples.zip" download> examples.zip </a>. The basic use cases up until Version 0.4 are shown in <code>ExamplesBasic.ipynb</code>, which also repeats the examples shown here. 
                As of Version 0.5.0 another notebook <code>ExamplesFit.ipynb</code> with some auxilary files was added to show the usage of the fitting subroutines added in that update. See also the fit example shown <a href="#fit"> below </a>. 

                <h2 id="ana">Calculate the scattering crosssection based on an analytic charge densitycharge distribution parametrisation</h2>
                
                <p> To calculate the scattering cross section base on a analytic charge distribution parametrisation, you first construct the nucleus object, which you then use to calculate the cross section. 
                    As an example, we use a Fourier Bessel parameterisation for \(^{48}\)Ti with \( R = 9.25\) fm and
                    \[a_{1} = 0.03392 ~ \text{fm}^{-3}, ~
                     a_{2}=0.05913 ~ \text{fm}^{-3}, ~
                     a_{3}=0.01547 ~ \text{fm}^{-3}, ~
                     a_{4}=-0.02550 ~ \text{fm}^{-3}, \]
                    \[a_{5}=-0.0152 ~ \text{fm}^{-3}, ~
                    a_{6}=0.0029 ~ \text{fm}^{-3}, ~
                    a_{7}=0.0037 ~ \text{fm}^{-3}, \]
                    The nucleus is then constructed by
                <pre><code class="python">ai_48Ti=np.array([0.03392,0.05913,0.01547,-0.02550,-0.0152,0.0029,0.0037])
R_48Ti=9.25
nucleus_48Ti = phr.nucleus('48Ti_FB',Z=22,A=48,ai=ai_48Ti,R=R_48Ti)</code></pre>
                We give it the name '48Ti_FB', which ideally should be unique for this parameterisation, such that temporary files can be uniquely assigned. 
                If no temporary files are created or loaded during the calculation, the name should in principle not matter, but we advise the use of a unique name nevertheless, if alone for you personal bookkeeping. <br>
                We can now use this to calculate the crosssection. We consider an initial energy of 249.5 MeV and scattering angles between 30\(^{\circ}\) and 120\(^{\circ}\). The angles are defined such that 0\(^{\circ}\) refers to forward scattering and 180\(^{\circ}\) to backwards scattering. 
                We use the package matplotlib to plot the resulting cross section. 
                <pre><code class="python">import matplotlib.pyplot as plt
energy=249.5
theta=np.arange(30,120,1e-1)
plt.plot(theta,phr.crosssection_lepton_nucleus_scattering(energy,theta*pi/180,nucleus_48Ti),label=r'$E=249.5~$MeV')
plt.yscale('log')
plt.title(r"Cross section $^{48}$Ti")
plt.xlabel(r"$\theta$ in deg")
plt.ylabel(r"$\frac{\operatorname{d}\sigma}{\operatorname{d}\Omega}$ in MeV$^{-2}$")
plt.legend()
plt.xlim(30,120)</code></pre>
                This results in the following graphic: <br>
                <img src="./images/48Ti.png"> <br>
                Which you can now for example compare to data. Depending on your maschine this calculation might take a few seconds, which might be problematic if one wants to iterate over this process many times for example in a fit. 
                For this reason there is the option to optimise the precison of the numerical calculation for the specific nucleus, angle and energy range, to speed up the calculation. 
                Under the assumption that the nucleus does not change to drastically during the fit these settings can then be used to increase the runtime significantly, as expensive cases like high energies or very small or very large angles are excluded. 
                This assessment itself is however quite time intensive and may run several minutes, as it scans over a variety of different parameter combinations. We can run this funcions via
<pre><code class="python">args=phr.optimise_crosssection_precision(energy,theta*pi/180,nucleus_48Ti,crosssection_precision=1e-2)</code></pre>
                which in this case increases the runtime by roughtly a factor of 10x compared to maximal precision, by demanding consistency of at least relative \(10^{-2}\). Plotting now again (with the additional **args) 
                <pre><code class="python">import matplotlib.pyplot as plt
energy=249.5
theta=np.arange(30,120,1e-1)
plt.plot(theta,phr.crosssection_lepton_nucleus_scattering(energy,theta*pi/180,nucleus_48Ti,**args),label=r'$E=249.5~$MeV')
plt.yscale('log')
plt.title(r"Cross section $^{48}$Ti")
plt.xlabel(r"$\theta$ in deg")
plt.ylabel(r"$\frac{\operatorname{d}\sigma}{\operatorname{d}\Omega}$ in MeV$^{-2}$")
plt.legend()
plt.xlim(30,120)</code></pre>
                </p>
                is significantly faster, but leads to an indistinguishable cross section for these energy and angle values (up to relative differences of \(10^{-2}\)). 

                <h2 id="num">Calculate the scattering crosssection based on a numerical charge density parametrisation</h2>
                
                <p>
                Calculating the scattering crosssection for a numerical charge density is for the most part identical to the analytical part. 
                The only difference is that the nucleus object requires slighlty more preparation, as for example the nucleus potential needs to be calculated numerically. 
                Let's construct the same nucleus as in the analytical case as a numerical nucleus. We do

                <pre><code class="python">ai_48Ti=np.array([0.03392,0.05913,0.01547,-0.02550,-0.0152,0.0029,0.0037])
R_48Ti=9.25
N_48Ti=len(ai_48Ti)
qi_48Ti = np.arange(1,N_48Ti+1)*np.pi/R_48Ti
def rho_48Ti(r): return phr.nuclei.parameterizations.fourier_bessel.charge_density_FB(r,ai_48Ti,R_48Ti,qi_48Ti)
nucleus_48Ti_num = phr.nucleus('48Ti_num',Z=22,A=48,charge_density=rho_48Ti)</code></pre>
                which constructs the same charge density, but uses it as a generic (potentially numerical) input. This nucleus doe not have a nucleus potential yet. 
                As this requires two numerical integrations. We can tell the nucleus to do these calculations either expliticitly. By doing
                
                <pre><code class="python">nucleus_48Ti_num.set_electric_field_from_charge_density()
nucleus_48Ti_num.set_electric_potential_from_electric_field()</code></pre>
                or implicitly by calling 
                <pre><code class="python">nucleus_48Ti_num.fill_gaps()</code></pre>
                which will however calculate anything that is missing, in this case in particular also the form factor. In either way, if you used renew=False, which is the default, 
                the results will be saved in a file and loaded if you call these functions again. After this you can calculate the crosssection as for the analytical case 
                <pre><code class="python">energy=249.5
theta=np.arange(30,120,1e-1)
plt.plot(theta,phr.crosssection_lepton_nucleus_scattering(energy,theta*pi/180,nucleus_48Ti_num),label=r'$E=249.5~$MeV')
plt.yscale('log')
plt.title(r"Cross section $^{48}$Ti")
plt.xlabel(r"$\theta$ in deg")
plt.ylabel(r"$\frac{\operatorname{d}\sigma}{\operatorname{d}\Omega}$ in MeV$^{-2}$")
plt.legend()
plt.xlim(30,120)
plt.show()</code></pre>
                which will again lead to the same figure shown above, but will probably have a bit longer runtime. In case you want to fit over numerical charge densities, 
                you should set renew=True or iterate over the name of the nucleus such that the integrations for the electric field and electric potential are repeated with every change of the charge density. 
                As this is necessary, we however strongly discourage this strategy, as the extra integrations will increase the runtimes to unfeasable numbers (also since the integrations are not optimised for this usecase). 
                If you have a way of analytically calculating the nucleus potential from the charge density this should always be priotized. 
                If the parameterization you want to use is not implemented you can always also pass the electric_potential directly to the nucleus. 
                </p>

                <h2 id="PV">Calculate the left-right asymmetry for parity violating electron scattering</h2>
                  
                <p>We consider a toy example for \({}^{208}\)Pb from a paper from <a href="https://journals.aps.org/prc/abstract/10.1103/PhysRevC.57.3430"> [Horrowitz - 1998] </a>. 
                Here the weak density is considered to simply be the rescaled charge distribution with one additonal parameter to adjust the radius, according to
                \[ \rho^\lambda_\operatorname{w}(r) = \frac{Q_\operatorname{w}}{Z} \lambda^3 \rho_\operatorname{ch}(\lambda r)  \] 
                As the charge distribution he uses a 3pF parameterisation with \(c=6.4\), \(z=0.54\), \(w=0.32\) and for the rescaling \(\lambda=0.9502\). 
                We may define a nucleus with these properties via 
                <pre><code class="python">nucleus_Pb208 = phr.nucleus('Pb208_Hor98_095',Z=82,A=208,c=6.4,z=0.54,w=0.32)
def weak_density_model(r,lam,nucleus): return (nucleus.Qw/nucleus.Z)*lam**3*nucleus.charge_density(lam*r)
nucleus_Pb208.weak_density = partial(weak_density_model,lam=0.9502,nucleus=Pb208_test)
nucleus_Pb208.update_dependencies()
nucleus_Pb208.fill_gaps()</code></pre>  
                This code will construct the nucleus with a 3pF parameterization for the charge density and then add a weak density as described. 
                The function <code>update_dependencies()</code> is run such that intermediate derivatives of <code>weak_density</code> like <code>weak_potential</code> are constructed. 
                Then <code>fill_gaps()</code> is run to calculate quantities than require explizit calculations like <code>weak_radius</code>. For the Fermi parameterizations this is also necessary to calculate related quantities to the <code>charge_density</code> like <code>electric_potential</code>. <br>
                <br>
                Now we can calculate the left-right asymmetry at \(E=850 \operatorname{MeV}\) and \(\theta=[1^\circ,50^\circ] \) for this nucleus by running
                <pre><code class="python">theta_deg=np.arange(1,50,1e-1)
E_MeV=850
A_PV_208Pb = phr.left_right_asymmetry_lepton_nucleus_scattering(E_MeV,theta_deg*pi/180,nucleus_Pb208,verbose=True)</code></pre> 
                </p>
                We may plot the results 
                <pre><code class="python">import matplotlib.pyplot as plt
plt.title(r'PVES $^{208}$Pb') #Horowitz 1998
plt.plot(theta_deg,A_PV_208Pb,label=r'$\lambda=0.9502$')
plt.ylim(0,4e-6)
plt.xlim(0,15)
plt.xlabel(r"$\theta$ in deg")
plt.ylabel(r"left-right asymmetry")
plt.legend()
plt.show()</code></pre>
                resulting in the following graphic: <br>
                <img src="./images/208Pb.png"> <br>
                which is consistent with the results from the original reference. Good parameters to improve the runtime can be found analogously to the crosssection case with <code>optimise_left_right_asymmetry_precision</code>, which might take very long to run due to the increased runtime. 

                <h2 id="fit">Fit a charge distribution to cross section data</h2>
                  
                <p> Using the the <code>cross_section_fitter</code> module to extract Fourier Bessel charge distributions from elastic electron nucleus scattering requires several steps, which require external supervison and decisions along the way. 
                    We follow the fitting strategie as described in <a href="https://inspirehep.net/literature/2796887"> [Noël, Hoferichter - 2024] </a>. 
                    For the sake of this example we may seperate the fitting strategie into the following steps, which will be discussed in the following. 
                <ol>
                    <li> Import and transformation of the experimental data (<code>phr.import_dataset</code>) </li>
                    <li> Baseline fits eastablishing \(R, N\) range (<code>phr.parallel_fitting_automatic</code>) </li>
                    <li> Selection of \(R, N\) range based on statistic properties (<code>phr.cross_section_fitter.select_RN_based_on_property</code>) </li>
                    <li> Fits for the selected \(R, N\) range (<code>phr.parallel_fitting_manual</code>) </li>
                    <li> Selection of asymptotic conform results (<code>phr.cross_section_fitter.split_based_on_asymptotic_and_p_val</code>) </li>
                    <li> Select/Promote a best fit and construct systematic uncertainty bands based on the other remaining solutions (<code>phr.cross_section_fitter.promote_best_fit</code>) </li>
                </ol> 
                For the example discussed here you may also follow the <code>ExamplesFit.ipynb</code> notebook. Note that if you download the zip-archive all fits are already part of the archive, thus if you actually want to rerun any fits (which could be time intensive), you need to delete the respective files in the tmp folder. 
                </p>

                <u><p><b> Import and transformation of the experimental data </b></u><br>
                We consider having a file with rows of different data points where the columns contain inputs on the initial electron energy, the scattering angle and the measured elastic scattering crosssection ideally also containing columns for uncertainties.
                We may then import and transform this data by running <code>phr.import_dataset</code> and answering the appearing questions, which will transform the data into the structure and units expected from the fitting routine.<br> 
                For the sake of this example we may consider a dataset for \(^{40}\)Ar from <a href="https://www.sciencedirect.com/science/article/abs/pii/0375947482900045?via%3Dihub"> [Ottermann et al. - 1982] </a>, whos data we have written down in a file <code>Ottermann1982_Ar40.txt</code>. 
                We may load this dataset now with the intend of using it for a fit by calling (assuming that the file is in the same folder)
                <pre><code class="python">path_Ar40_Ot82 = "../Ottermann1982_Ar40.txt"
phr.import_dataset(path_Ar40_Ot82,"Ottermann1982",Z=18,A=40)</code></pre>
                and following und answering the questions presented to you, which will walk you through providing the necessary information such that the data can be interpreted correctly. 
                For this example the questions should be answered in the following way: 
                <pre>What column (starting at 0) contains the central values for the energie? 0
In what units is the energy (MeV or GeV)? MeV
What column (starting at 0) contains the central values for the angles? 1
In what units is the angle theta (deg or rad)? deg
Does the file contain direct cross sections or relative measurements to a different nucleus? (answer with: direct or relative) direct
What column (starting at 0) contains the central values for the cross section? 2
In what units is the cross section (fmsq, cmsq, mub, mb or invMeVsq)? fmsq
Does the data distinguish between statistical and systematical uncertainties? (y or n) y
What columns (starting at 0), if any, contain statistical uncertainties for the cross sections (separate by comma)? 3
Are the statistical uncertainties absolute values or relative to the central value? (answer with: absolute or relative) relative
Are the relative statistical uncertainties in percent and thus need to divided by 100? (y or n) y
What columns (starting at 0), if any, contain systematical uncertainties for the cross sections (separate by comma)? 4
Are the systematical uncertainties absolute values or relative to the central value? (answer with: absolute or relative) relative
Are the relative systematical uncertainties in percent and thus need to divided by 100? (y or n) y
Do you want to add a global relative statistical uncertainty w.r.t. the cross section as an (additional) uncertainty component? (For 3% insert 3, type 0 if you do not want to do so)? 0
Do you want to add a global relative systematical uncertainty w.r.t. the cross section as an (additional) uncertainty component? (For 3% insert 3, type 0 if you do not want to do so)? 0.8</pre>
                If you feel like you entered something wrong, you can always rerun this function, which will overwrite the existing prepared data. 
                After this step the fitting routines can now identify this dataset by the unique label of "Ottermann1982" and the correct \(Z, A\). 
                We can list all imported datasets for a given \(Z, A\) by calling <code>phr.cross_section_fitter.list_datasets(Z,A)</code>
                One may provide correlation matrices for statitistical and systematical uncertainties as additional arguments in the <code>import_dataset</code> function. 
                If these are not set, statistical uncertainties are considered completely uncorrelated and systematical uncertainties 100% correlated (considing they are in associaton with / dominated by normalisation uncertainties). <br>
                One may also import Barrett moments using the function <code>phr.cross_section_fitter.import_barrett_moment</code>, where the parameters and values are simply directly supplied (radii constrains can be considered as a special case of a barrett moment with \(k=2,\alpha=0\)). 
                </p>

                <u><p><b> Baseline fits </b></u><br>
                We may run baseline fits over a range of \(R,N\) to establish a minimum \(N\) for a given \(R\) range. We call for this <code>phr.parallel_fitting_automatic</code>. This function will derive how many \(N\) are covered by the exerimental data for a specific \(R\). 
                Then centered around this central value for \(N\) closeby values for \(N\) are choosen for the \(R,N\) pairs that should the fit should run for. 
                After the fits are run one should check if the lower borders of validity in \(R,N\) are sufficiently established or otherwise increase the range in \(R\) and/or \(N\). 
                Initial values for the fits are either taken from older fits with the same parameters, or from reference charge distributions from <a href="https://www.sciencedirect.com/science/article/abs/pii/0092640X87900131?via%3Dihub"> [De Vries et al. - 1987] </a> (which can be accessed via <code>phr.nuclei.load_reference_nucleus</code>). 
                Before running all these fits it might make sense to establish the necessary precision for the cross section calculation to minimze runtime by running <code>phr.optimise_crosssection_precision</code> for the considered data points and a typical charge distribution as described above. 
                The call may then look like:
                <pre><code class="python">args_optimised =  {'method': 'DOP853', 'N_partial_waves': 25, 'atol': 1e-08, 'rtol': 1e-06, 'energy_norm': 0.001973269804, 'phase_difference_limit': 1e-06}
results_dict = phr.cross_section_fitter.fit_organizer.parallel_fitting_automatic(['Ottermann1982'],18,40,np.arange(4.00,8.75+0.25,0.25),redo_N=True,redo_aggressive=True,N_base_offset=1,N_base_span=3,cross_section_args=args_optimised)</code></pre>  
                This function will now run up to 5 different values of \(N\) fits per \(R\) with \(R\) in a range from 4.00fm to 8.75fm in steps of 0.25fm, resulting in a total of 102 fits. 
                These fits will be run in parallel and distributed over different processes based on the number of cores available on the maschine minus two (or if you set the keyword <code>N_processes</code> manually). 
                It makes sense to run this on a fast maschine with a lot of cores. It might still take between minutes to hours up to days to complete all fits, dependent on the used maschine and considered nucleus and datasets. Completed fits are saved and simply loaded if the function is run again with the same parameters and starting conditions. 
                The resulting <code>results_dict</code> is now a dictionary containing all fit results, from fitting against the 'Ottermann1982' dataset. Since we activated <code>redo_N</code> and <code>redo_aggressive</code>, after a first pass, individual fits were redone if any other fit result with the same \(R\) but smaller \(N\) had a better loss function, indicating that the fit did not find the best minimum yet. 
                </p>

                <u><p><b> Selection of \(R, N\) </b></u><br>

                We want to select a range of \(R, N\) with good statistics. We may generate 2d-arrays in \(R, N\) to study the statistical properties and if the studied range in \(R, N\) is sufficient. 
                We use the function <code>phr.cross_section_fitter.generate_data_tables</code> to prepare tables for different statistical properties. The <code>pandas</code> package is a good way to illustrate these 2d-arrays as tables in a jupyther notebook (you need to have this packege installed for this to work). 
                <pre><code class="python">import pandas as pd
database_tables, Rs, Ns, hist = phr.cross_section_fitter.generate_data_tables(results_dict)
pd.DataFrame(database_tables['p_val'],index=Rs,columns=Ns)</code></pre>  
                which shows a table with all the p values for all the fits. Other keywords are for example 'chisq' or 'redchisq' for \(\chi^2\) or the \(\chi^2/\text{d.o.f}\) respectively. 
                You may plot a histogramm of the distribution of the statistical quantities (using the <code>matplotlib</code> package) via. Here you may choose to plot it like this
                <pre><code class="python">import matplotlib.pyplot as plt
plt.title('fit distribution')
plt.xlabel(r'$p_{val}$')
plt.plot([0.2,0.2],[0,42],color='red',linestyle='--')
plt.ylim(0,42)
plt.xlim(0,0.7)
plt.hist(hist['p_val'],10)
plt.show()</code></pre>
                which results in the following graphic:<br>
                <img src="./images/p_val_dist_base.png"> <br>
                There will usually be a structure of one peak to the right containing fits that "work", and a collection very close to zero with fits that do not "work". One may study the distribution a bit more by adjusting the number of bins. 
                Based on this ditribution one may choose a cutoff criterium. In our case we choose a p value of 0.2 as the cutoff (denoted by the red dashed line). We can select all \(R, N\) pairs whoes fits have a p value greater than 0.2 via 
<pre><code class="python">selected_RN_tuples = phr.cross_section_fitter.fit_organizer.select_RN_based_on_property(results_dict,'p_val',0.2)</code></pre></p>
                
                <u><p><b> Final fits for our selection of \(R, N\) </b></u><br>

                We now perform the actual fits we want to use for our analysis. Here we only fit in the established window of values for \(R, N\) using the previous fit results as initial values. Here we also may now turn on additional constraints. <br>
                One additional contraint that we usually want to enable is a penalty on oscillations for large \(R\). A typical weight for this is <code>monotonous_decrease_precision=0.04</code>, in accordance with typical uncertainties on radii squared. 
                But if one has the computing resources one may play around with different values for this. <br>
                Other constraints are from Barrett moments (or radii squared as a special case), where we usually study fitting with or without them. These are included as an additional constraint in the same way as the datasets by listing keys of previously importet values. <br>
                A fit including barrett moments may look like 
                <pre><code class="python">ini_settings = {'datasets':['Ottermann1982'],'datasets_barrett_moment':[],'monotonous_decrease_precision':np.inf}
results_dict_bar = phr.cross_section_fitter.fit_organizer.parallel_fitting_manual(['Ottermann1982'],18,40,selected_RN_tuples,redo_N=True,monotonous_decrease_precision=0.04,barrett_moment_keys=['Fricke1995_2p'],initialize_from=ini_settings,cross_section_args=args_optimised)</code></pre>
                </p>

                <u><p><b> Selection of asymptotic confrom results </b></u><br>

                We can again study the statistical quantities of our fit results with the same tools as the baseline fits and find based on the histogram that a p value of 0.3 is a good cutoff. <br>
                <img src="./images/p_val_dist_bar.png"> <br>
                We further veto all fits with bad asymptotic behaviour. For this we define three areas in \(q\) to match an upper limit for the asymptotic. 
                Ideally if the fits clearly contrains several minima in the form factor these regions should be seperated by the last clearly defined minimas, such that it matches onto the maximum values in the last two clearly defined areas. 
                We have a minimum falloff with \(q^{-4}\) which will jump in for our example case, since the data does not cover sufficent range in \(q\). We can study the resulting form factors and then choose
                <pre><code class="python">qs=[50,235,370,600]
results_dict_bar_sel, results_dict_bar_veto, veto_fct = phr.cross_section_fitter.fit_organizer.split_based_on_asymptotic_and_p_val(results_dict_bar,qs=qs,p_val_lim=0.3)</code></pre>
                The <code>results_dict_bar_sel</code> dictionary now contains all fits we consider reasonable in describing the provided data without overparametrizating. The condition on the asymptotic should set an implicit upper limit on \(N\) for each \(R\). If this limit is not saturated yet, one might want to take a step back and extend the basefits to higher \(N\).  
                </p>

                <u><p><b> Select/Promote best fit and add systemetic uncertainty bands </b></u><br>
                One may now choose the best fit within the remaining sample usually by considering the fit with the best reduced \(\chi^2\). One way to select this could be to run
                <pre><code class="python">best_key_bar = None
best_p_val = 0
for key in results_dict_bar_sel:
p_val = results_dict_bar_sel[key]['p_val']
    if p_val > best_p_val:
        best_p_val = p_val
        best_key_bar = key</code></pre>
                after which <code>best_key_bar, best_p_val</code> contain the best p value and its corresponding dictionary key. We can now promote this fit to beeing the reference parameterization for this kind of nucleus, by calling
                <pre><code class="python">phr.cross_section_fitter.promote_best_fit(best_key_bar,results_dict_bar_sel)</code></pre>
                this will also call <code>phr.cross_section_fitter.add_systematic_uncertainties</code> to construct systematic uncertainty bands as an envelope around the selection of fits. Alternatively we can do this manually by calling
                <pre><code class="python">best_results_dict_bar = phr.cross_section_fitter.add_systematic_uncertainties(best_key_bar,results_dict_bar_sel)</code></pre>
                We can now plot the resulting charge distribution and the uncertainty bands via 
                <pre><code class="python">best_nuc_result = phr.nucleus('Ar40_FB_best_test',18,40,ai=best_results_dict_bar['ai'],R=best_results_dict_bar['R'])
best_cov_ai_model = best_results_dict_bar['cov_ai_model']
best_cov_ai_stat = best_results_dict_bar['cov_ai_stat'] * np.sqrt(best_results_dict_bar['redchisq'])
best_cov_ai_syst = best_results_dict_bar['cov_ai_syst']

r = np.arange(0,15,1e-2)
best_rho = best_nuc_result.charge_density(r)
plt.plot(r,best_rho,color='C0',zorder=2,label='best fit')
best_jac_rho = best_nuc_result.charge_density_jacobian(r)
best_drho_model = np.sqrt(np.einsum('ij,ik,kj->j',best_jac_rho,best_cov_ai_model,best_jac_rho))
best_drho_stat = np.sqrt(np.einsum('ij,ik,kj->j',best_jac_rho,best_cov_ai_stat,best_jac_rho))
best_drho_syst = np.sqrt(np.einsum('ij,ik,kj->j',best_jac_rho,best_cov_ai_syst,best_jac_rho))
plt.plot(r,best_rho+best_drho_stat,color='C0',linestyle=':',zorder=1,label='stat. error')
plt.plot(r,best_rho-best_drho_stat,color='C0',linestyle=':',zorder=1)
plt.plot(r,best_rho+best_drho_syst,color='C0',linestyle='--',zorder=1,label='syst. error')
plt.plot(r,best_rho-best_drho_syst,color='C0',linestyle='--',zorder=1)
for key in results_dict_bar_sel:
    result=results_dict_bar_sel[key]
    nuc_result = phr.nucleus('Ar40_FB_test_'+key,18,40,ai=result['ai'],R=result['R'])
    plt.plot(r,nuc_result.charge_density(r),color='gray',zorder=-2) #,label=key
plt.xlim(0,8.5)
plt.ylim(0,0.11)
plt.legend()
plt.title('$^{40}$Ar')
plt.xlabel('$r$ in fm')
plt.ylabel(r'$\rho$ in fm$^{-3}$')</code></pre>
                which results in the following graphic<br>
                <img src="./images/40Ar.png"> <br>
                We see that in this case we find very large systematic uncertainties. This is not necessarily the case, but a result of the only very low momentum transfer covered by the experimental data. We note that the statistical uncertainties are reduced \(\chi^2\) inflated (in particular this also happens as part of the derivation of the combined 'model' errors). 
                </p>


                <h1>More Info</h1>

                <p> The package is currently in an development stage, and partly incomplete. 
                    Use the package at your own risk and without any garanties. <br>
                    This package was written by Frederic Noël. 
                    I would like to thank my collaborators and office mates for meaningfull inputs. This website was build based on a template from github user charlyllo.</p>

                <div class="doublespace"></div>
                <div class="divider" style="width:24%; margin:30px 0;"></div>

            </div>

        </div>


    </div>

<script>hljs.highlightAll();</script>

</body>
</html>
<!--Based on template from charlyllo-->
