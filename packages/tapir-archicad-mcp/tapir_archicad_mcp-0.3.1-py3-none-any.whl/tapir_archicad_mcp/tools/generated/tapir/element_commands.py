# This file is auto-generated by generate_tools.py. DO NOT EDIT.
import logging
from pydantic import ValidationError
from multiconn_archicad.basic_types import Port
from tapir_archicad_mcp.context import multi_conn_instance
from tapir_archicad_mcp.tools.tool_registry import register_tool_for_dispatch
import time
from typing import Any
from tapir_archicad_mcp.pagination import handle_paginated_request, PAGINATION_CACHE, CACHE_LIFETIME_SECONDS

from multiconn_archicad.models.tapir.commands import (
    ChangeSelectionOfElementsParameters,
ChangeSelectionOfElementsResult,
CreateColumnsParameters,
CreateColumnsResult,
CreateMeshesParameters,
CreateMeshesResult,
CreateObjectsParameters,
CreateObjectsResult,
CreatePolylinesParameters,
CreatePolylinesResult,
CreateSlabsParameters,
CreateSlabsResult,
CreateZonesParameters,
CreateZonesResult,
DeleteElementsParameters,
FilterElementsParameters,
FilterElementsResult,
Get3DBoundingBoxesParameters,
Get3DBoundingBoxesResult,
GetAllElementsParameters,
GetAllElementsResult,
GetClassificationsOfElementsParameters,
GetClassificationsOfElementsResult,
GetCollisionsParameters,
GetCollisionsResult,
GetConnectedElementsParameters,
GetConnectedElementsResult,
GetDetailsOfElementsParameters,
GetDetailsOfElementsResult,
GetElementsByTypeParameters,
GetElementsByTypeResult,
GetGDLParametersOfElementsParameters,
GetGDLParametersOfElementsResult,
GetSelectedElementsResult,
GetSubelementsOfHierarchicalElementsParameters,
GetSubelementsOfHierarchicalElementsResult,
GetZoneBoundariesParameters,
GetZoneBoundariesResult,
HighlightElementsParameters,
MoveElementsParameters,
MoveElementsResult,
SetClassificationsOfElementsParameters,
SetClassificationsOfElementsResult,
SetDetailsOfElementsParameters,
SetDetailsOfElementsResult,
SetGDLParametersOfElementsParameters,
SetGDLParametersOfElementsResult
)


log = logging.getLogger()

def change_selection_of_elements(port: int, params: ChangeSelectionOfElementsParameters) -> ChangeSelectionOfElementsResult:
    """
    Adds/removes a number of elements to/from the current selection.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="ChangeSelectionOfElements",
            parameters=params.model_dump(mode='json')
        )
        return ChangeSelectionOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for ChangeSelectionOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing ChangeSelectionOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    change_selection_of_elements,
    name="elements_change_selection_of_elements",
    title="ChangeSelectionOfElements",
    description="Adds/removes a number of elements to/from the current selection.",
    params_model=ChangeSelectionOfElementsParameters,
    result_model=ChangeSelectionOfElementsResult
)


def create_columns(port: int, params: CreateColumnsParameters) -> CreateColumnsResult:
    """
    Creates Column elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateColumns",
            parameters=params.model_dump(mode='json')
        )
        return CreateColumnsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateColumns result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateColumns on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_columns,
    name="elements_create_columns",
    title="CreateColumns",
    description="Creates Column elements based on the given parameters.",
    params_model=CreateColumnsParameters,
    result_model=CreateColumnsResult
)


def create_meshes(port: int, params: CreateMeshesParameters) -> CreateMeshesResult:
    """
    Creates Mesh elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateMeshes",
            parameters=params.model_dump(mode='json')
        )
        return CreateMeshesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateMeshes result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateMeshes on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_meshes,
    name="elements_create_meshes",
    title="CreateMeshes",
    description="Creates Mesh elements based on the given parameters.",
    params_model=CreateMeshesParameters,
    result_model=CreateMeshesResult
)


def create_objects(port: int, params: CreateObjectsParameters) -> CreateObjectsResult:
    """
    Creates Object elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateObjects",
            parameters=params.model_dump(mode='json')
        )
        return CreateObjectsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateObjects result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateObjects on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_objects,
    name="elements_create_objects",
    title="CreateObjects",
    description="Creates Object elements based on the given parameters.",
    params_model=CreateObjectsParameters,
    result_model=CreateObjectsResult
)


def create_polylines(port: int, params: CreatePolylinesParameters) -> CreatePolylinesResult:
    """
    Creates Polyline elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreatePolylines",
            parameters=params.model_dump(mode='json')
        )
        return CreatePolylinesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreatePolylines result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreatePolylines on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_polylines,
    name="elements_create_polylines",
    title="CreatePolylines",
    description="Creates Polyline elements based on the given parameters.",
    params_model=CreatePolylinesParameters,
    result_model=CreatePolylinesResult
)


def create_slabs(port: int, params: CreateSlabsParameters) -> CreateSlabsResult:
    """
    Creates Slab elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateSlabs",
            parameters=params.model_dump(mode='json')
        )
        return CreateSlabsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateSlabs result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateSlabs on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_slabs,
    name="elements_create_slabs",
    title="CreateSlabs",
    description="Creates Slab elements based on the given parameters.",
    params_model=CreateSlabsParameters,
    result_model=CreateSlabsResult
)


def create_zones(port: int, params: CreateZonesParameters) -> CreateZonesResult:
    """
    Creates Zone elements based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateZones",
            parameters=params.model_dump(mode='json')
        )
        return CreateZonesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateZones result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateZones on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_zones,
    name="elements_create_zones",
    title="CreateZones",
    description="Creates Zone elements based on the given parameters.",
    params_model=CreateZonesParameters,
    result_model=CreateZonesResult
)


def delete_elements(port: int, params: DeleteElementsParameters) -> None:
    """
    Deletes elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        conn_header.core.post_tapir_command(
            command="DeleteElements",
            parameters=params.model_dump(mode='json')
        )
        return None

    except ValidationError as e:
        log.error(f"Validation error for DeleteElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing DeleteElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    delete_elements,
    name="elements_delete_elements",
    title="DeleteElements",
    description="Deletes elements.",
    params_model=DeleteElementsParameters,
    result_model=None
)


def filter_elements(port: int, params: FilterElementsParameters) -> FilterElementsResult:
    """
    Tests an elements by the given criterias.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="FilterElements",
            parameters=params.model_dump(mode='json')
        )
        return FilterElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for FilterElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing FilterElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    filter_elements,
    name="elements_filter_elements",
    title="FilterElements",
    description="Tests an elements by the given criterias.",
    params_model=FilterElementsParameters,
    result_model=FilterElementsResult
)


def get3_d_bounding_boxes(port: int, params: Get3DBoundingBoxesParameters) -> Get3DBoundingBoxesResult:
    """
    Get the 3D bounding box of elements. The bounding box is calculated from the global origin in the 3D view. The output is the array of the bounding boxes respective to the input array of elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="Get3DBoundingBoxes",
            parameters=params.model_dump(mode='json')
        )
        return Get3DBoundingBoxesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for Get3DBoundingBoxes result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing Get3DBoundingBoxes on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get3_d_bounding_boxes,
    name="elements_get3_d_bounding_boxes",
    title="Get3DBoundingBoxes",
    description="Get the 3D bounding box of elements. The bounding box is calculated from the global origin in the 3D view. The output is the array of the bounding boxes respective to the input array of elements.",
    params_model=Get3DBoundingBoxesParameters,
    result_model=Get3DBoundingBoxesResult
)


class PaginatedGetAllElementsResult(GetAllElementsResult):
    """A paginated version of the GetAllElementsResult."""
    elements: list[Any]
    next_page_token: str | None = None


def get_all_elements(port: int, params: GetAllElementsParameters, page_token: str | None = None) -> PaginatedGetAllElementsResult:
    """
    Returns the identifier of all elements on the plan. Use the optional filter parameter for filtering.
        This response is paginated. If 'next_page_token' is returned, call this function
        again with that token to get the next page of results.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        cache_key = f"{port}:GetAllElements:{params.model_dump_json()}"

        if not page_token:
            full_response_dict = conn_header.core.post_tapir_command(
                command="GetAllElements",
                parameters=params.model_dump(mode='json')
            )
            full_response_model = GetAllElementsResult.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "elements")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["elements"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return PaginatedGetAllElementsResult.model_validate(response_data)

    except ValidationError as e:
        log.error(f"Validation error for GetAllElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetAllElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_all_elements,
    name="elements_get_all_elements",
    title="GetAllElements",
    description="Returns the identifier of all elements on the plan. Use the optional filter parameter for filtering.",
    params_model=GetAllElementsParameters,
    result_model=PaginatedGetAllElementsResult
)


def get_classifications_of_elements(port: int, params: GetClassificationsOfElementsParameters) -> GetClassificationsOfElementsResult:
    """
    Returns the classification of the given elements in the given classification systems. It works for subelements of hierarchal elements also.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetClassificationsOfElements",
            parameters=params.model_dump(mode='json')
        )
        return GetClassificationsOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetClassificationsOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetClassificationsOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_classifications_of_elements,
    name="elements_get_classifications_of_elements",
    title="GetClassificationsOfElements",
    description="Returns the classification of the given elements in the given classification systems. It works for subelements of hierarchal elements also.",
    params_model=GetClassificationsOfElementsParameters,
    result_model=GetClassificationsOfElementsResult
)


def get_collisions(port: int, params: GetCollisionsParameters) -> GetCollisionsResult:
    """
    Detect collisions between the given two groups of elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetCollisions",
            parameters=params.model_dump(mode='json')
        )
        return GetCollisionsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetCollisions result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetCollisions on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_collisions,
    name="elements_get_collisions",
    title="GetCollisions",
    description="Detect collisions between the given two groups of elements.",
    params_model=GetCollisionsParameters,
    result_model=GetCollisionsResult
)


def get_connected_elements(port: int, params: GetConnectedElementsParameters) -> GetConnectedElementsResult:
    """
    Gets connected elements of the given elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetConnectedElements",
            parameters=params.model_dump(mode='json')
        )
        return GetConnectedElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetConnectedElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetConnectedElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_connected_elements,
    name="elements_get_connected_elements",
    title="GetConnectedElements",
    description="Gets connected elements of the given elements.",
    params_model=GetConnectedElementsParameters,
    result_model=GetConnectedElementsResult
)


def get_details_of_elements(port: int, params: GetDetailsOfElementsParameters) -> GetDetailsOfElementsResult:
    """
    Gets the details of the given elements (geometry parameters etc).
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetDetailsOfElements",
            parameters=params.model_dump(mode='json')
        )
        return GetDetailsOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetDetailsOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetDetailsOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_details_of_elements,
    name="elements_get_details_of_elements",
    title="GetDetailsOfElements",
    description="Gets the details of the given elements (geometry parameters etc).",
    params_model=GetDetailsOfElementsParameters,
    result_model=GetDetailsOfElementsResult
)


class PaginatedGetElementsByTypeResult(GetElementsByTypeResult):
    """A paginated version of the GetElementsByTypeResult."""
    elements: list[Any]
    next_page_token: str | None = None


def get_elements_by_type(port: int, params: GetElementsByTypeParameters, page_token: str | None = None) -> PaginatedGetElementsByTypeResult:
    """
    Returns the identifier of every element of the given type on the plan. It works for any type. Use the optional filter parameter for filtering.
        This response is paginated. If 'next_page_token' is returned, call this function
        again with that token to get the next page of results.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        cache_key = f"{port}:GetElementsByType:{params.model_dump_json()}"

        if not page_token:
            full_response_dict = conn_header.core.post_tapir_command(
                command="GetElementsByType",
                parameters=params.model_dump(mode='json')
            )
            full_response_model = GetElementsByTypeResult.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "elements")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["elements"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return PaginatedGetElementsByTypeResult.model_validate(response_data)

    except ValidationError as e:
        log.error(f"Validation error for GetElementsByType result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetElementsByType on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_elements_by_type,
    name="elements_get_elements_by_type",
    title="GetElementsByType",
    description="Returns the identifier of every element of the given type on the plan. It works for any type. Use the optional filter parameter for filtering.",
    params_model=GetElementsByTypeParameters,
    result_model=PaginatedGetElementsByTypeResult
)


def get_gdl_parameters_of_elements(port: int, params: GetGDLParametersOfElementsParameters) -> GetGDLParametersOfElementsResult:
    """
    Gets all the GDL parameters (name, type, value) of the given elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetGDLParametersOfElements",
            parameters=params.model_dump(mode='json')
        )
        return GetGDLParametersOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetGDLParametersOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetGDLParametersOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_gdl_parameters_of_elements,
    name="elements_get_gdl_parameters_of_elements",
    title="GetGDLParametersOfElements",
    description="Gets all the GDL parameters (name, type, value) of the given elements.",
    params_model=GetGDLParametersOfElementsParameters,
    result_model=GetGDLParametersOfElementsResult
)


class PaginatedGetSelectedElementsResult(GetSelectedElementsResult):
    """A paginated version of the GetSelectedElementsResult."""
    elements: list[Any]
    next_page_token: str | None = None


def get_selected_elements(port: int, page_token: str | None = None) -> PaginatedGetSelectedElementsResult:
    """
    Gets the list of the currently selected elements.
        This response is paginated. If 'next_page_token' is returned, call this function
        again with that token to get the next page of results.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        cache_key = f"{port}:GetSelectedElements"

        if not page_token:
            full_response_dict = conn_header.core.post_tapir_command(
                command="GetSelectedElements",
                parameters={}
            )
            full_response_model = GetSelectedElementsResult.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "elements")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["elements"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return PaginatedGetSelectedElementsResult.model_validate(response_data)

    except ValidationError as e:
        log.error(f"Validation error for GetSelectedElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetSelectedElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_selected_elements,
    name="elements_get_selected_elements",
    title="GetSelectedElements",
    description="Gets the list of the currently selected elements.",
    params_model=None,
    result_model=PaginatedGetSelectedElementsResult
)


def get_subelements_of_hierarchical_elements(port: int, params: GetSubelementsOfHierarchicalElementsParameters) -> GetSubelementsOfHierarchicalElementsResult:
    """
    Gets the subelements of the given hierarchical elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetSubelementsOfHierarchicalElements",
            parameters=params.model_dump(mode='json')
        )
        return GetSubelementsOfHierarchicalElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetSubelementsOfHierarchicalElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetSubelementsOfHierarchicalElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_subelements_of_hierarchical_elements,
    name="elements_get_subelements_of_hierarchical_elements",
    title="GetSubelementsOfHierarchicalElements",
    description="Gets the subelements of the given hierarchical elements.",
    params_model=GetSubelementsOfHierarchicalElementsParameters,
    result_model=GetSubelementsOfHierarchicalElementsResult
)


def get_zone_boundaries(port: int, params: GetZoneBoundariesParameters) -> GetZoneBoundariesResult:
    """
    Gets the boundaries of the given Zone (connected elements, neighbour zones, etc.).
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetZoneBoundaries",
            parameters=params.model_dump(mode='json')
        )
        return GetZoneBoundariesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetZoneBoundaries result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetZoneBoundaries on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_zone_boundaries,
    name="elements_get_zone_boundaries",
    title="GetZoneBoundaries",
    description="Gets the boundaries of the given Zone (connected elements, neighbour zones, etc.).",
    params_model=GetZoneBoundariesParameters,
    result_model=GetZoneBoundariesResult
)


def highlight_elements(port: int, params: HighlightElementsParameters) -> None:
    """
    Highlights the elements given in the elements array. In case of empty elements array removes all previously set highlights.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        conn_header.core.post_tapir_command(
            command="HighlightElements",
            parameters=params.model_dump(mode='json')
        )
        return None

    except ValidationError as e:
        log.error(f"Validation error for HighlightElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing HighlightElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    highlight_elements,
    name="elements_highlight_elements",
    title="HighlightElements",
    description="Highlights the elements given in the elements array. In case of empty elements array removes all previously set highlights.",
    params_model=HighlightElementsParameters,
    result_model=None
)


def move_elements(port: int, params: MoveElementsParameters) -> MoveElementsResult:
    """
    Moves elements with a given vector.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="MoveElements",
            parameters=params.model_dump(mode='json')
        )
        return MoveElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for MoveElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing MoveElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    move_elements,
    name="elements_move_elements",
    title="MoveElements",
    description="Moves elements with a given vector.",
    params_model=MoveElementsParameters,
    result_model=MoveElementsResult
)


def set_classifications_of_elements(port: int, params: SetClassificationsOfElementsParameters) -> SetClassificationsOfElementsResult:
    """
    Sets the classifications of elements. In order to set the classification of an element to unclassified, omit the classificationItemId field. It works for subelements of hierarchal elements also.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="SetClassificationsOfElements",
            parameters=params.model_dump(mode='json')
        )
        return SetClassificationsOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for SetClassificationsOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing SetClassificationsOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    set_classifications_of_elements,
    name="elements_set_classifications_of_elements",
    title="SetClassificationsOfElements",
    description="Sets the classifications of elements. In order to set the classification of an element to unclassified, omit the classificationItemId field. It works for subelements of hierarchal elements also.",
    params_model=SetClassificationsOfElementsParameters,
    result_model=SetClassificationsOfElementsResult
)


def set_details_of_elements(port: int, params: SetDetailsOfElementsParameters) -> SetDetailsOfElementsResult:
    """
    Sets the details of the given elements (floor, layer, order etc).
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="SetDetailsOfElements",
            parameters=params.model_dump(mode='json')
        )
        return SetDetailsOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for SetDetailsOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing SetDetailsOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    set_details_of_elements,
    name="elements_set_details_of_elements",
    title="SetDetailsOfElements",
    description="Sets the details of the given elements (floor, layer, order etc).",
    params_model=SetDetailsOfElementsParameters,
    result_model=SetDetailsOfElementsResult
)


def set_gdl_parameters_of_elements(port: int, params: SetGDLParametersOfElementsParameters) -> SetGDLParametersOfElementsResult:
    """
    Sets the given GDL parameters of the given elements.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="SetGDLParametersOfElements",
            parameters=params.model_dump(mode='json')
        )
        return SetGDLParametersOfElementsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for SetGDLParametersOfElements result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing SetGDLParametersOfElements on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    set_gdl_parameters_of_elements,
    name="elements_set_gdl_parameters_of_elements",
    title="SetGDLParametersOfElements",
    description="Sets the given GDL parameters of the given elements.",
    params_model=SetGDLParametersOfElementsParameters,
    result_model=SetGDLParametersOfElementsResult
)
