# This file is auto-generated by generate_tools.py. DO NOT EDIT.
import logging
from pydantic import ValidationError
from multiconn_archicad.basic_types import Port
from tapir_archicad_mcp.context import multi_conn_instance
from tapir_archicad_mcp.tools.tool_registry import register_tool_for_dispatch

from multiconn_archicad.models.tapir.commands import (
    AddFilesToEmbeddedLibraryParameters,
AddFilesToEmbeddedLibraryResult,
GetLibrariesResult
)


log = logging.getLogger()

def add_files_to_embedded_library(port: int, params: AddFilesToEmbeddedLibraryParameters) -> AddFilesToEmbeddedLibraryResult:
    """
    Adds the given files into the embedded library.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="AddFilesToEmbeddedLibrary",
            parameters=params.model_dump(mode='json')
        )
        return AddFilesToEmbeddedLibraryResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for AddFilesToEmbeddedLibrary result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing AddFilesToEmbeddedLibrary on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    add_files_to_embedded_library,
    name="library_add_files_to_embedded_library",
    title="AddFilesToEmbeddedLibrary",
    description="Adds the given files into the embedded library.",
    params_model=AddFilesToEmbeddedLibraryParameters,
    result_model=AddFilesToEmbeddedLibraryResult
)


def get_libraries(port: int) -> GetLibrariesResult:
    """
    Gets the list of loaded libraries.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetLibraries",
            parameters={}
        )
        return GetLibrariesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetLibraries result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetLibraries on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_libraries,
    name="library_get_libraries",
    title="GetLibraries",
    description="Gets the list of loaded libraries.",
    params_model=None,
    result_model=GetLibrariesResult
)


def reload_libraries(port: int) -> None:
    """
    Executes the reload libraries command.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        conn_header.core.post_tapir_command(
            command="ReloadLibraries",
            parameters={}
        )
        return None

    except ValidationError as e:
        log.error(f"Validation error for ReloadLibraries result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing ReloadLibraries on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    reload_libraries,
    name="library_reload_libraries",
    title="ReloadLibraries",
    description="Executes the reload libraries command.",
    params_model=None,
    result_model=None
)
