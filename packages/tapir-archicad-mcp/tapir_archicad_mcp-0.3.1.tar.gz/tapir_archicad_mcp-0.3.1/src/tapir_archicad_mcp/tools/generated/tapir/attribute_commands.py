# This file is auto-generated by generate_tools.py. DO NOT EDIT.
import logging
from pydantic import ValidationError
from multiconn_archicad.basic_types import Port
from tapir_archicad_mcp.context import multi_conn_instance
from tapir_archicad_mcp.tools.tool_registry import register_tool_for_dispatch
import time
from typing import Any
from tapir_archicad_mcp.pagination import handle_paginated_request, PAGINATION_CACHE, CACHE_LIFETIME_SECONDS

from multiconn_archicad.models.tapir.commands import (
    CreateBuildingMaterialsParameters,
CreateBuildingMaterialsResult,
CreateCompositesParameters,
CreateCompositesResult,
CreateLayerCombinationsParameters,
CreateLayerCombinationsResult,
CreateLayersParameters,
CreateLayersResult,
CreateSurfacesParameters,
CreateSurfacesResult,
GetAttributesByTypeParameters,
GetAttributesByTypeResult,
GetBuildingMaterialPhysicalPropertiesParameters,
GetBuildingMaterialPhysicalPropertiesResult,
GetLayerCombinationsParameters,
GetLayerCombinationsResult
)


log = logging.getLogger()

def create_building_materials(port: int, params: CreateBuildingMaterialsParameters) -> CreateBuildingMaterialsResult:
    """
    Creates or overwrites Building Material attributes based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateBuildingMaterials",
            parameters=params.model_dump(mode='json')
        )
        return CreateBuildingMaterialsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateBuildingMaterials result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateBuildingMaterials on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_building_materials,
    name="attributes_create_building_materials",
    title="CreateBuildingMaterials",
    description="Creates or overwrites Building Material attributes based on the given parameters.",
    params_model=CreateBuildingMaterialsParameters,
    result_model=CreateBuildingMaterialsResult
)


def create_composites(port: int, params: CreateCompositesParameters) -> CreateCompositesResult:
    """
    Creates or overwrites Composite attributes based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateComposites",
            parameters=params.model_dump(mode='json')
        )
        return CreateCompositesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateComposites result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateComposites on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_composites,
    name="attributes_create_composites",
    title="CreateComposites",
    description="Creates or overwrites Composite attributes based on the given parameters.",
    params_model=CreateCompositesParameters,
    result_model=CreateCompositesResult
)


def create_layer_combinations(port: int, params: CreateLayerCombinationsParameters) -> CreateLayerCombinationsResult:
    """
    Creates or overwrites Layer Combination attributes based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateLayerCombinations",
            parameters=params.model_dump(mode='json')
        )
        return CreateLayerCombinationsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateLayerCombinations result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateLayerCombinations on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_layer_combinations,
    name="attributes_create_layer_combinations",
    title="CreateLayerCombinations",
    description="Creates or overwrites Layer Combination attributes based on the given parameters.",
    params_model=CreateLayerCombinationsParameters,
    result_model=CreateLayerCombinationsResult
)


def create_layers(port: int, params: CreateLayersParameters) -> CreateLayersResult:
    """
    Creates or overwrites Layer attributes based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateLayers",
            parameters=params.model_dump(mode='json')
        )
        return CreateLayersResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateLayers result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateLayers on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_layers,
    name="attributes_create_layers",
    title="CreateLayers",
    description="Creates or overwrites Layer attributes based on the given parameters.",
    params_model=CreateLayersParameters,
    result_model=CreateLayersResult
)


def create_surfaces(port: int, params: CreateSurfacesParameters) -> CreateSurfacesResult:
    """
    Creates or overwrites Surface attributes based on the given parameters.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="CreateSurfaces",
            parameters=params.model_dump(mode='json')
        )
        return CreateSurfacesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for CreateSurfaces result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing CreateSurfaces on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    create_surfaces,
    name="attributes_create_surfaces",
    title="CreateSurfaces",
    description="Creates or overwrites Surface attributes based on the given parameters.",
    params_model=CreateSurfacesParameters,
    result_model=CreateSurfacesResult
)


class PaginatedGetAttributesByTypeResult(GetAttributesByTypeResult):
    """A paginated version of the GetAttributesByTypeResult."""
    attributes: list[Any]
    next_page_token: str | None = None


def get_attributes_by_type(port: int, params: GetAttributesByTypeParameters, page_token: str | None = None) -> PaginatedGetAttributesByTypeResult:
    """
    Returns the details of every attribute of the given type.
        This response is paginated. If 'next_page_token' is returned, call this function
        again with that token to get the next page of results.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        cache_key = f"{port}:GetAttributesByType:{params.model_dump_json()}"

        if not page_token:
            full_response_dict = conn_header.core.post_tapir_command(
                command="GetAttributesByType",
                parameters=params.model_dump(mode='json')
            )
            full_response_model = GetAttributesByTypeResult.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "attributes")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["attributes"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return PaginatedGetAttributesByTypeResult.model_validate(response_data)

    except ValidationError as e:
        log.error(f"Validation error for GetAttributesByType result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetAttributesByType on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_attributes_by_type,
    name="attributes_get_attributes_by_type",
    title="GetAttributesByType",
    description="Returns the details of every attribute of the given type.",
    params_model=GetAttributesByTypeParameters,
    result_model=PaginatedGetAttributesByTypeResult
)


def get_building_material_physical_properties(port: int, params: GetBuildingMaterialPhysicalPropertiesParameters) -> GetBuildingMaterialPhysicalPropertiesResult:
    """
    Retrieves the physical properties of the given Building Materials.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetBuildingMaterialPhysicalProperties",
            parameters=params.model_dump(mode='json')
        )
        return GetBuildingMaterialPhysicalPropertiesResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetBuildingMaterialPhysicalProperties result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetBuildingMaterialPhysicalProperties on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_building_material_physical_properties,
    name="attributes_get_building_material_physical_properties",
    title="GetBuildingMaterialPhysicalProperties",
    description="Retrieves the physical properties of the given Building Materials.",
    params_model=GetBuildingMaterialPhysicalPropertiesParameters,
    result_model=GetBuildingMaterialPhysicalPropertiesResult
)


def get_layer_combinations(port: int, params: GetLayerCombinationsParameters) -> GetLayerCombinationsResult:
    """
    Returns the details of layer combination attributes.
    """
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {port} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:

        result_dict = conn_header.core.post_tapir_command(
            command="GetLayerCombinations",
            parameters=params.model_dump(mode='json')
        )
        return GetLayerCombinationsResult.model_validate(result_dict)

    except ValidationError as e:
        log.error(f"Validation error for GetLayerCombinations result: {e}")
        raise ValueError(f"Received an invalid response from the Archicad API: {e}")
    except Exception as e:
        log.error(f"Error executing GetLayerCombinations on port {port}: {e}")
        raise e


register_tool_for_dispatch(
    get_layer_combinations,
    name="attributes_get_layer_combinations",
    title="GetLayerCombinations",
    description="Returns the details of layer combination attributes.",
    params_model=GetLayerCombinationsParameters,
    result_model=GetLayerCombinationsResult
)
