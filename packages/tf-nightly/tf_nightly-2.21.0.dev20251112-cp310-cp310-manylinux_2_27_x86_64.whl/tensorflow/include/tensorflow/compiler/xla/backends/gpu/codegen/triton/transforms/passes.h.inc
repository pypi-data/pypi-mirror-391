/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_EXTRACTTMAINFOPASS
#define GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#define GEN_PASS_DECL_LOADINT4REWRITEPASS
#define GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#define GEN_PASS_DECL_STABLEHLOLOWERTOTRITONPASS
#define GEN_PASS_DECL_TENSORLOWERTOTRITONPASS
#define GEN_PASS_DECL_TRITONXLACONVERT0DTENSORTOSCALARPASS
#define GEN_PASS_DECL_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
#define GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#define GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#define GEN_PASS_DECL_TRITONXLALOWERATOMICSPASS
#define GEN_PASS_DECL_TRITONXLALOWERBLOCKBARRIERPASS
#define GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#define GEN_PASS_DECL_TRITONXLALOWERREMOTEACCESSPASS
#define GEN_PASS_DECL_TRITONXLALOWERXTILEPASS
#define GEN_PASS_DECL_TRITONXLAMATHTOLIBDEVICEPASS
#define GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#define GEN_PASS_DECL_TRITONXLAUNSWITCHLOOPSPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ExtractTmaInfoPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXTRACTTMAINFOPASS
#undef GEN_PASS_DECL_EXTRACTTMAINFOPASS
#endif // GEN_PASS_DECL_EXTRACTTMAINFOPASS
#ifdef GEN_PASS_DEF_EXTRACTTMAINFOPASS
namespace impl {

template <typename DerivedT>
class ExtractTmaInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExtractTmaInfoPassBase;

  ExtractTmaInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTmaInfoPassBase(const ExtractTmaInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExtractTmaInfoPassBase& operator=(const ExtractTmaInfoPassBase &) = delete;
  ExtractTmaInfoPassBase(ExtractTmaInfoPassBase &&) = delete;
  ExtractTmaInfoPassBase& operator=(ExtractTmaInfoPassBase &&) = delete;
  ~ExtractTmaInfoPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("extract-tma-info");
  }
  ::llvm::StringRef getArgument() const override { return "extract-tma-info"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Extract TMA info during Triton lowering.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTmaInfoPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTmaInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTmaInfoPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXTRACTTMAINFOPASS
#endif // GEN_PASS_DEF_EXTRACTTMAINFOPASS

//===----------------------------------------------------------------------===//
// GeneralizeKernelSignaturePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#undef GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#endif // GEN_PASS_DECL_GENERALIZEKERNELSIGNATUREPASS
#ifdef GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS
namespace impl {

template <typename DerivedT>
class GeneralizeKernelSignaturePassBase : public ::mlir::OperationPass<> {
public:
  using Base = GeneralizeKernelSignaturePassBase;

  GeneralizeKernelSignaturePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GeneralizeKernelSignaturePassBase(const GeneralizeKernelSignaturePassBase &other) : ::mlir::OperationPass<>(other) {}
  GeneralizeKernelSignaturePassBase& operator=(const GeneralizeKernelSignaturePassBase &) = delete;
  GeneralizeKernelSignaturePassBase(GeneralizeKernelSignaturePassBase &&) = delete;
  GeneralizeKernelSignaturePassBase& operator=(GeneralizeKernelSignaturePassBase &&) = delete;
  ~GeneralizeKernelSignaturePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generalize-kernel-signature");
  }
  ::llvm::StringRef getArgument() const override { return "generalize-kernel-signature"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite kernels to use generic data pointer arguments.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GeneralizeKernelSignaturePass");
  }
  ::llvm::StringRef getName() const override { return "GeneralizeKernelSignaturePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GeneralizeKernelSignaturePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS
#endif // GEN_PASS_DEF_GENERALIZEKERNELSIGNATUREPASS

//===----------------------------------------------------------------------===//
// LoadInt4RewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOADINT4REWRITEPASS
struct LoadInt4RewritePassOptions {
  bool enable_bf16x2_ = true;
};
std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass();
std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass(LoadInt4RewritePassOptions options);
#undef GEN_PASS_DECL_LOADINT4REWRITEPASS
#endif // GEN_PASS_DECL_LOADINT4REWRITEPASS
#ifdef GEN_PASS_DEF_LOADINT4REWRITEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass(LoadInt4RewritePassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class LoadInt4RewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LoadInt4RewritePassBase;

  LoadInt4RewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoadInt4RewritePassBase(const LoadInt4RewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LoadInt4RewritePassBase& operator=(const LoadInt4RewritePassBase &) = delete;
  LoadInt4RewritePassBase(LoadInt4RewritePassBase &&) = delete;
  LoadInt4RewritePassBase& operator=(LoadInt4RewritePassBase &&) = delete;
  ~LoadInt4RewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("int4-to-packed-int4-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "int4-to-packed-int4-rewrite"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts ops with int4 tensors to the ops with int4 packed to int8 tensors.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoadInt4RewritePass");
  }
  ::llvm::StringRef getName() const override { return "LoadInt4RewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoadInt4RewritePassBase<DerivedT>)

  LoadInt4RewritePassBase(LoadInt4RewritePassOptions options) : LoadInt4RewritePassBase() {
    enable_bf16x2_ = std::move(options.enable_bf16x2_);
  }
protected:
  ::mlir::Pass::Option<bool> enable_bf16x2_{*this, "enable_bf16x2", ::llvm::cl::desc(R"PO(Whether to enable bf16x2.)PO"), ::llvm::cl::init(true)};
private:

  friend std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass(LoadInt4RewritePassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass() {
  return impl::createLoadInt4RewritePass();
}

std::unique_ptr<::mlir::Pass> createLoadInt4RewritePass(LoadInt4RewritePassOptions options) {
  return impl::createLoadInt4RewritePass(std::move(options));
}
#undef GEN_PASS_DEF_LOADINT4REWRITEPASS
#endif // GEN_PASS_DEF_LOADINT4REWRITEPASS

//===----------------------------------------------------------------------===//
// RoundF32ToTF32ForTf32DotRewritePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#undef GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#endif // GEN_PASS_DECL_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#ifdef GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
namespace impl {

template <typename DerivedT>
class RoundF32ToTF32ForTf32DotRewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RoundF32ToTF32ForTf32DotRewritePassBase;

  RoundF32ToTF32ForTf32DotRewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RoundF32ToTF32ForTf32DotRewritePassBase(const RoundF32ToTF32ForTf32DotRewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(const RoundF32ToTF32ForTf32DotRewritePassBase &) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  ~RoundF32ToTF32ForTf32DotRewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("round-f32-to-tf32-for-tf32-dot-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "round-f32-to-tf32-for-tf32-dot-rewrite"; }

  ::llvm::StringRef getDescription() const override { return R"PD(dot with tf32 algorithm requires explicit rounding.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RoundF32ToTF32ForTf32DotRewritePass");
  }
  ::llvm::StringRef getName() const override { return "RoundF32ToTF32ForTf32DotRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RoundF32ToTF32ForTf32DotRewritePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS
#endif // GEN_PASS_DEF_ROUNDF32TOTF32FORTF32DOTREWRITEPASS

//===----------------------------------------------------------------------===//
// StableHLOLowerToTritonPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_STABLEHLOLOWERTOTRITONPASS
#undef GEN_PASS_DECL_STABLEHLOLOWERTOTRITONPASS
#endif // GEN_PASS_DECL_STABLEHLOLOWERTOTRITONPASS
#ifdef GEN_PASS_DEF_STABLEHLOLOWERTOTRITONPASS
namespace impl {

template <typename DerivedT>
class StableHLOLowerToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StableHLOLowerToTritonPassBase;

  StableHLOLowerToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StableHLOLowerToTritonPassBase(const StableHLOLowerToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  StableHLOLowerToTritonPassBase& operator=(const StableHLOLowerToTritonPassBase &) = delete;
  StableHLOLowerToTritonPassBase(StableHLOLowerToTritonPassBase &&) = delete;
  StableHLOLowerToTritonPassBase& operator=(StableHLOLowerToTritonPassBase &&) = delete;
  ~StableHLOLowerToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-lower-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-lower-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers StableHLO operations to their Triton equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StableHLOLowerToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "StableHLOLowerToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::stablehlo::StablehloDialect>();
    registry.insert<::mlir::triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StableHLOLowerToTritonPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_STABLEHLOLOWERTOTRITONPASS
#endif // GEN_PASS_DEF_STABLEHLOLOWERTOTRITONPASS

//===----------------------------------------------------------------------===//
// TensorLowerToTritonPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TENSORLOWERTOTRITONPASS
#undef GEN_PASS_DECL_TENSORLOWERTOTRITONPASS
#endif // GEN_PASS_DECL_TENSORLOWERTOTRITONPASS
#ifdef GEN_PASS_DEF_TENSORLOWERTOTRITONPASS
namespace impl {

template <typename DerivedT>
class TensorLowerToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TensorLowerToTritonPassBase;

  TensorLowerToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorLowerToTritonPassBase(const TensorLowerToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TensorLowerToTritonPassBase& operator=(const TensorLowerToTritonPassBase &) = delete;
  TensorLowerToTritonPassBase(TensorLowerToTritonPassBase &&) = delete;
  TensorLowerToTritonPassBase& operator=(TensorLowerToTritonPassBase &&) = delete;
  ~TensorLowerToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tensor-lower-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "tensor-lower-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers tensor operations to their Triton equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorLowerToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TensorLowerToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorLowerToTritonPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TENSORLOWERTOTRITONPASS
#endif // GEN_PASS_DEF_TENSORLOWERTOTRITONPASS

//===----------------------------------------------------------------------===//
// TritonXLAConvert0DTensorToScalarPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLACONVERT0DTENSORTOSCALARPASS
std::unique_ptr<::mlir::Pass> createTritonXLAConvert0DTensorToScalarPass();
#undef GEN_PASS_DECL_TRITONXLACONVERT0DTENSORTOSCALARPASS
#endif // GEN_PASS_DECL_TRITONXLACONVERT0DTENSORTOSCALARPASS
#ifdef GEN_PASS_DEF_TRITONXLACONVERT0DTENSORTOSCALARPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonXLAConvert0DTensorToScalarPass();
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonXLAConvert0DTensorToScalarPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAConvert0DTensorToScalarPassBase;

  TritonXLAConvert0DTensorToScalarPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAConvert0DTensorToScalarPassBase(const TritonXLAConvert0DTensorToScalarPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAConvert0DTensorToScalarPassBase& operator=(const TritonXLAConvert0DTensorToScalarPassBase &) = delete;
  TritonXLAConvert0DTensorToScalarPassBase(TritonXLAConvert0DTensorToScalarPassBase &&) = delete;
  TritonXLAConvert0DTensorToScalarPassBase& operator=(TritonXLAConvert0DTensorToScalarPassBase &&) = delete;
  ~TritonXLAConvert0DTensorToScalarPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-convert-0d-tensor-to-scalar");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-convert-0d-tensor-to-scalar"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers 0D tensors to scalars.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAConvert0DTensorToScalarPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAConvert0DTensorToScalarPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAConvert0DTensorToScalarPassBase<DerivedT>)

protected:
private:

  friend std::unique_ptr<::mlir::Pass> createTritonXLAConvert0DTensorToScalarPass() {
    return std::make_unique<DerivedT>();
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonXLAConvert0DTensorToScalarPass() {
  return impl::createTritonXLAConvert0DTensorToScalarPass();
}
#undef GEN_PASS_DEF_TRITONXLACONVERT0DTENSORTOSCALARPASS
#endif // GEN_PASS_DEF_TRITONXLACONVERT0DTENSORTOSCALARPASS

//===----------------------------------------------------------------------===//
// TritonXLAConvertUnsupportedTypesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
#undef GEN_PASS_DECL_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
#endif // GEN_PASS_DECL_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
#ifdef GEN_PASS_DEF_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
namespace impl {

template <typename DerivedT>
class TritonXLAConvertUnsupportedTypesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAConvertUnsupportedTypesPassBase;

  TritonXLAConvertUnsupportedTypesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAConvertUnsupportedTypesPassBase(const TritonXLAConvertUnsupportedTypesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAConvertUnsupportedTypesPassBase& operator=(const TritonXLAConvertUnsupportedTypesPassBase &) = delete;
  TritonXLAConvertUnsupportedTypesPassBase(TritonXLAConvertUnsupportedTypesPassBase &&) = delete;
  TritonXLAConvertUnsupportedTypesPassBase& operator=(TritonXLAConvertUnsupportedTypesPassBase &&) = delete;
  ~TritonXLAConvertUnsupportedTypesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-unsupported-types");
  }
  ::llvm::StringRef getArgument() const override { return "convert-unsupported-types"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts types unsupported by Triton into their supported equivalents.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAConvertUnsupportedTypesPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAConvertUnsupportedTypesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAConvertUnsupportedTypesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLACONVERTUNSUPPORTEDTYPESPASS
#endif // GEN_PASS_DEF_TRITONXLACONVERTUNSUPPORTEDTYPESPASS

//===----------------------------------------------------------------------===//
// TritonXLAExtractInsertToTritonPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
struct TritonXLAExtractInsertToTritonPassOptions {
  bool allow_tma_ = false;
  int num_stages_ = 1;
};
#undef GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#endif // GEN_PASS_DECL_TRITONXLAEXTRACTINSERTTOTRITONPASS
#ifdef GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS
namespace impl {

template <typename DerivedT>
class TritonXLAExtractInsertToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAExtractInsertToTritonPassBase;

  TritonXLAExtractInsertToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAExtractInsertToTritonPassBase(const TritonXLAExtractInsertToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAExtractInsertToTritonPassBase& operator=(const TritonXLAExtractInsertToTritonPassBase &) = delete;
  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  TritonXLAExtractInsertToTritonPassBase& operator=(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  ~TritonXLAExtractInsertToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-extract-insert-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-extract-insert-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert Triton XLA extract and insert ops to Triton ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAExtractInsertToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAExtractInsertToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAExtractInsertToTritonPassBase<DerivedT>)

  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassOptions options) : TritonXLAExtractInsertToTritonPassBase() {
    allow_tma_ = std::move(options.allow_tma_);
    num_stages_ = std::move(options.num_stages_);
  }
protected:
  ::mlir::Pass::Option<bool> allow_tma_{*this, "allow_tma", ::llvm::cl::desc(R"PO(Whether to permit lowering to TMA.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int> num_stages_{*this, "num_stages", ::llvm::cl::desc(R"PO(Number of stages for pipelining.)PO"), ::llvm::cl::init(1)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS
#endif // GEN_PASS_DEF_TRITONXLAEXTRACTINSERTTOTRITONPASS

//===----------------------------------------------------------------------===//
// TritonXLAFoldTransposePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#undef GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#endif // GEN_PASS_DECL_TRITONXLAFOLDTRANSPOSEPASS
#ifdef GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS
namespace impl {

template <typename DerivedT>
class TritonXLAFoldTransposePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAFoldTransposePassBase;

  TritonXLAFoldTransposePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAFoldTransposePassBase(const TritonXLAFoldTransposePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAFoldTransposePassBase& operator=(const TritonXLAFoldTransposePassBase &) = delete;
  TritonXLAFoldTransposePassBase(TritonXLAFoldTransposePassBase &&) = delete;
  TritonXLAFoldTransposePassBase& operator=(TritonXLAFoldTransposePassBase &&) = delete;
  ~TritonXLAFoldTransposePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-fold-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-fold-transpose"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Folds transposes into loads.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAFoldTransposePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAFoldTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAFoldTransposePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS
#endif // GEN_PASS_DEF_TRITONXLAFOLDTRANSPOSEPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerAtomicsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERATOMICSPASS
#undef GEN_PASS_DECL_TRITONXLALOWERATOMICSPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERATOMICSPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERATOMICSPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerAtomicsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerAtomicsPassBase;

  TritonXLALowerAtomicsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerAtomicsPassBase(const TritonXLALowerAtomicsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerAtomicsPassBase& operator=(const TritonXLALowerAtomicsPassBase &) = delete;
  TritonXLALowerAtomicsPassBase(TritonXLALowerAtomicsPassBase &&) = delete;
  TritonXLALowerAtomicsPassBase& operator=(TritonXLALowerAtomicsPassBase &&) = delete;
  ~TritonXLALowerAtomicsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-atomics");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-atomics"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower triton_xla.atomic operations.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerAtomicsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerAtomicsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerAtomicsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERATOMICSPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERATOMICSPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerBlockBarrierPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERBLOCKBARRIERPASS
#undef GEN_PASS_DECL_TRITONXLALOWERBLOCKBARRIERPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERBLOCKBARRIERPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERBLOCKBARRIERPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerBlockBarrierPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerBlockBarrierPassBase;

  TritonXLALowerBlockBarrierPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerBlockBarrierPassBase(const TritonXLALowerBlockBarrierPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerBlockBarrierPassBase& operator=(const TritonXLALowerBlockBarrierPassBase &) = delete;
  TritonXLALowerBlockBarrierPassBase(TritonXLALowerBlockBarrierPassBase &&) = delete;
  TritonXLALowerBlockBarrierPassBase& operator=(TritonXLALowerBlockBarrierPassBase &&) = delete;
  ~TritonXLALowerBlockBarrierPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-block-barrier");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-block-barrier"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower a block barrier to triton_xla/triton operations.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerBlockBarrierPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerBlockBarrierPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerBlockBarrierPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERBLOCKBARRIERPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERBLOCKBARRIERPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerGetTidPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#undef GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERGETTIDPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerGetTidPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerGetTidPassBase;

  TritonXLALowerGetTidPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerGetTidPassBase(const TritonXLALowerGetTidPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerGetTidPassBase& operator=(const TritonXLALowerGetTidPassBase &) = delete;
  TritonXLALowerGetTidPassBase(TritonXLALowerGetTidPassBase &&) = delete;
  TritonXLALowerGetTidPassBase& operator=(TritonXLALowerGetTidPassBase &&) = delete;
  ~TritonXLALowerGetTidPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-get-tid");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-get-tid"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower get_tid to the PTX intrinsic.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerGetTidPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerGetTidPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerGetTidPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERGETTIDPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerRemoteAccessPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERREMOTEACCESSPASS
#undef GEN_PASS_DECL_TRITONXLALOWERREMOTEACCESSPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERREMOTEACCESSPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERREMOTEACCESSPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerRemoteAccessPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerRemoteAccessPassBase;

  TritonXLALowerRemoteAccessPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerRemoteAccessPassBase(const TritonXLALowerRemoteAccessPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerRemoteAccessPassBase& operator=(const TritonXLALowerRemoteAccessPassBase &) = delete;
  TritonXLALowerRemoteAccessPassBase(TritonXLALowerRemoteAccessPassBase &&) = delete;
  TritonXLALowerRemoteAccessPassBase& operator=(TritonXLALowerRemoteAccessPassBase &&) = delete;
  ~TritonXLALowerRemoteAccessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-remote-access");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-remote-access"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower triton_xla.get_rank/get_peer operations used to remote access kernels.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerRemoteAccessPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerRemoteAccessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerRemoteAccessPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERREMOTEACCESSPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERREMOTEACCESSPASS

//===----------------------------------------------------------------------===//
// TritonXLALowerXTilePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLALOWERXTILEPASS
#undef GEN_PASS_DECL_TRITONXLALOWERXTILEPASS
#endif // GEN_PASS_DECL_TRITONXLALOWERXTILEPASS
#ifdef GEN_PASS_DEF_TRITONXLALOWERXTILEPASS
namespace impl {

template <typename DerivedT>
class TritonXLALowerXTilePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerXTilePassBase;

  TritonXLALowerXTilePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerXTilePassBase(const TritonXLALowerXTilePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerXTilePassBase& operator=(const TritonXLALowerXTilePassBase &) = delete;
  TritonXLALowerXTilePassBase(TritonXLALowerXTilePassBase &&) = delete;
  TritonXLALowerXTilePassBase& operator=(TritonXLALowerXTilePassBase &&) = delete;
  ~TritonXLALowerXTilePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-lower-xtile");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-lower-xtile"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers xtile ops to Triton ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerXTilePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerXTilePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::memref::MemRefDialect>();
    registry.insert<mlir::triton::xla::XlaTritonDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerXTilePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLALOWERXTILEPASS
#endif // GEN_PASS_DEF_TRITONXLALOWERXTILEPASS

//===----------------------------------------------------------------------===//
// TritonXLAMathToLibdevicePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAMATHTOLIBDEVICEPASS
struct TritonXLAMathToLibdevicePassOptions {
  std::string libdevice_path_;
  std::string triple_string_;
};
std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass();
std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass(TritonXLAMathToLibdevicePassOptions options);
#undef GEN_PASS_DECL_TRITONXLAMATHTOLIBDEVICEPASS
#endif // GEN_PASS_DECL_TRITONXLAMATHTOLIBDEVICEPASS
#ifdef GEN_PASS_DEF_TRITONXLAMATHTOLIBDEVICEPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass(TritonXLAMathToLibdevicePassOptions options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class TritonXLAMathToLibdevicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAMathToLibdevicePassBase;

  TritonXLAMathToLibdevicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAMathToLibdevicePassBase(const TritonXLAMathToLibdevicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAMathToLibdevicePassBase& operator=(const TritonXLAMathToLibdevicePassBase &) = delete;
  TritonXLAMathToLibdevicePassBase(TritonXLAMathToLibdevicePassBase &&) = delete;
  TritonXLAMathToLibdevicePassBase& operator=(TritonXLAMathToLibdevicePassBase &&) = delete;
  ~TritonXLAMathToLibdevicePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-math-to-libdevice");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-math-to-libdevice"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers math operations to tt.extern_elementwise calls to their libdevice equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAMathToLibdevicePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAMathToLibdevicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAMathToLibdevicePassBase<DerivedT>)

  TritonXLAMathToLibdevicePassBase(TritonXLAMathToLibdevicePassOptions options) : TritonXLAMathToLibdevicePassBase() {
    libdevice_path_ = std::move(options.libdevice_path_);
    triple_string_ = std::move(options.triple_string_);
  }
protected:
  ::mlir::Pass::Option<std::string> libdevice_path_{*this, "libdevice_path", ::llvm::cl::desc(R"PO(Path to the libdevice library.)PO")};
  ::mlir::Pass::Option<std::string> triple_string_{*this, "triple", ::llvm::cl::desc(R"PO(Device triple string.)PO")};
private:

  friend std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass(TritonXLAMathToLibdevicePassOptions options) {
    return std::make_unique<DerivedT>(std::move(options));
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass() {
  return impl::createTritonXLAMathToLibdevicePass();
}

std::unique_ptr<::mlir::Pass> createTritonXLAMathToLibdevicePass(TritonXLAMathToLibdevicePassOptions options) {
  return impl::createTritonXLAMathToLibdevicePass(std::move(options));
}
#undef GEN_PASS_DEF_TRITONXLAMATHTOLIBDEVICEPASS
#endif // GEN_PASS_DEF_TRITONXLAMATHTOLIBDEVICEPASS

//===----------------------------------------------------------------------===//
// TritonXLASqueezeDimsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
struct TritonXLASqueezeDimsPassOptions {
  bool finalize_ = true;
};
#undef GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#endif // GEN_PASS_DECL_TRITONXLASQUEEZEDIMSPASS
#ifdef GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS
namespace impl {

template <typename DerivedT>
class TritonXLASqueezeDimsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLASqueezeDimsPassBase;

  TritonXLASqueezeDimsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLASqueezeDimsPassBase(const TritonXLASqueezeDimsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLASqueezeDimsPassBase& operator=(const TritonXLASqueezeDimsPassBase &) = delete;
  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassBase &&) = delete;
  TritonXLASqueezeDimsPassBase& operator=(TritonXLASqueezeDimsPassBase &&) = delete;
  ~TritonXLASqueezeDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-squeeze-dims");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-squeeze-dims"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Remove superfluous size-1 dimensions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLASqueezeDimsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLASqueezeDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<::mlir::triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLASqueezeDimsPassBase<DerivedT>)

  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassOptions options) : TritonXLASqueezeDimsPassBase() {
    finalize_ = std::move(options.finalize_);
  }
protected:
  ::mlir::Pass::Option<bool> finalize_{*this, "finalize", ::llvm::cl::desc(R"PO(Convert squeeze_dims back to reshape. Disable for testing only.)PO"), ::llvm::cl::init(true)};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS
#endif // GEN_PASS_DEF_TRITONXLASQUEEZEDIMSPASS

//===----------------------------------------------------------------------===//
// TritonXLAUnswitchLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_TRITONXLAUNSWITCHLOOPSPASS
#undef GEN_PASS_DECL_TRITONXLAUNSWITCHLOOPSPASS
#endif // GEN_PASS_DECL_TRITONXLAUNSWITCHLOOPSPASS
#ifdef GEN_PASS_DEF_TRITONXLAUNSWITCHLOOPSPASS
namespace impl {

template <typename DerivedT>
class TritonXLAUnswitchLoopsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAUnswitchLoopsPassBase;

  TritonXLAUnswitchLoopsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAUnswitchLoopsPassBase(const TritonXLAUnswitchLoopsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAUnswitchLoopsPassBase& operator=(const TritonXLAUnswitchLoopsPassBase &) = delete;
  TritonXLAUnswitchLoopsPassBase(TritonXLAUnswitchLoopsPassBase &&) = delete;
  TritonXLAUnswitchLoopsPassBase& operator=(TritonXLAUnswitchLoopsPassBase &&) = delete;
  ~TritonXLAUnswitchLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-unswitch-loops");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-unswitch-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Hoists scf.if out of scf.for.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAUnswitchLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAUnswitchLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAUnswitchLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_TRITONXLAUNSWITCHLOOPSPASS
#endif // GEN_PASS_DEF_TRITONXLAUNSWITCHLOOPSPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ExtractTmaInfoPass Registration
//===----------------------------------------------------------------------===//

inline void registerExtractTmaInfoPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExtractTmaInfoPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExtractTmaInfoPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExtractTmaInfoPass();
  });
}

//===----------------------------------------------------------------------===//
// GeneralizeKernelSignaturePass Registration
//===----------------------------------------------------------------------===//

inline void registerGeneralizeKernelSignaturePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateGeneralizeKernelSignaturePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerGeneralizeKernelSignaturePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateGeneralizeKernelSignaturePass();
  });
}

//===----------------------------------------------------------------------===//
// LoadInt4RewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerLoadInt4RewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoadInt4RewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLoadInt4RewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLoadInt4RewritePass();
  });
}

//===----------------------------------------------------------------------===//
// RoundF32ToTF32ForTf32DotRewritePass Registration
//===----------------------------------------------------------------------===//

inline void registerRoundF32ToTF32ForTf32DotRewritePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRoundF32ToTF32ForTf32DotRewritePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRoundF32ToTF32ForTf32DotRewritePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRoundF32ToTF32ForTf32DotRewritePass();
  });
}

//===----------------------------------------------------------------------===//
// StableHLOLowerToTritonPass Registration
//===----------------------------------------------------------------------===//

inline void registerStableHLOLowerToTritonPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateStableHLOLowerToTritonPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerStableHLOLowerToTritonPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateStableHLOLowerToTritonPass();
  });
}

//===----------------------------------------------------------------------===//
// TensorLowerToTritonPass Registration
//===----------------------------------------------------------------------===//

inline void registerTensorLowerToTritonPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorLowerToTritonPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTensorLowerToTritonPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTensorLowerToTritonPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAConvert0DTensorToScalarPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAConvert0DTensorToScalarPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonXLAConvert0DTensorToScalarPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAConvert0DTensorToScalarPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonXLAConvert0DTensorToScalarPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAConvertUnsupportedTypesPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAConvertUnsupportedTypesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAConvertUnsupportedTypesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAConvertUnsupportedTypesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAConvertUnsupportedTypesPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAExtractInsertToTritonPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAExtractInsertToTritonPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAExtractInsertToTritonPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAExtractInsertToTritonPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAExtractInsertToTritonPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAFoldTransposePass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAFoldTransposePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAFoldTransposePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAFoldTransposePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAFoldTransposePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerAtomicsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerAtomicsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerAtomicsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerAtomicsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerAtomicsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerBlockBarrierPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerBlockBarrierPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerBlockBarrierPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerBlockBarrierPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerBlockBarrierPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerGetTidPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerGetTidPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerGetTidPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerGetTidPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerGetTidPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerRemoteAccessPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerRemoteAccessPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerRemoteAccessPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerRemoteAccessPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerRemoteAccessPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLALowerXTilePass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLALowerXTilePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerXTilePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLALowerXTilePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLALowerXTilePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAMathToLibdevicePass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAMathToLibdevicePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonXLAMathToLibdevicePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAMathToLibdevicePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createTritonXLAMathToLibdevicePass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLASqueezeDimsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLASqueezeDimsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLASqueezeDimsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLASqueezeDimsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLASqueezeDimsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXLAUnswitchLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXLAUnswitchLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAUnswitchLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerTritonXLAUnswitchLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateTritonXLAUnswitchLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// TritonXlaTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerTritonXlaTransformsPasses() {
  registerExtractTmaInfoPass();
  registerGeneralizeKernelSignaturePass();
  registerLoadInt4RewritePass();
  registerRoundF32ToTF32ForTf32DotRewritePass();
  registerStableHLOLowerToTritonPass();
  registerTensorLowerToTritonPass();
  registerTritonXLAConvert0DTensorToScalarPass();
  registerTritonXLAConvertUnsupportedTypesPass();
  registerTritonXLAExtractInsertToTritonPass();
  registerTritonXLAFoldTransposePass();
  registerTritonXLALowerAtomicsPass();
  registerTritonXLALowerBlockBarrierPass();
  registerTritonXLALowerGetTidPass();
  registerTritonXLALowerRemoteAccessPass();
  registerTritonXLALowerXTilePass();
  registerTritonXLAMathToLibdevicePass();
  registerTritonXLASqueezeDimsPass();
  registerTritonXLAUnswitchLoopsPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ExtractTmaInfoPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExtractTmaInfoPassBase;

  ExtractTmaInfoPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExtractTmaInfoPassBase(const ExtractTmaInfoPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExtractTmaInfoPassBase& operator=(const ExtractTmaInfoPassBase &) = delete;
  ExtractTmaInfoPassBase(ExtractTmaInfoPassBase &&) = delete;
  ExtractTmaInfoPassBase& operator=(ExtractTmaInfoPassBase &&) = delete;
  ~ExtractTmaInfoPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("extract-tma-info");
  }
  ::llvm::StringRef getArgument() const override { return "extract-tma-info"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Extract TMA info during Triton lowering.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExtractTmaInfoPass");
  }
  ::llvm::StringRef getName() const override { return "ExtractTmaInfoPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExtractTmaInfoPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class GeneralizeKernelSignaturePassBase : public ::mlir::OperationPass<> {
public:
  using Base = GeneralizeKernelSignaturePassBase;

  GeneralizeKernelSignaturePassBase() : ::mlir::OperationPass<>(::mlir::TypeID::get<DerivedT>()) {}
  GeneralizeKernelSignaturePassBase(const GeneralizeKernelSignaturePassBase &other) : ::mlir::OperationPass<>(other) {}
  GeneralizeKernelSignaturePassBase& operator=(const GeneralizeKernelSignaturePassBase &) = delete;
  GeneralizeKernelSignaturePassBase(GeneralizeKernelSignaturePassBase &&) = delete;
  GeneralizeKernelSignaturePassBase& operator=(GeneralizeKernelSignaturePassBase &&) = delete;
  ~GeneralizeKernelSignaturePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("generalize-kernel-signature");
  }
  ::llvm::StringRef getArgument() const override { return "generalize-kernel-signature"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Rewrite kernels to use generic data pointer arguments.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("GeneralizeKernelSignaturePass");
  }
  ::llvm::StringRef getName() const override { return "GeneralizeKernelSignaturePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(GeneralizeKernelSignaturePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LoadInt4RewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LoadInt4RewritePassBase;

  LoadInt4RewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LoadInt4RewritePassBase(const LoadInt4RewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LoadInt4RewritePassBase& operator=(const LoadInt4RewritePassBase &) = delete;
  LoadInt4RewritePassBase(LoadInt4RewritePassBase &&) = delete;
  LoadInt4RewritePassBase& operator=(LoadInt4RewritePassBase &&) = delete;
  ~LoadInt4RewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("int4-to-packed-int4-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "int4-to-packed-int4-rewrite"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts ops with int4 tensors to the ops with int4 packed to int8 tensors.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LoadInt4RewritePass");
  }
  ::llvm::StringRef getName() const override { return "LoadInt4RewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LoadInt4RewritePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> enable_bf16x2_{*this, "enable_bf16x2", ::llvm::cl::desc(R"PO(Whether to enable bf16x2.)PO"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class RoundF32ToTF32ForTf32DotRewritePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = RoundF32ToTF32ForTf32DotRewritePassBase;

  RoundF32ToTF32ForTf32DotRewritePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  RoundF32ToTF32ForTf32DotRewritePassBase(const RoundF32ToTF32ForTf32DotRewritePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(const RoundF32ToTF32ForTf32DotRewritePassBase &) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  RoundF32ToTF32ForTf32DotRewritePassBase& operator=(RoundF32ToTF32ForTf32DotRewritePassBase &&) = delete;
  ~RoundF32ToTF32ForTf32DotRewritePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("round-f32-to-tf32-for-tf32-dot-rewrite");
  }
  ::llvm::StringRef getArgument() const override { return "round-f32-to-tf32-for-tf32-dot-rewrite"; }

  ::llvm::StringRef getDescription() const override { return R"PD(dot with tf32 algorithm requires explicit rounding.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RoundF32ToTF32ForTf32DotRewritePass");
  }
  ::llvm::StringRef getName() const override { return "RoundF32ToTF32ForTf32DotRewritePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RoundF32ToTF32ForTf32DotRewritePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class StableHLOLowerToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = StableHLOLowerToTritonPassBase;

  StableHLOLowerToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  StableHLOLowerToTritonPassBase(const StableHLOLowerToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  StableHLOLowerToTritonPassBase& operator=(const StableHLOLowerToTritonPassBase &) = delete;
  StableHLOLowerToTritonPassBase(StableHLOLowerToTritonPassBase &&) = delete;
  StableHLOLowerToTritonPassBase& operator=(StableHLOLowerToTritonPassBase &&) = delete;
  ~StableHLOLowerToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("stablehlo-lower-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "stablehlo-lower-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers StableHLO operations to their Triton equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("StableHLOLowerToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "StableHLOLowerToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::stablehlo::StablehloDialect>();
    registry.insert<::mlir::triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(StableHLOLowerToTritonPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TensorLowerToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TensorLowerToTritonPassBase;

  TensorLowerToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TensorLowerToTritonPassBase(const TensorLowerToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TensorLowerToTritonPassBase& operator=(const TensorLowerToTritonPassBase &) = delete;
  TensorLowerToTritonPassBase(TensorLowerToTritonPassBase &&) = delete;
  TensorLowerToTritonPassBase& operator=(TensorLowerToTritonPassBase &&) = delete;
  ~TensorLowerToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("tensor-lower-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "tensor-lower-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers tensor operations to their Triton equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TensorLowerToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TensorLowerToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TensorLowerToTritonPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLAConvert0DTensorToScalarPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAConvert0DTensorToScalarPassBase;

  TritonXLAConvert0DTensorToScalarPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAConvert0DTensorToScalarPassBase(const TritonXLAConvert0DTensorToScalarPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAConvert0DTensorToScalarPassBase& operator=(const TritonXLAConvert0DTensorToScalarPassBase &) = delete;
  TritonXLAConvert0DTensorToScalarPassBase(TritonXLAConvert0DTensorToScalarPassBase &&) = delete;
  TritonXLAConvert0DTensorToScalarPassBase& operator=(TritonXLAConvert0DTensorToScalarPassBase &&) = delete;
  ~TritonXLAConvert0DTensorToScalarPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-convert-0d-tensor-to-scalar");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-convert-0d-tensor-to-scalar"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers 0D tensors to scalars.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAConvert0DTensorToScalarPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAConvert0DTensorToScalarPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::xla::xtile::XTileDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAConvert0DTensorToScalarPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLAConvertUnsupportedTypesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAConvertUnsupportedTypesPassBase;

  TritonXLAConvertUnsupportedTypesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAConvertUnsupportedTypesPassBase(const TritonXLAConvertUnsupportedTypesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAConvertUnsupportedTypesPassBase& operator=(const TritonXLAConvertUnsupportedTypesPassBase &) = delete;
  TritonXLAConvertUnsupportedTypesPassBase(TritonXLAConvertUnsupportedTypesPassBase &&) = delete;
  TritonXLAConvertUnsupportedTypesPassBase& operator=(TritonXLAConvertUnsupportedTypesPassBase &&) = delete;
  ~TritonXLAConvertUnsupportedTypesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("convert-unsupported-types");
  }
  ::llvm::StringRef getArgument() const override { return "convert-unsupported-types"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Converts types unsupported by Triton into their supported equivalents.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAConvertUnsupportedTypesPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAConvertUnsupportedTypesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAConvertUnsupportedTypesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLAExtractInsertToTritonPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAExtractInsertToTritonPassBase;

  TritonXLAExtractInsertToTritonPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAExtractInsertToTritonPassBase(const TritonXLAExtractInsertToTritonPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAExtractInsertToTritonPassBase& operator=(const TritonXLAExtractInsertToTritonPassBase &) = delete;
  TritonXLAExtractInsertToTritonPassBase(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  TritonXLAExtractInsertToTritonPassBase& operator=(TritonXLAExtractInsertToTritonPassBase &&) = delete;
  ~TritonXLAExtractInsertToTritonPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-extract-insert-to-triton");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-extract-insert-to-triton"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Convert Triton XLA extract and insert ops to Triton ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAExtractInsertToTritonPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAExtractInsertToTritonPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<triton::TritonDialect>();
    registry.insert<::xla::XlaDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAExtractInsertToTritonPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> allow_tma_{*this, "allow_tma", ::llvm::cl::desc(R"PO(Whether to permit lowering to TMA.)PO"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<int> num_stages_{*this, "num_stages", ::llvm::cl::desc(R"PO(Number of stages for pipelining.)PO"), ::llvm::cl::init(1)};
};

template <typename DerivedT>
class TritonXLAFoldTransposePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAFoldTransposePassBase;

  TritonXLAFoldTransposePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAFoldTransposePassBase(const TritonXLAFoldTransposePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAFoldTransposePassBase& operator=(const TritonXLAFoldTransposePassBase &) = delete;
  TritonXLAFoldTransposePassBase(TritonXLAFoldTransposePassBase &&) = delete;
  TritonXLAFoldTransposePassBase& operator=(TritonXLAFoldTransposePassBase &&) = delete;
  ~TritonXLAFoldTransposePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-fold-transpose");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-fold-transpose"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Folds transposes into loads.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAFoldTransposePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAFoldTransposePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAFoldTransposePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerAtomicsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerAtomicsPassBase;

  TritonXLALowerAtomicsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerAtomicsPassBase(const TritonXLALowerAtomicsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerAtomicsPassBase& operator=(const TritonXLALowerAtomicsPassBase &) = delete;
  TritonXLALowerAtomicsPassBase(TritonXLALowerAtomicsPassBase &&) = delete;
  TritonXLALowerAtomicsPassBase& operator=(TritonXLALowerAtomicsPassBase &&) = delete;
  ~TritonXLALowerAtomicsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-atomics");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-atomics"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower triton_xla.atomic operations.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerAtomicsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerAtomicsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerAtomicsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerBlockBarrierPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerBlockBarrierPassBase;

  TritonXLALowerBlockBarrierPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerBlockBarrierPassBase(const TritonXLALowerBlockBarrierPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerBlockBarrierPassBase& operator=(const TritonXLALowerBlockBarrierPassBase &) = delete;
  TritonXLALowerBlockBarrierPassBase(TritonXLALowerBlockBarrierPassBase &&) = delete;
  TritonXLALowerBlockBarrierPassBase& operator=(TritonXLALowerBlockBarrierPassBase &&) = delete;
  ~TritonXLALowerBlockBarrierPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-block-barrier");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-block-barrier"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower a block barrier to triton_xla/triton operations.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerBlockBarrierPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerBlockBarrierPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerBlockBarrierPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerGetTidPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerGetTidPassBase;

  TritonXLALowerGetTidPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerGetTidPassBase(const TritonXLALowerGetTidPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerGetTidPassBase& operator=(const TritonXLALowerGetTidPassBase &) = delete;
  TritonXLALowerGetTidPassBase(TritonXLALowerGetTidPassBase &&) = delete;
  TritonXLALowerGetTidPassBase& operator=(TritonXLALowerGetTidPassBase &&) = delete;
  ~TritonXLALowerGetTidPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-get-tid");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-get-tid"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower get_tid to the PTX intrinsic.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerGetTidPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerGetTidPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerGetTidPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerRemoteAccessPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerRemoteAccessPassBase;

  TritonXLALowerRemoteAccessPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerRemoteAccessPassBase(const TritonXLALowerRemoteAccessPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerRemoteAccessPassBase& operator=(const TritonXLALowerRemoteAccessPassBase &) = delete;
  TritonXLALowerRemoteAccessPassBase(TritonXLALowerRemoteAccessPassBase &&) = delete;
  TritonXLALowerRemoteAccessPassBase& operator=(TritonXLALowerRemoteAccessPassBase &&) = delete;
  ~TritonXLALowerRemoteAccessPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-remote-access");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-remote-access"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lower triton_xla.get_rank/get_peer operations used to remote access kernels.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerRemoteAccessPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerRemoteAccessPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerRemoteAccessPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLALowerXTilePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLALowerXTilePassBase;

  TritonXLALowerXTilePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLALowerXTilePassBase(const TritonXLALowerXTilePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLALowerXTilePassBase& operator=(const TritonXLALowerXTilePassBase &) = delete;
  TritonXLALowerXTilePassBase(TritonXLALowerXTilePassBase &&) = delete;
  TritonXLALowerXTilePassBase& operator=(TritonXLALowerXTilePassBase &&) = delete;
  ~TritonXLALowerXTilePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-lower-xtile");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-lower-xtile"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers xtile ops to Triton ops.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLALowerXTilePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLALowerXTilePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::memref::MemRefDialect>();
    registry.insert<mlir::triton::xla::XlaTritonDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLALowerXTilePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class TritonXLAMathToLibdevicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAMathToLibdevicePassBase;

  TritonXLAMathToLibdevicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAMathToLibdevicePassBase(const TritonXLAMathToLibdevicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAMathToLibdevicePassBase& operator=(const TritonXLAMathToLibdevicePassBase &) = delete;
  TritonXLAMathToLibdevicePassBase(TritonXLAMathToLibdevicePassBase &&) = delete;
  TritonXLAMathToLibdevicePassBase& operator=(TritonXLAMathToLibdevicePassBase &&) = delete;
  ~TritonXLAMathToLibdevicePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-math-to-libdevice");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-math-to-libdevice"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Lowers math operations to tt.extern_elementwise calls to their libdevice equivalent.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAMathToLibdevicePass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAMathToLibdevicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<tensor::TensorDialect>();
    registry.insert<triton::TritonDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAMathToLibdevicePassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<std::string> libdevice_path_{*this, "libdevice_path", ::llvm::cl::desc(R"PO(Path to the libdevice library.)PO")};
  ::mlir::Pass::Option<std::string> triple_string_{*this, "triple", ::llvm::cl::desc(R"PO(Device triple string.)PO")};
};

template <typename DerivedT>
class TritonXLASqueezeDimsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLASqueezeDimsPassBase;

  TritonXLASqueezeDimsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLASqueezeDimsPassBase(const TritonXLASqueezeDimsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLASqueezeDimsPassBase& operator=(const TritonXLASqueezeDimsPassBase &) = delete;
  TritonXLASqueezeDimsPassBase(TritonXLASqueezeDimsPassBase &&) = delete;
  TritonXLASqueezeDimsPassBase& operator=(TritonXLASqueezeDimsPassBase &&) = delete;
  ~TritonXLASqueezeDimsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-squeeze-dims");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-squeeze-dims"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Remove superfluous size-1 dimensions.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLASqueezeDimsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLASqueezeDimsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<::mlir::triton::xla::XlaTritonDialect>();
    registry.insert<::mlir::triton::TritonDialect>();
    registry.insert<::xla::xtile::XTileDialect>();
    registry.insert<::mlir::memref::MemRefDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLASqueezeDimsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> finalize_{*this, "finalize", ::llvm::cl::desc(R"PO(Convert squeeze_dims back to reshape. Disable for testing only.)PO"), ::llvm::cl::init(true)};
};

template <typename DerivedT>
class TritonXLAUnswitchLoopsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = TritonXLAUnswitchLoopsPassBase;

  TritonXLAUnswitchLoopsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  TritonXLAUnswitchLoopsPassBase(const TritonXLAUnswitchLoopsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  TritonXLAUnswitchLoopsPassBase& operator=(const TritonXLAUnswitchLoopsPassBase &) = delete;
  TritonXLAUnswitchLoopsPassBase(TritonXLAUnswitchLoopsPassBase &&) = delete;
  TritonXLAUnswitchLoopsPassBase& operator=(TritonXLAUnswitchLoopsPassBase &&) = delete;
  ~TritonXLAUnswitchLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("triton-xla-unswitch-loops");
  }
  ::llvm::StringRef getArgument() const override { return "triton-xla-unswitch-loops"; }

  ::llvm::StringRef getDescription() const override { return R"PD(Hoists scf.if out of scf.for.)PD"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("TritonXLAUnswitchLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "TritonXLAUnswitchLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(TritonXLAUnswitchLoopsPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
