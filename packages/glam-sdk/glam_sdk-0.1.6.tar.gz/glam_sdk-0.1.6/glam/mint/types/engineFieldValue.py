'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import BorshPubkey, EnumForCodegen
from construct import Construct
from dataclasses import dataclass
from solders.pubkey import Pubkey as SolPubkey
from . import accruedFees, delegateAcl, feeParams, feeStructure, integrationAcl, notifyAndSettle, oracleConfigs

class BooleanJSONValue(typing.TypedDict):
    val: bool

class BooleanValue(typing.TypedDict):
    val: bool




class BooleanJSON(typing.TypedDict):
    kind: typing.Literal["Boolean"]
    value: BooleanJSONValue


@dataclass
class Boolean:
    discriminator: typing.ClassVar = 0
    value : BooleanValue
    def to_json(self) -> BooleanJSON:
        return BooleanJSON(
            kind="Boolean",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Boolean":{ "val":self.value["val"] }
            }



class U8JSONValue(typing.TypedDict):
    val: int

class U8Value(typing.TypedDict):
    val: int




class U8JSON(typing.TypedDict):
    kind: typing.Literal["U8"]
    value: U8JSONValue


@dataclass
class U8:
    discriminator: typing.ClassVar = 1
    value : U8Value
    def to_json(self) -> U8JSON:
        return U8JSON(
            kind="U8",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "U8":{ "val":self.value["val"] }
            }



class U32JSONValue(typing.TypedDict):
    val: int

class U32Value(typing.TypedDict):
    val: int




class U32JSON(typing.TypedDict):
    kind: typing.Literal["U32"]
    value: U32JSONValue


@dataclass
class U32:
    discriminator: typing.ClassVar = 2
    value : U32Value
    def to_json(self) -> U32JSON:
        return U32JSON(
            kind="U32",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "U32":{ "val":self.value["val"] }
            }



class U64JSONValue(typing.TypedDict):
    val: int

class U64Value(typing.TypedDict):
    val: int




class U64JSON(typing.TypedDict):
    kind: typing.Literal["U64"]
    value: U64JSONValue


@dataclass
class U64:
    discriminator: typing.ClassVar = 3
    value : U64Value
    def to_json(self) -> U64JSON:
        return U64JSON(
            kind="U64",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "U64":{ "val":self.value["val"] }
            }



class StringJSONValue(typing.TypedDict):
    val: str

class StringValue(typing.TypedDict):
    val: str




class StringJSON(typing.TypedDict):
    kind: typing.Literal["String"]
    value: StringJSONValue


@dataclass
class String:
    discriminator: typing.ClassVar = 4
    value : StringValue
    def to_json(self) -> StringJSON:
        return StringJSON(
            kind="String",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "String":{ "val":self.value["val"] }
            }



class PubkeyJSONValue(typing.TypedDict):
    val: str

class PubkeyValue(typing.TypedDict):
    val: SolPubkey




class PubkeyJSON(typing.TypedDict):
    kind: typing.Literal["Pubkey"]
    value: PubkeyJSONValue


@dataclass
class Pubkey:
    discriminator: typing.ClassVar = 5
    value : PubkeyValue
    def to_json(self) -> PubkeyJSON:
        return PubkeyJSON(
            kind="Pubkey",
            value = {
            "val":str(self.value["val"])
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Pubkey":{ "val":self.value["val"] }
            }



class VecPubkeyJSONValue(typing.TypedDict):
    val: list[str]

class VecPubkeyValue(typing.TypedDict):
    val: list[SolPubkey]




class VecPubkeyJSON(typing.TypedDict):
    kind: typing.Literal["VecPubkey"]
    value: VecPubkeyJSONValue


@dataclass
class VecPubkey:
    discriminator: typing.ClassVar = 6
    value : VecPubkeyValue
    def to_json(self) -> VecPubkeyJSON:
        return VecPubkeyJSON(
            kind="VecPubkey",
            value = {
            "val":list(map(lambda item:str(item),self.value["val"]))
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "VecPubkey":{ "val": }
            }



class VecU8JSONValue(typing.TypedDict):
    val: list[int]

class VecU8Value(typing.TypedDict):
    val: borsh.Bytes




class VecU8JSON(typing.TypedDict):
    kind: typing.Literal["VecU8"]
    value: VecU8JSONValue


@dataclass
class VecU8:
    discriminator: typing.ClassVar = 7
    value : VecU8Value
    def to_json(self) -> VecU8JSON:
        return VecU8JSON(
            kind="VecU8",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "VecU8":{ "val":self.value["val"] }
            }



class VecU32JSONValue(typing.TypedDict):
    val: list[int]

class VecU32Value(typing.TypedDict):
    val: list[int]




class VecU32JSON(typing.TypedDict):
    kind: typing.Literal["VecU32"]
    value: VecU32JSONValue


@dataclass
class VecU32:
    discriminator: typing.ClassVar = 8
    value : VecU32Value
    def to_json(self) -> VecU32JSON:
        return VecU32JSON(
            kind="VecU32",
            value = {
            "val":self.value["val"]
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "VecU32":{ "val":self.value["val"] }
            }



class VecDelegateAclJSONValue(typing.TypedDict):
    val: list[delegateAcl.DelegateAclJSON]

class VecDelegateAclValue(typing.TypedDict):
    val: list[delegateAcl.DelegateAcl]




class VecDelegateAclJSON(typing.TypedDict):
    kind: typing.Literal["VecDelegateAcl"]
    value: VecDelegateAclJSONValue


@dataclass
class VecDelegateAcl:
    discriminator: typing.ClassVar = 9
    value : VecDelegateAclValue
    def to_json(self) -> VecDelegateAclJSON:
        return VecDelegateAclJSON(
            kind="VecDelegateAcl",
            value = {
            "val":list(map(lambda item:item.to_json(),self.value["val"]))
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "VecDelegateAcl":{ "val":list(map(lambda item:item.to_encodable(),self.value["val"])) }
            }



class VecIntegrationAclJSONValue(typing.TypedDict):
    val: list[integrationAcl.IntegrationAclJSON]

class VecIntegrationAclValue(typing.TypedDict):
    val: list[integrationAcl.IntegrationAcl]




class VecIntegrationAclJSON(typing.TypedDict):
    kind: typing.Literal["VecIntegrationAcl"]
    value: VecIntegrationAclJSONValue


@dataclass
class VecIntegrationAcl:
    discriminator: typing.ClassVar = 10
    value : VecIntegrationAclValue
    def to_json(self) -> VecIntegrationAclJSON:
        return VecIntegrationAclJSON(
            kind="VecIntegrationAcl",
            value = {
            "val":list(map(lambda item:item.to_json(),self.value["val"]))
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "VecIntegrationAcl":{ "val":list(map(lambda item:item.to_encodable(),self.value["val"])) }
            }



class FeeStructureJSONValue(typing.TypedDict):
    val: feeStructure.FeeStructureJSON

class FeeStructureValue(typing.TypedDict):
    val: feeStructure.FeeStructure




class FeeStructureJSON(typing.TypedDict):
    kind: typing.Literal["FeeStructure"]
    value: FeeStructureJSONValue


@dataclass
class FeeStructure:
    discriminator: typing.ClassVar = 11
    value : FeeStructureValue
    def to_json(self) -> FeeStructureJSON:
        return FeeStructureJSON(
            kind="FeeStructure",
            value = {
            "val":self.value["val"].to_json()
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FeeStructure":{ "val":self.value["val"].to_encodable() }
            }



class FeeParamsJSONValue(typing.TypedDict):
    val: feeParams.FeeParamsJSON

class FeeParamsValue(typing.TypedDict):
    val: feeParams.FeeParams




class FeeParamsJSON(typing.TypedDict):
    kind: typing.Literal["FeeParams"]
    value: FeeParamsJSONValue


@dataclass
class FeeParams:
    discriminator: typing.ClassVar = 12
    value : FeeParamsValue
    def to_json(self) -> FeeParamsJSON:
        return FeeParamsJSON(
            kind="FeeParams",
            value = {
            "val":self.value["val"].to_json()
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FeeParams":{ "val":self.value["val"].to_encodable() }
            }



class AccruedFeesJSONValue(typing.TypedDict):
    val: accruedFees.AccruedFeesJSON

class AccruedFeesValue(typing.TypedDict):
    val: accruedFees.AccruedFees




class AccruedFeesJSON(typing.TypedDict):
    kind: typing.Literal["AccruedFees"]
    value: AccruedFeesJSONValue


@dataclass
class AccruedFees:
    discriminator: typing.ClassVar = 13
    value : AccruedFeesValue
    def to_json(self) -> AccruedFeesJSON:
        return AccruedFeesJSON(
            kind="AccruedFees",
            value = {
            "val":self.value["val"].to_json()
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "AccruedFees":{ "val":self.value["val"].to_encodable() }
            }



class NotifyAndSettleJSONValue(typing.TypedDict):
    val: notifyAndSettle.NotifyAndSettleJSON

class NotifyAndSettleValue(typing.TypedDict):
    val: notifyAndSettle.NotifyAndSettle




class NotifyAndSettleJSON(typing.TypedDict):
    kind: typing.Literal["NotifyAndSettle"]
    value: NotifyAndSettleJSONValue


@dataclass
class NotifyAndSettle:
    discriminator: typing.ClassVar = 14
    value : NotifyAndSettleValue
    def to_json(self) -> NotifyAndSettleJSON:
        return NotifyAndSettleJSON(
            kind="NotifyAndSettle",
            value = {
            "val":self.value["val"].to_json()
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "NotifyAndSettle":{ "val":self.value["val"].to_encodable() }
            }



class OracleConfigsJSONValue(typing.TypedDict):
    val: oracleConfigs.OracleConfigsJSON

class OracleConfigsValue(typing.TypedDict):
    val: oracleConfigs.OracleConfigs




class OracleConfigsJSON(typing.TypedDict):
    kind: typing.Literal["OracleConfigs"]
    value: OracleConfigsJSONValue


@dataclass
class OracleConfigs:
    discriminator: typing.ClassVar = 15
    value : OracleConfigsValue
    def to_json(self) -> OracleConfigsJSON:
        return OracleConfigsJSON(
            kind="OracleConfigs",
            value = {
            "val":self.value["val"].to_json()
            }
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OracleConfigs":{ "val":self.value["val"].to_encodable() }
            }





EngineFieldValueKind = typing.Union[
    Boolean,
    U8,
    U32,
    U64,
    String,
    Pubkey,
    VecPubkey,
    VecU8,
    VecU32,
    VecDelegateAcl,
    VecIntegrationAcl,
    FeeStructure,
    FeeParams,
    AccruedFees,
    NotifyAndSettle,
    OracleConfigs,
]
EngineFieldValueJSON = typing.Union[
    BooleanJSON,
    U8JSON,
    U32JSON,
    U64JSON,
    StringJSON,
    PubkeyJSON,
    VecPubkeyJSON,
    VecU8JSON,
    VecU32JSON,
    VecDelegateAclJSON,
    VecIntegrationAclJSON,
    FeeStructureJSON,
    FeeParamsJSON,
    AccruedFeesJSON,
    NotifyAndSettleJSON,
    OracleConfigsJSON,
]

def from_decoded(obj: dict) -> EngineFieldValueKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Boolean" in obj:
      val = obj["Boolean"]
      return Boolean(
            BooleanValue(
                val= val["val"]
            )
        )

    if "U8" in obj:
      val = obj["U8"]
      return U8(
            U8Value(
                val= val["val"]
            )
        )

    if "U32" in obj:
      val = obj["U32"]
      return U32(
            U32Value(
                val= val["val"]
            )
        )

    if "U64" in obj:
      val = obj["U64"]
      return U64(
            U64Value(
                val= val["val"]
            )
        )

    if "String" in obj:
      val = obj["String"]
      return String(
            StringValue(
                val= val["val"]
            )
        )

    if "Pubkey" in obj:
      val = obj["Pubkey"]
      return Pubkey(
            PubkeyValue(
                val= val["val"]
            )
        )

    if "VecPubkey" in obj:
      val = obj["VecPubkey"]
      return VecPubkey(
            VecPubkeyValue(
                val= list(map(lambda item:SolPubkey.from_string(item),val["val"]))
            )
        )

    if "VecU8" in obj:
      val = obj["VecU8"]
      return VecU8(
            VecU8Value(
                val= val["val"]
            )
        )

    if "VecU32" in obj:
      val = obj["VecU32"]
      return VecU32(
            VecU32Value(
                val= val["val"]
            )
        )

    if "VecDelegateAcl" in obj:
      val = obj["VecDelegateAcl"]
      return VecDelegateAcl(
            VecDelegateAclValue(
                val= list(map(lambda item:delegateAcl.DelegateAcl.from_json(item),val["val"]))
            )
        )

    if "VecIntegrationAcl" in obj:
      val = obj["VecIntegrationAcl"]
      return VecIntegrationAcl(
            VecIntegrationAclValue(
                val= list(map(lambda item:integrationAcl.IntegrationAcl.from_json(item),val["val"]))
            )
        )

    if "FeeStructure" in obj:
      val = obj["FeeStructure"]
      return FeeStructure(
            FeeStructureValue(
                val= feeStructure.FeeStructure.from_decoded(val["val"])
            )
        )

    if "FeeParams" in obj:
      val = obj["FeeParams"]
      return FeeParams(
            FeeParamsValue(
                val= feeParams.FeeParams.from_decoded(val["val"])
            )
        )

    if "AccruedFees" in obj:
      val = obj["AccruedFees"]
      return AccruedFees(
            AccruedFeesValue(
                val= accruedFees.AccruedFees.from_decoded(val["val"])
            )
        )

    if "NotifyAndSettle" in obj:
      val = obj["NotifyAndSettle"]
      return NotifyAndSettle(
            NotifyAndSettleValue(
                val= notifyAndSettle.NotifyAndSettle.from_decoded(val["val"])
            )
        )

    if "OracleConfigs" in obj:
      val = obj["OracleConfigs"]
      return OracleConfigs(
            OracleConfigsValue(
                val= oracleConfigs.OracleConfigs.from_decoded(val["val"])
            )
        )

    raise ValueError("Invalid enum object")

def from_json(obj: EngineFieldValueJSON) -> EngineFieldValueKind:
    if obj["kind"] == "Boolean":
        booleanJSONValue = typing.cast(BooleanJSONValue, obj["value"])
        return Boolean(
            BooleanValue(
                val=booleanJSONValue["val"]
            )
        )


    if obj["kind"] == "U8":
        u8JSONValue = typing.cast(U8JSONValue, obj["value"])
        return U8(
            U8Value(
                val=u8JSONValue["val"]
            )
        )


    if obj["kind"] == "U32":
        u32JSONValue = typing.cast(U32JSONValue, obj["value"])
        return U32(
            U32Value(
                val=u32JSONValue["val"]
            )
        )


    if obj["kind"] == "U64":
        u64JSONValue = typing.cast(U64JSONValue, obj["value"])
        return U64(
            U64Value(
                val=u64JSONValue["val"]
            )
        )


    if obj["kind"] == "String":
        stringJSONValue = typing.cast(StringJSONValue, obj["value"])
        return String(
            StringValue(
                val=stringJSONValue["val"]
            )
        )


    if obj["kind"] == "Pubkey":
        pubkeyJSONValue = typing.cast(PubkeyJSONValue, obj["value"])
        return Pubkey(
            PubkeyValue(
                val=SolPubkey.from_string(pubkeyJSONValue["val"])
            )
        )


    if obj["kind"] == "VecPubkey":
        vecPubkeyJSONValue = typing.cast(VecPubkeyJSONValue, obj["value"])
        return VecPubkey(
            VecPubkeyValue(
                val=list(map(lambda item:SolPubkey.from_string(item),vecPubkeyJSONValue["val"]))
            )
        )


    if obj["kind"] == "VecU8":
        vecU8JSONValue = typing.cast(VecU8JSONValue, obj["value"])
        return VecU8(
            VecU8Value(
                val=vecU8JSONValue["val"]
            )
        )


    if obj["kind"] == "VecU32":
        vecU32JSONValue = typing.cast(VecU32JSONValue, obj["value"])
        return VecU32(
            VecU32Value(
                val=vecU32JSONValue["val"]
            )
        )


    if obj["kind"] == "VecDelegateAcl":
        vecDelegateAclJSONValue = typing.cast(VecDelegateAclJSONValue, obj["value"])
        return VecDelegateAcl(
            VecDelegateAclValue(
                val=list(map(lambda item:delegateAcl.DelegateAcl.from_json(item),vecDelegateAclJSONValue["val"]))
            )
        )


    if obj["kind"] == "VecIntegrationAcl":
        vecIntegrationAclJSONValue = typing.cast(VecIntegrationAclJSONValue, obj["value"])
        return VecIntegrationAcl(
            VecIntegrationAclValue(
                val=list(map(lambda item:integrationAcl.IntegrationAcl.from_json(item),vecIntegrationAclJSONValue["val"]))
            )
        )


    if obj["kind"] == "FeeStructure":
        feeStructureJSONValue = typing.cast(FeeStructureJSONValue, obj["value"])
        return FeeStructure(
            FeeStructureValue(
                val=feeStructure.FeeStructure.from_json(feeStructureJSONValue["val"])
            )
        )


    if obj["kind"] == "FeeParams":
        feeParamsJSONValue = typing.cast(FeeParamsJSONValue, obj["value"])
        return FeeParams(
            FeeParamsValue(
                val=feeParams.FeeParams.from_json(feeParamsJSONValue["val"])
            )
        )


    if obj["kind"] == "AccruedFees":
        accruedFeesJSONValue = typing.cast(AccruedFeesJSONValue, obj["value"])
        return AccruedFees(
            AccruedFeesValue(
                val=accruedFees.AccruedFees.from_json(accruedFeesJSONValue["val"])
            )
        )


    if obj["kind"] == "NotifyAndSettle":
        notifyAndSettleJSONValue = typing.cast(NotifyAndSettleJSONValue, obj["value"])
        return NotifyAndSettle(
            NotifyAndSettleValue(
                val=notifyAndSettle.NotifyAndSettle.from_json(notifyAndSettleJSONValue["val"])
            )
        )


    if obj["kind"] == "OracleConfigs":
        oracleConfigsJSONValue = typing.cast(OracleConfigsJSONValue, obj["value"])
        return OracleConfigs(
            OracleConfigsValue(
                val=oracleConfigs.OracleConfigs.from_json(oracleConfigsJSONValue["val"])
            )
        )


    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"Boolean" / borsh.CStruct("val" /borsh.Bool),
"U8" / borsh.CStruct("val" /borsh.U8),
"U32" / borsh.CStruct("val" /borsh.U32),
"U64" / borsh.CStruct("val" /borsh.U64),
"String" / borsh.CStruct("val" /borsh.String),
"Pubkey" / borsh.CStruct("val" /BorshPubkey),
"VecPubkey" / borsh.CStruct("val" /borsh.Vec(typing.cast(Construct, BorshPubkey))),
"VecU8" / borsh.CStruct("val" /borsh.Bytes),
"VecU32" / borsh.CStruct("val" /borsh.Vec(typing.cast(Construct, borsh.U32))),
"VecDelegateAcl" / borsh.CStruct("val" /borsh.Vec(typing.cast(Construct, delegateAcl.DelegateAcl.layout))),
"VecIntegrationAcl" / borsh.CStruct("val" /borsh.Vec(typing.cast(Construct, integrationAcl.IntegrationAcl.layout))),
"FeeStructure" / borsh.CStruct("val" /feeStructure.FeeStructure.layout),
"FeeParams" / borsh.CStruct("val" /feeParams.FeeParams.layout),
"AccruedFees" / borsh.CStruct("val" /accruedFees.AccruedFees.layout),
"NotifyAndSettle" / borsh.CStruct("val" /notifyAndSettle.NotifyAndSettle.layout),
"OracleConfigs" / borsh.CStruct("val" /oracleConfigs.OracleConfigs.layout),
)
