'''
    This code was AUTOGENERATED using the codama library.
    Please DO NOT EDIT THIS FILE, instead use visitors
    to add features, then rerun codama to update it.
    @see https://github.com/codama-idl/codama
'''

import borsh_construct as borsh
import typing
from anchorpy.borsh_extension import EnumForCodegen
from dataclasses import dataclass


class OwnerJSON(typing.TypedDict):
    kind: typing.Literal["Owner"]


@dataclass
class Owner:
    discriminator: typing.ClassVar = 0
    def to_json(self) -> OwnerJSON:
        return OwnerJSON(
            kind="Owner",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Owner": {},
        }




class PortfolioManagerNameJSON(typing.TypedDict):
    kind: typing.Literal["PortfolioManagerName"]


@dataclass
class PortfolioManagerName:
    discriminator: typing.ClassVar = 1
    def to_json(self) -> PortfolioManagerNameJSON:
        return PortfolioManagerNameJSON(
            kind="PortfolioManagerName",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PortfolioManagerName": {},
        }




class NameJSON(typing.TypedDict):
    kind: typing.Literal["Name"]


@dataclass
class Name:
    discriminator: typing.ClassVar = 2
    def to_json(self) -> NameJSON:
        return NameJSON(
            kind="Name",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Name": {},
        }




class UriJSON(typing.TypedDict):
    kind: typing.Literal["Uri"]


@dataclass
class Uri:
    discriminator: typing.ClassVar = 3
    def to_json(self) -> UriJSON:
        return UriJSON(
            kind="Uri",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Uri": {},
        }




class AssetsJSON(typing.TypedDict):
    kind: typing.Literal["Assets"]


@dataclass
class Assets:
    discriminator: typing.ClassVar = 4
    def to_json(self) -> AssetsJSON:
        return AssetsJSON(
            kind="Assets",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Assets": {},
        }




class DelegateAclsJSON(typing.TypedDict):
    kind: typing.Literal["DelegateAcls"]


@dataclass
class DelegateAcls:
    discriminator: typing.ClassVar = 5
    def to_json(self) -> DelegateAclsJSON:
        return DelegateAclsJSON(
            kind="DelegateAcls",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "DelegateAcls": {},
        }




class IntegrationAclsJSON(typing.TypedDict):
    kind: typing.Literal["IntegrationAcls"]


@dataclass
class IntegrationAcls:
    discriminator: typing.ClassVar = 6
    def to_json(self) -> IntegrationAclsJSON:
        return IntegrationAclsJSON(
            kind="IntegrationAcls",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "IntegrationAcls": {},
        }




class TimelockDurationJSON(typing.TypedDict):
    kind: typing.Literal["TimelockDuration"]


@dataclass
class TimelockDuration:
    discriminator: typing.ClassVar = 7
    def to_json(self) -> TimelockDurationJSON:
        return TimelockDurationJSON(
            kind="TimelockDuration",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "TimelockDuration": {},
        }




class BorrowableJSON(typing.TypedDict):
    kind: typing.Literal["Borrowable"]


@dataclass
class Borrowable:
    discriminator: typing.ClassVar = 8
    def to_json(self) -> BorrowableJSON:
        return BorrowableJSON(
            kind="Borrowable",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "Borrowable": {},
        }




class DefaultAccountStateFrozenJSON(typing.TypedDict):
    kind: typing.Literal["DefaultAccountStateFrozen"]


@dataclass
class DefaultAccountStateFrozen:
    discriminator: typing.ClassVar = 9
    def to_json(self) -> DefaultAccountStateFrozenJSON:
        return DefaultAccountStateFrozenJSON(
            kind="DefaultAccountStateFrozen",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "DefaultAccountStateFrozen": {},
        }




class PermanentDelegateJSON(typing.TypedDict):
    kind: typing.Literal["PermanentDelegate"]


@dataclass
class PermanentDelegate:
    discriminator: typing.ClassVar = 10
    def to_json(self) -> PermanentDelegateJSON:
        return PermanentDelegateJSON(
            kind="PermanentDelegate",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "PermanentDelegate": {},
        }




class NotifyAndSettleJSON(typing.TypedDict):
    kind: typing.Literal["NotifyAndSettle"]


@dataclass
class NotifyAndSettle:
    discriminator: typing.ClassVar = 11
    def to_json(self) -> NotifyAndSettleJSON:
        return NotifyAndSettleJSON(
            kind="NotifyAndSettle",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "NotifyAndSettle": {},
        }




class FeeStructureJSON(typing.TypedDict):
    kind: typing.Literal["FeeStructure"]


@dataclass
class FeeStructure:
    discriminator: typing.ClassVar = 12
    def to_json(self) -> FeeStructureJSON:
        return FeeStructureJSON(
            kind="FeeStructure",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FeeStructure": {},
        }




class FeeParamsJSON(typing.TypedDict):
    kind: typing.Literal["FeeParams"]


@dataclass
class FeeParams:
    discriminator: typing.ClassVar = 13
    def to_json(self) -> FeeParamsJSON:
        return FeeParamsJSON(
            kind="FeeParams",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "FeeParams": {},
        }




class ClaimableFeesJSON(typing.TypedDict):
    kind: typing.Literal["ClaimableFees"]


@dataclass
class ClaimableFees:
    discriminator: typing.ClassVar = 14
    def to_json(self) -> ClaimableFeesJSON:
        return ClaimableFeesJSON(
            kind="ClaimableFees",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "ClaimableFees": {},
        }




class ClaimedFeesJSON(typing.TypedDict):
    kind: typing.Literal["ClaimedFees"]


@dataclass
class ClaimedFees:
    discriminator: typing.ClassVar = 15
    def to_json(self) -> ClaimedFeesJSON:
        return ClaimedFeesJSON(
            kind="ClaimedFees",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "ClaimedFees": {},
        }




class OracleConfigsJSON(typing.TypedDict):
    kind: typing.Literal["OracleConfigs"]


@dataclass
class OracleConfigs:
    discriminator: typing.ClassVar = 16
    def to_json(self) -> OracleConfigsJSON:
        return OracleConfigsJSON(
            kind="OracleConfigs",
        )

    def to_encodable(self) -> dict[str, typing.Any]:
        return {
            "OracleConfigs": {},
        }





EngineFieldNameKind = typing.Union[
    Owner,
    PortfolioManagerName,
    Name,
    Uri,
    Assets,
    DelegateAcls,
    IntegrationAcls,
    TimelockDuration,
    Borrowable,
    DefaultAccountStateFrozen,
    PermanentDelegate,
    NotifyAndSettle,
    FeeStructure,
    FeeParams,
    ClaimableFees,
    ClaimedFees,
    OracleConfigs,
]
EngineFieldNameJSON = typing.Union[
    OwnerJSON,
    PortfolioManagerNameJSON,
    NameJSON,
    UriJSON,
    AssetsJSON,
    DelegateAclsJSON,
    IntegrationAclsJSON,
    TimelockDurationJSON,
    BorrowableJSON,
    DefaultAccountStateFrozenJSON,
    PermanentDelegateJSON,
    NotifyAndSettleJSON,
    FeeStructureJSON,
    FeeParamsJSON,
    ClaimableFeesJSON,
    ClaimedFeesJSON,
    OracleConfigsJSON,
]

def from_decoded(obj: dict) -> EngineFieldNameKind:
    if not isinstance(obj, dict):
        raise ValueError("Invalid enum object")
    if "Owner" in obj:
      return Owner()
    if "PortfolioManagerName" in obj:
      return PortfolioManagerName()
    if "Name" in obj:
      return Name()
    if "Uri" in obj:
      return Uri()
    if "Assets" in obj:
      return Assets()
    if "DelegateAcls" in obj:
      return DelegateAcls()
    if "IntegrationAcls" in obj:
      return IntegrationAcls()
    if "TimelockDuration" in obj:
      return TimelockDuration()
    if "Borrowable" in obj:
      return Borrowable()
    if "DefaultAccountStateFrozen" in obj:
      return DefaultAccountStateFrozen()
    if "PermanentDelegate" in obj:
      return PermanentDelegate()
    if "NotifyAndSettle" in obj:
      return NotifyAndSettle()
    if "FeeStructure" in obj:
      return FeeStructure()
    if "FeeParams" in obj:
      return FeeParams()
    if "ClaimableFees" in obj:
      return ClaimableFees()
    if "ClaimedFees" in obj:
      return ClaimedFees()
    if "OracleConfigs" in obj:
      return OracleConfigs()
    raise ValueError("Invalid enum object")

def from_json(obj: EngineFieldNameJSON) -> EngineFieldNameKind:
    if obj["kind"] == "Owner":
        return Owner()

    if obj["kind"] == "PortfolioManagerName":
        return PortfolioManagerName()

    if obj["kind"] == "Name":
        return Name()

    if obj["kind"] == "Uri":
        return Uri()

    if obj["kind"] == "Assets":
        return Assets()

    if obj["kind"] == "DelegateAcls":
        return DelegateAcls()

    if obj["kind"] == "IntegrationAcls":
        return IntegrationAcls()

    if obj["kind"] == "TimelockDuration":
        return TimelockDuration()

    if obj["kind"] == "Borrowable":
        return Borrowable()

    if obj["kind"] == "DefaultAccountStateFrozen":
        return DefaultAccountStateFrozen()

    if obj["kind"] == "PermanentDelegate":
        return PermanentDelegate()

    if obj["kind"] == "NotifyAndSettle":
        return NotifyAndSettle()

    if obj["kind"] == "FeeStructure":
        return FeeStructure()

    if obj["kind"] == "FeeParams":
        return FeeParams()

    if obj["kind"] == "ClaimableFees":
        return ClaimableFees()

    if obj["kind"] == "ClaimedFees":
        return ClaimedFees()

    if obj["kind"] == "OracleConfigs":
        return OracleConfigs()

    kind = obj["kind"]
    raise ValueError(f"Unrecognized enum kind: {kind}")


layout = EnumForCodegen(
"Owner" / borsh.CStruct(),
"PortfolioManagerName" / borsh.CStruct(),
"Name" / borsh.CStruct(),
"Uri" / borsh.CStruct(),
"Assets" / borsh.CStruct(),
"DelegateAcls" / borsh.CStruct(),
"IntegrationAcls" / borsh.CStruct(),
"TimelockDuration" / borsh.CStruct(),
"Borrowable" / borsh.CStruct(),
"DefaultAccountStateFrozen" / borsh.CStruct(),
"PermanentDelegate" / borsh.CStruct(),
"NotifyAndSettle" / borsh.CStruct(),
"FeeStructure" / borsh.CStruct(),
"FeeParams" / borsh.CStruct(),
"ClaimableFees" / borsh.CStruct(),
"ClaimedFees" / borsh.CStruct(),
"OracleConfigs" / borsh.CStruct(),
)
