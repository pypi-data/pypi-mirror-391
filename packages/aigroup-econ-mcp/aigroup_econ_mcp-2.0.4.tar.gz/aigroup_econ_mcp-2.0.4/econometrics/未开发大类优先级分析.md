# AIGroup Econometrics MCP 未开发大类优先级分析

## 项目现状概览

根据项目结构和测试报告分析，当前已开发 **49个计量经济学工具**，涵盖以下主要类别：

### 已开发工具类别统计

| 类别 | 工具数量 | 状态 |
|------|----------|------|
| **基础参数估计** | 3个 | ✅ 已开发 |
| **因果推断方法** | 13个 | ✅ 已开发 |
| **机器学习方法** | 8个 | ✅ 已开发 |
| **微观计量模型** | 7个 | ✅ 已开发 |
| **模型规范与诊断** | 7个 | ✅ 已开发 |
| **时间序列与面板数据** | 11个 | ✅ 已开发 |
| **总计** | **49个** | ✅ 已开发 |

## 未开发大类识别

根据 README.md 中的分类体系，识别出以下尚未开发的大类：

### 1. 空间计量经济学 (SPATIAL ECONOMETRICS) - 高优先级

**核心问题**: 处理数据的空间依赖性和空间异质性

**主要方法**:
- 空间权重矩阵构建（邻接、距离、K近邻矩阵）
- 空间自相关检验（Moran's I、Geary's C、局部空间自相关LISA）
- 空间回归模型（SAR、SEM、SDM、GWR、空间面板数据模型）

**优先级理由**: 
- 在区域经济、地理经济学中应用广泛
- 具有独特的方法论价值
- 实际研究需求强烈

**推荐Python库**:
- `libpysal`: 空间分析核心库
- `spreg`: 空间回归模型
- `esda`: 探索性空间数据分析
- `mgwr`: 地理加权回归

### 2. 非参数与半参数方法 (NONPARAMETRIC & SEMIPARAMETRIC) - 高优先级

**核心问题**: 放宽函数形式的线性或参数化假设

**主要方法**:
- 核回归
- 局部回归
- 样条回归
- 广义可加模型 (GAM)
- 部分线性模型
- 非参数工具变量估计

**优先级理由**:
- 现代计量经济学重要发展方向
- 对函数形式假设要求较低
- 在机器学习交叉领域应用广泛

**推荐Python库**:
- `statsmodels.nonparametric`: 核回归、局部回归
- `scikit-learn`: 样条回归、GAM
- `pygam`: 广义可加模型
- `linearmodels`: 部分线性模型

### 3. 分布分析与分解方法 (DISTRIBUTION ANALYSIS & DECOMPOSITION) - 中优先级

**核心问题**: 分析因变量整个条件分布的特征，而非仅仅条件均值

**主要方法**:
- 分位数回归
- 分解方法（Oaxaca-Blinder、DiNardo-Fortin-Lemieux）
- 方差分解、ANOVA分解
- Shapley值分解
- 时间序列分解（趋势-季节-随机）

**优先级理由**:
- 提供更全面的分布信息
- 在收入不平等、劳动经济学中应用重要
- 与机器学习解释性方法结合

**推荐Python库**:
- `statsmodels.regression.quantile_regression`: 分位数回归
- `linearmodels`: Oaxaca-Blinder分解
- `shap`: Shapley值分解
- `statsmodels.tsa.seasonal`: 时间序列分解

### 4. 统计推断技术 (STATISTICAL INFERENCE TECHNIQUES) - 中优先级

**核心问题**: 在理论分布难以推导或模型复杂时进行可靠推断

**主要方法**:
- 重采样方法（Bootstrap、Pairs Bootstrap、Residual Bootstrap、Wild Bootstrap、Block Bootstrap）
- 模拟方法（蒙特卡洛模拟、置换检验）
- 渐近方法（Delta方法、聚类稳健推断）

**优先级理由**:
- 为复杂模型提供统计推断基础
- 在小样本情况下特别重要
- 现代实证研究的标准工具

**推荐Python库**:
- `scipy.stats.bootstrap`: Bootstrap方法
- `resample`: 重采样工具
- `numpy.random`: 蒙特卡洛模拟
- `scipy.stats.permutation_test`: 置换检验

### 5. 缺失数据与测量误差 (MISSING DATA & MEASUREMENT ERROR) - 中优先级

**核心问题**: 处理数据不完整或变量测量不准确的问题

**主要方法**:
- 缺失数据处理（列表删除、均值插补、回归插补、多重插补MICE/Amelia、EM算法）
- 测量误差（工具变量法、SIMEX方法）

**优先级理由**:
- 实际数据中普遍存在的问题
- 对估计结果有重要影响
- 现代数据处理的关键技术

**推荐Python库**:
- `sklearn.impute`: 缺失值插补
- `statsmodels.imputation`: 多重插补
- `fancyimpute`: 高级插补方法
- `measurement_error`: 测量误差处理

### 6. 生存/持续时间数据 (SURVIVAL/DURATION DATA) - 低优先级

**核心问题**: 分析"事件发生时间"数据并处理右删失

**主要方法**:
- Kaplan-Meier估计量
- Cox比例风险模型
- 加速失效时间模型

**优先级理由**:
- 在特定领域（医学、工程可靠性）应用重要
- 但应用范围相对较窄
- 可与其他工具配合使用

**推荐Python库**:
- `lifelines`: 生存分析库
- `scikit-survival`: 生存分析机器学习
- `statsmodels.duration`: 持续时间模型

## 开发优先级排序

### 第一优先级 (立即开发)
1. **空间计量经济学**
   - 应用广泛，方法论独特
   - 实际研究需求强烈

2. **非参数与半参数方法**
   - 现代计量重要方向
   - 与机器学习交叉应用

### 第二优先级 (中期开发)
3. **分布分析与分解方法**
   - 提供更全面的分析视角
   - 在政策评估中应用重要

4. **统计推断技术**
   - 为其他方法提供统计基础
   - 现代实证研究标准工具

### 第三优先级 (长期开发)
5. **缺失数据与测量误差**
   - 数据处理关键技术
   - 对数据质量影响重要

6. **生存/持续时间数据**
   - 特定领域应用
   - 可与其他工具配合

## 开发规范参考

### 三层架构设计

新工具的开发应严格遵循项目的三层架构：

```
┌─────────────────────────────────────────────────┐
│  MCP工具层 (tools/mcp_tool_groups/)            │
│  - 工具注册和接口定义                           │
│  - 参数验证                                     │
│  - 异步函数封装                                 │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  适配器层 (tools/*_adapter.py)                  │
│  - 数据加载和格式转换                           │
│  - 调用核心算法                                 │
│  - 输出格式化                                   │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│  核心算法层 (econometrics/)                     │
│  - 统计模型实现                                 │
│  - 基于成熟Python库                             │
│  - Pydantic结果模型                             │
└─────────────────────────────────────────────────┘
```

### 1. 核心算法层开发规范

**参考模板**: `econometrics/basic_parametric_estimation/ols/ols_model.py`

#### 核心要点：
```python
"""
方法名称模型实现
"""
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field
import numpy as np
# 导入相关的成熟统计库
import statsmodels.api as sm  # 或其他库

class MethodResult(BaseModel):
    """方法结果的Pydantic模型"""
    # 定义所有输出字段
    coefficients: List[float] = Field(..., description="系数估计")
    std_errors: List[float] = Field(..., description="标准误")
    # ... 其他统计量

def method_analysis(
    # 输入参数
    data: List[float],
    # ... 其他参数
) -> MethodResult:
    """
    方法的核心实现
    
    Args:
        data: 输入数据说明
        
    Returns:
        MethodResult: 分析结果
        
    Raises:
        ValueError: 输入验证失败时抛出
    """
    # 1. 输入验证
    if not data:
        raise ValueError("数据不能为空")
    
    # 2. 数据预处理
    # 使用numpy进行数据转换
    
    # 3. 调用成熟统计库执行计算
    # 基于statsmodels、scipy、sklearn等
    
    # 4. 提取并返回结果
    return MethodResult(
        coefficients=...,
        std_errors=...,
        # ...
    )
```

**关键原则**：
- ✅ 使用Pydantic定义结果模型
- ✅ 完整的类型注解
- ✅ 详细的文档字符串
- ✅ 输入验证和错误处理
- ✅ 基于成熟的Python统计库
- ❌ 不要重复造轮子

### 2. 适配器层开发规范

**参考模板**: `tools/econometrics_adapter.py`

#### 核心要点：
```python
"""
方法适配器
将核心算法适配为MCP工具
"""
from typing import List, Optional
from .data_loader import DataLoader
from .output_formatter import OutputFormatter
from econometrics.category.method.method_model import (
    method_analysis as core_method,
    MethodResult as CoreMethodResult
)

def method_adapter(
    # 输入参数（支持直接数据和文件路径）
    data: Optional[List[float]] = None,
    file_path: Optional[str] = None,
    # ... 其他参数
    output_format: str = "json",
    save_path: Optional[str] = None
) -> str:
    """
    方法适配器
    
    功能：
    1. 数据加载（文件或直接数据）
    2. 调用核心算法
    3. 格式化输出
    """
    # 1. 数据准备
    if file_path:
        data_dict = DataLoader.load_from_file(file_path)
        data = data_dict["data"]
    elif data is None:
        raise ValueError("必须提供file_path或data")
    
    # 2. 调用核心算法（复用！）
    result: CoreMethodResult = core_method(data=data, ...)
    
    # 3. 格式化输出
    if output_format == "json":
        json_result = json.dumps(result.dict(), ensure_ascii=False, indent=2)
        if save_path:
            OutputFormatter.save_to_file(json_result, save_path)
            return f"分析完成！结果已保存到: {save_path}\n\n{json_result}"
        return json_result
    else:
        # 其他格式处理
        formatted = OutputFormatter.format_result(result, output_format)
        if save_path:
            OutputFormatter.save_to_file(formatted, save_path)
        return formatted
```

**关键原则**：
- ✅ 支持文件输入和直接数据输入
- ✅ 使用DataLoader统一数据加载
- ✅ 使用OutputFormatter统一输出格式化
- ✅ 统一的错误处理机制

### 3. MCP工具注册规范

**参考模板**: `tools/mcp_tool_groups/basic_parametric_tools.py`

#### 核心要点：
```python
"""
方法类别工具组
"""
from typing import List, Dict, Any, Optional
from mcp.server.fastmcp import Context
from mcp.server.session import ServerSession
from ..mcp_tools_registry import ToolGroup
from ..category_adapter import method_adapter

class CategoryTools(ToolGroup):
    """类别工具组"""
    
    name = "CATEGORY NAME"
    description = "类别描述"
    version = "1.0.0"
    
    @classmethod
    def get_tools(cls) -> List[Dict[str, Any]]:
        """返回工具列表"""
        return [
            {
                "name": "category_method_name",
                "handler": cls.method_tool,
                "description": "Method Description"
            },
            # 更多工具...
        ]
    
    @staticmethod
    async def method_tool(
        # 参数定义（与适配器一致）
        data: Optional[List[float]] = None,
        file_path: Optional[str] = None,
        output_format: str = "json",
        save_path: Optional[str] = None,
        ctx: Context[ServerSession, None] = None
    ) -> str:
        """方法工具（异步函数）"""
        try:
            if ctx:
                await ctx.info("Starting method analysis...")
            
            # 调用适配器
            result = method_adapter(
                data=data,
                file_path=file_path,
                output_format=output_format,
                save_path=save_path
            )
            
            if ctx:
                await ctx.info("Method analysis complete")
            
            return result
        except Exception as e:
            if ctx:
                await ctx.error(f"Error: {str(e)}")
            raise
```

**关键原则**：
- ✅ 继承ToolGroup基类
- ✅ 实现get_tools()类方法
- ✅ 每个工具都是async函数
- ✅ 使用Context进行日志记录
- ✅ 统一的异常处理

### 4. 输入输出格式规范

**参考文档**: `resources/MCP_TOOLS_DATA_FORMAT_GUIDE.md`

#### 输入格式要求：

1. **直接数据输入**:
   - 一维数据: `List[float]`
   - 二维数据: `List[List[float]]`
   - 标识符: `List[str]` 或 `List[int]`

2. **文件输入**:
   - 支持格式: txt, json, csv, excel
   - 使用DataLoader统一加载

3. **数据验证**:
   - 非空检查
   - 维度一致性检查
   - 数据类型验证

#### 输出格式要求：

1. **JSON格式** (默认):
```json
{
  "coefficients": [1.0, 2.0],
  "std_errors": [0.1, 0.2],
  "statistics": {...}
}
```

2. **Markdown格式**:
```markdown
# 分析结果

## 系数估计
- 系数1: 1.0 (标准误: 0.1)
- 系数2: 2.0 (标准误: 0.2)
```

3. **文本格式**:
```
分析结果
=========
系数估计: [1.0, 2.0]
标准误: [0.1, 0.2]
```

## 模块化开发架构设计

### 文件结构设计原则
```
econometrics/
├── spatial_econometrics/           # 空间计量经济学
│   ├── spatial_weights.py          # 空间权重矩阵（单一方法）
│   ├── spatial_autocorrelation.py  # 空间自相关检验（单一方法）
│   ├── spatial_regression.py       # 空间回归模型（单一方法）
│   └── __init__.py
├── nonparametric_methods/          # 非参数方法
│   ├── kernel_regression.py        # 核回归（单一方法）
│   ├── local_regression.py         # 局部回归（单一方法）
│   ├── spline_regression.py        # 样条回归（单一方法）
│   ├── gam_model.py                # 广义可加模型（单一方法）
│   └── __init__.py
├── distribution_analysis/          # 分布分析
│   ├── quantile_regression.py      # 分位数回归（单一方法）
│   ├── decomposition_methods.py    # 分解方法（单一方法）
│   ├── variance_decomposition.py   # 方差分解（单一方法）
│   └── __init__.py
└── ... (其他类别类似结构)
```

### 每个方法独立脚本的优势
1. **易于维护**: 每个方法独立，修改不影响其他功能
2. **便于测试**: 可以为每个方法编写独立的单元测试
3. **灵活组合**: 用户可以根据需要选择特定方法
4. **错误隔离**: 单个方法出错不会影响整个系统
5. **版本控制**: 可以独立更新和发布单个方法

## 建议开发计划

### 第一阶段 (1-2个月)
- 开发空间计量经济学工具组 (5-7个工具)
  - 基于 `libpysal` 和 `spreg` 库
  - 每个空间模型独立脚本
- 开发非参数与半参数方法工具组 (5-6个工具)
  - 基于 `statsmodels.nonparametric` 和 `pygam`
  - 每个非参数方法独立脚本

### 第二阶段 (2-3个月)
- 开发分布分析与分解方法工具组 (4-5个工具)
  - 基于 `statsmodels` 和 `linearmodels`
  - 每个分解方法独立脚本
- 开发统计推断技术工具组 (5-6个工具)
  - 基于 `scipy.stats` 和 `resample`
  - 每个推断方法独立脚本

### 第三阶段 (3-4个月)
- 开发缺失数据与测量误差工具组 (4-5个工具)
  - 基于 `sklearn.impute` 和 `fancyimpute`
  - 每个插补方法独立脚本
- 开发生存/持续时间数据工具组 (3-4个工具)
  - 基于 `lifelines` 库
  - 每个生存模型独立脚本

## 预期工具总数

完成所有类别开发后，预计新增 **26-33个工具**，使总工具数达到 **75-82个**，形成完整的计量经济学分析工具集。

## 技术实现原则

### 1. 基于现有Python统计库
- **不重复造轮子**: 充分利用成熟的统计库
- **标准化接口**: 统一输入输出格式
- **性能优化**: 利用底层库的优化实现

### 2. 模块化设计
- **单一职责**: 每个脚本只实现一个核心方法
- **独立测试**: 每个方法都有完整的单元测试
- **清晰依赖**: 明确的方法依赖关系

### 3. 向后兼容
- **接口稳定**: 保持现有MCP工具接口不变
- **数据格式**: 统一使用现有数据格式标准
- **错误处理**: 统一的错误处理机制

### 4. 文档完善
- **使用示例**: 每个方法提供完整的使用示例
- **参数说明**: 详细的参数文档
- **输出格式**: 明确的输出格式说明

---
**分析时间**: 2025-11-06  
**分析依据**: 项目结构分析、测试报告、README文档  
**当前工具总数**: 49个  
**预计新增工具**: 26-33个  
**最终工具总数**: 75-82个  
**开发原则**: 基于现有Python统计库 + 模块化独立脚本设计 + 严格遵循三层架构规范