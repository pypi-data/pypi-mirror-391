"""
------------------------------------------------------------------------------
<auto-generated>
    This code was auto-generated by main/tools/jsonparser.
    Do not change this file.
</auto-generated>
------------------------------------------------------------------------------
"""
import json
import sys
import re
from six import string_types
from .ClusterPortMapping import ClusterPortMapping
from .DataInput import DataInput
from .ClusterComponentParams import ClusterComponentParams
from .Env import Env
from .SecretSpec import SecretSpec

# Unused import over optimization prevention
str(repr(ClusterComponentParams))
str(repr(SecretSpec))
str(repr(Env))
str(repr(ClusterPortMapping))
str(repr(DataInput))


if sys.version_info > (3,):
    long = int
    unicode = str

class ClusterParams(object):
    """Cluster params"""
    def __init__(self, propDict=None):
        fromDict = propDict is not None and isinstance(propDict, dict)
        self.ace = (
            None if not fromDict or propDict.get(
                "ace"
            ) is None
            else propDict["ace"])
        self.additionalOpenPorts = (
            None if not fromDict or propDict.get(
                "additionalOpenPorts"
            ) is None
            else propDict["additionalOpenPorts"])
        self.additionalPortMappings = (
            None if not fromDict or propDict.get(
                "additionalPortMappings"
            ) is None
            else [ ClusterPortMapping(i)
            for i in propDict["additionalPortMappings"] ])
        self.clusterLifetime = (
            None if not fromDict or propDict.get(
                "clusterLifetime"
            ) is None
            else propDict["clusterLifetime"])
        self.condaPackages = (
            None if not fromDict or propDict.get(
                "condaPackages"
            ) is None
            else propDict["condaPackages"])
        self.containerImage = (
            None if not fromDict or propDict.get(
                "containerImage"
            ) is None
            else propDict["containerImage"])
        self.dataInput = (
            None if not fromDict or propDict.get(
                "dataInput"
            ) is None
            else propDict["dataInput"])
        self.dataOutputMountPoint = (
            None if not fromDict or propDict.get(
                "dataOutputMountPoint"
            ) is None
            else propDict["dataOutputMountPoint"])
        self.expiryDuration = (
            None if not fromDict or propDict.get(
                "expiryDuration"
            ) is None
            else propDict["expiryDuration"])
        self.isLabelLocked = (
            None if not fromDict or propDict.get(
                "isLabelLocked"
            ) is None
            else propDict["isLabelLocked"])
        self.isMultiNode = (
            None if not fromDict or propDict.get(
                "isMultiNode"
            ) is None
            else propDict["isMultiNode"])
        self.jobOrder = (
            None if not fromDict or propDict.get(
                "jobOrder"
            ) is None
            else propDict["jobOrder"])
        self.jobPriority = (
            None if not fromDict or propDict.get(
                "jobPriority"
            ) is None
            else propDict["jobPriority"])
        self.labels = (
            None if not fromDict or propDict.get(
                "labels"
            ) is None
            else propDict["labels"])
        self.minAvailability = (
            None if not fromDict or propDict.get(
                "minAvailability"
            ) is None
            else propDict["minAvailability"])
        self.minTimesliceSeconds = (
            None if not fromDict or propDict.get(
                "minTimesliceSeconds"
            ) is None
            else propDict["minTimesliceSeconds"])
        self.name = (
            None if not fromDict or propDict.get(
                "name"
            ) is None
            else propDict["name"])
        self.nworkers = (
            None if not fromDict or propDict.get(
                "nworkers"
            ) is None
            else propDict["nworkers"])
        self.options = (
            None if not fromDict or propDict.get(
                "options"
            ) is None
            else [ Env(i)
            for i in propDict["options"] ])
        self.pipPackages = (
            None if not fromDict or propDict.get(
                "pipPackages"
            ) is None
            else propDict["pipPackages"])
        self.preemptClass = (
            None if not fromDict or propDict.get(
                "preemptClass"
            ) is None
            else propDict["preemptClass"])
        self.scheduler = (
            None if not fromDict or propDict.get(
                "scheduler"
            ) is None
            else propDict["scheduler"])
        self.schedulerPort = (
            None if not fromDict or propDict.get(
                "schedulerPort"
            ) is None
            else propDict["schedulerPort"])
        self.systemPackages = (
            None if not fromDict or propDict.get(
                "systemPackages"
            ) is None
            else propDict["systemPackages"])
        self.topologyConstraint = (
            None if not fromDict or propDict.get(
                "topologyConstraint"
            ) is None
            else propDict["topologyConstraint"])
        self.userSecretsSpec = (
            None if not fromDict or propDict.get(
                "userSecretsSpec"
            ) is None
            else [ SecretSpec(i)
            for i in propDict["userSecretsSpec"] ])
        self.worker = (
            None if not fromDict or propDict.get(
                "worker"
            ) is None
            else propDict["worker"])

    @property
    def ace(self):
        """str: ACE instance"""
        return self._ace

    @ace.setter
    def ace(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._ace = value
        else:
            raise TypeError(
                'Property "ace" of type "list<str>" set to wrong type'
            )

    @property
    def additionalOpenPorts(self):
        """list: (Deprecated) Additional Ports"""
        return self._additionalOpenPorts

    @additionalOpenPorts.setter
    def additionalOpenPorts(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._additionalOpenPorts = value
        else:
            raise TypeError(
                'Property "additionalOpenPorts" of type "list<int>" set to wr'
                'ong type'
            )

    @property
    def additionalPortMappings(self):
        """list: Additional port mappings used for the cluster"""
        return self._additionalPortMappings

    @additionalPortMappings.setter
    def additionalPortMappings(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._additionalPortMappings = value
        else:
            raise TypeError(
                'Property "additionalPortMappings" of type "list<ClusterPortM'
                'apping>" set to wrong type'
            )

    @property
    def clusterLifetime(self):
        """str: Cluster lifetime"""
        return self._clusterLifetime

    @clusterLifetime.setter
    def clusterLifetime(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._clusterLifetime = value
        else:
            raise TypeError(
                'Property "clusterLifetime" of type "list<str>" set to wrong '
                'type'
            )

    @property
    def condaPackages(self):
        """list: List of custom packages to install in the container image via
         conda install command"""
        return self._condaPackages

    @condaPackages.setter
    def condaPackages(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._condaPackages = value
        else:
            raise TypeError(
                'Property "condaPackages" of type "list<str>" set to wrong ty'
                'pe'
            )

    @property
    def containerImage(self):
        """str: Container image"""
        return self._containerImage

    @containerImage.setter
    def containerImage(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._containerImage = value
        else:
            raise TypeError(
                'Property "containerImage" of type "list<str>" set to wrong t'
                'ype'
            )

    @property
    def dataInput(self):
        """DataInput: Data Input"""
        return self._dataInput

    @dataInput.setter
    def dataInput(self, value):
        if value is not None and not isinstance(value, DataInput):
            value = DataInput(value)
        if (value is None) or isinstance(value, DataInput):
            self._dataInput = value
        else:
            raise TypeError(
                'Property "dataInput" of type "list<DataInput>" set to wrong '
                'type'
            )

    @property
    def dataOutputMountPoint(self):
        """str: Data output results mount point"""
        return self._dataOutputMountPoint

    @dataOutputMountPoint.setter
    def dataOutputMountPoint(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._dataOutputMountPoint = value
        else:
            raise TypeError(
                'Property "dataOutputMountPoint" of type "list<str>" set to w'
                'rong type'
            )

    @property
    def expiryDuration(self):
        """str: Maximum duration from submission time during which the job wil
        l be allowed to run. If not specified, or is 0, then ACE limit
         will be applied."""
        return self._expiryDuration

    @expiryDuration.setter
    def expiryDuration(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._expiryDuration = value
        else:
            raise TypeError(
                'Property "expiryDuration" of type "list<str>" set to wrong t'
                'ype'
            )

    @property
    def isLabelLocked(self):
        """bool: Indicates whether the labels will be locked or not, default a
        s false"""
        return self._isLabelLocked

    @isLabelLocked.setter
    def isLabelLocked(self, value):
        if value is not None and not isinstance(value, bool):
            value = bool(value)
        if (value is None) or isinstance(value, bool):
            self._isLabelLocked = value
        else:
            raise TypeError(
                'Property "isLabelLocked" of type "list<bool>" set to wrong t'
                'ype'
            )

    @property
    def isMultiNode(self):
        """bool: Indicates whether this is multi node cluster"""
        return self._isMultiNode

    @isMultiNode.setter
    def isMultiNode(self, value):
        if value is not None and not isinstance(value, bool):
            value = bool(value)
        if (value is None) or isinstance(value, bool):
            self._isMultiNode = value
        else:
            raise TypeError(
                'Property "isMultiNode" of type "list<bool>" set to wrong typ'
                'e'
            )

    @property
    def jobOrder(self):
        """int: The order of job. Job order is from 1 to 99. Default value is 
        50"""
        return self._jobOrder

    @jobOrder.setter
    def jobOrder(self, value):
        if value is not None and not isinstance(value, int):
            value = int(value)
        if (value is None) or isinstance(value, int):
            self._jobOrder = value
        else:
            raise TypeError(
                'Property "jobOrder" of type "list<int>" set to wrong type'
            )

    @property
    def jobPriority(self):
        """str: The priority of job. Default value is NORMAL"""
        return self._jobPriority

    @jobPriority.setter
    def jobPriority(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._jobPriority = value
        else:
            raise TypeError(
                'Property "jobPriority" of type "list<str>" set to wrong type'
            )

    @property
    def labels(self):
        """list: An array of user/reserved/system labels that describe this jo
        b"""
        return self._labels

    @labels.setter
    def labels(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._labels = value
        else:
            raise TypeError(
                'Property "labels" of type "list<str>" set to wrong type'
            )

    @property
    def minAvailability(self):
        """int: Option to indicate whether n tasks are needed to be scheduled 
        at the same time for array job."""
        return self._minAvailability

    @minAvailability.setter
    def minAvailability(self, value):
        if value is not None and not isinstance(value, int):
            value = int(value)
        if (value is None) or isinstance(value, int):
            self._minAvailability = value
        else:
            raise TypeError(
                'Property "minAvailability" of type "list<int>" set to wrong '
                'type'
            )

    @property
    def minTimesliceSeconds(self):
        """long: Minimum time in seconds job is expected (not guaranteed) to b
        e in the RUNNING state once scheduled to assure forward progre
        ss."""
        return self._minTimesliceSeconds

    @minTimesliceSeconds.setter
    def minTimesliceSeconds(self, value):
        if value is not None and not isinstance(value, long):
            value = long(value)
        if (value is None) or isinstance(value, long):
            self._minTimesliceSeconds = value
        else:
            raise TypeError(
                'Property "minTimesliceSeconds" of type "list<long>" set to w'
                'rong type'
            )

    @property
    def name(self):
        """str: Cluster name"""
        return self._name

    @name.setter
    def name(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._name = value
        else:
            raise TypeError(
                'Property "name" of type "list<str>" set to wrong type'
            )

    @property
    def nworkers(self):
        """int: Number of workers"""
        return self._nworkers

    @nworkers.setter
    def nworkers(self, value):
        if value is not None and not isinstance(value, int):
            value = int(value)
        if (value is None) or isinstance(value, int):
            self._nworkers = value
        else:
            raise TypeError(
                'Property "nworkers" of type "list<int>" set to wrong type'
            )

    @property
    def options(self):
        """list: List of env variable format options"""
        return self._options

    @options.setter
    def options(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._options = value
        else:
            raise TypeError(
                'Property "options" of type "list<Env>" set to wrong type'
            )

    @property
    def pipPackages(self):
        """list: List of custom packages to install in the container image via
         pip install command"""
        return self._pipPackages

    @pipPackages.setter
    def pipPackages(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._pipPackages = value
        else:
            raise TypeError(
                'Property "pipPackages" of type "list<str>" set to wrong type'
            )

    @property
    def preemptClass(self):
        """str: Describes the job class for preemption and scheduling behavior
        . One of RESUMABLE, RESTARTABLE, or RUNONCE (default)."""
        return self._preemptClass

    @preemptClass.setter
    def preemptClass(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._preemptClass = value
        else:
            raise TypeError(
                'Property "preemptClass" of type "list<str>" set to wrong typ'
                'e'
            )

    @property
    def scheduler(self):
        """ClusterComponentParams: Common parameters for scheduler and worker
        """
        return self._scheduler

    @scheduler.setter
    def scheduler(self, value):
        if value is not None and not isinstance(value, ClusterComponentParams):
            value = ClusterComponentParams(value)
        if (value is None) or isinstance(value, ClusterComponentParams):
            self._scheduler = value
        else:
            raise TypeError(
                'Property "scheduler" of type "list<ClusterComponentParams>" '
                'set to wrong type'
            )

    @property
    def schedulerPort(self):
        """int: Scheduler port"""
        return self._schedulerPort

    @schedulerPort.setter
    def schedulerPort(self, value):
        if value is not None and not isinstance(value, int):
            value = int(value)
        if (value is None) or isinstance(value, int):
            self._schedulerPort = value
        else:
            raise TypeError(
                'Property "schedulerPort" of type "list<int>" set to wrong ty'
                'pe'
            )

    @property
    def systemPackages(self):
        """list: List of custom packages to install in the container image via
         system package install command (apt or yum install command)"""
        return self._systemPackages

    @systemPackages.setter
    def systemPackages(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._systemPackages = value
        else:
            raise TypeError(
                'Property "systemPackages" of type "list<str>" set to wrong t'
                'ype'
            )

    @property
    def topologyConstraint(self):
        """str: Constraints to set the topology for the array job"""
        return self._topologyConstraint

    @topologyConstraint.setter
    def topologyConstraint(self, value):
        if value is not None and not isinstance(value, string_types):
            value = repr(value)
        if (value is None) or isinstance(value, string_types):
            self._topologyConstraint = value
        else:
            raise TypeError(
                'Property "topologyConstraint" of type "list<str>" set to wro'
                'ng type'
            )

    @property
    def userSecretsSpec(self):
        """list: Specification of list of user secrets to associate to the job
        """
        return self._userSecretsSpec

    @userSecretsSpec.setter
    def userSecretsSpec(self, value):
        if value is not None and not isinstance(value, list):
            value = list(value)
        if (value is None) or isinstance(value, list):
            self._userSecretsSpec = value
        else:
            raise TypeError(
                'Property "userSecretsSpec" of type "list<SecretSpec>" set to'
                ' wrong type'
            )

    @property
    def worker(self):
        """ClusterComponentParams: Common parameters for scheduler and worker
        """
        return self._worker

    @worker.setter
    def worker(self, value):
        if value is not None and not isinstance(value, ClusterComponentParams):
            value = ClusterComponentParams(value)
        if (value is None) or isinstance(value, ClusterComponentParams):
            self._worker = value
        else:
            raise TypeError(
                'Property "worker" of type "list<ClusterComponentParams>" set'
                ' to wrong type'
            )

    def toDict(self):
        result = {}
        if self._ace is not None:
            result["ace"] = \
                self._ace
        if self._additionalOpenPorts is not None:
            result["additionalOpenPorts"] = \
                self._additionalOpenPorts
        if self._additionalPortMappings:
            result["additionalPortMappings"] = [
                i.toDict() for i in self._additionalPortMappings 
            ] if self._additionalPortMappings else []
        if self._clusterLifetime is not None:
            result["clusterLifetime"] = \
                self._clusterLifetime
        if self._condaPackages is not None:
            result["condaPackages"] = \
                self._condaPackages
        if self._containerImage is not None:
            result["containerImage"] = \
                self._containerImage
        if self._dataInput:
            result["dataInput"] = \
                self._dataInput.toDict() if self._dataInput is not None else None
        if self._dataOutputMountPoint is not None:
            result["dataOutputMountPoint"] = \
                self._dataOutputMountPoint
        if self._expiryDuration is not None:
            result["expiryDuration"] = \
                self._expiryDuration
        if self._isLabelLocked is not None:
            result["isLabelLocked"] = \
                self._isLabelLocked
        if self._isMultiNode is not None:
            result["isMultiNode"] = \
                self._isMultiNode
        if self._jobOrder is not None:
            result["jobOrder"] = \
                self._jobOrder
        if self._jobPriority is not None:
            result["jobPriority"] = \
                self._jobPriority
        if self._labels is not None:
            result["labels"] = \
                self._labels
        if self._minAvailability is not None:
            result["minAvailability"] = \
                self._minAvailability
        if self._minTimesliceSeconds is not None:
            result["minTimesliceSeconds"] = \
                self._minTimesliceSeconds
        if self._name is not None:
            result["name"] = \
                self._name
        if self._nworkers is not None:
            result["nworkers"] = \
                self._nworkers
        if self._options:
            result["options"] = [
                i.toDict() for i in self._options 
            ] if self._options else []
        if self._pipPackages is not None:
            result["pipPackages"] = \
                self._pipPackages
        if self._preemptClass is not None:
            result["preemptClass"] = \
                self._preemptClass
        if self._scheduler:
            result["scheduler"] = \
                self._scheduler.toDict() if self._scheduler is not None else None
        if self._schedulerPort is not None:
            result["schedulerPort"] = \
                self._schedulerPort
        if self._systemPackages is not None:
            result["systemPackages"] = \
                self._systemPackages
        if self._topologyConstraint is not None:
            result["topologyConstraint"] = \
                self._topologyConstraint
        if self._userSecretsSpec:
            result["userSecretsSpec"] = [
                i.toDict() for i in self._userSecretsSpec 
            ] if self._userSecretsSpec else []
        if self._worker:
            result["worker"] = \
                self._worker.toDict() if self._worker is not None else None
        return result

    def toJSON(self, pretty=False):
        if pretty:
            return json.dumps(self.toDict(), sort_keys=True, indent=4)
        else:
            return json.dumps(self.toDict(), sort_keys=True)

    def isValid(self):
        if self._ace is None:
            raise ValueError(
                "ClusterParams.ace doesnt match requirement:" 
                "required: True"
            )
        if (self._ace is not None
            and
            len(self._ace) < 1):
            raise ValueError(
                "ClusterParams.ace: " + str(self._ace) + 
                " doesnt match requirement: minLength: 1")
        if (self._schedulerPort is not None
            and
            self._schedulerPort < 1):
            raise ValueError(
                "ClusterParams.schedulerPort: " + str(self._schedulerPort) + 
                " doesnt match requirement: minimum: 1")
        if (self._schedulerPort is not None
            and
            self._schedulerPort > 65535):
            raise ValueError(
                "ClusterParams.schedulerPort: " + str(self._schedulerPort) + 
                " doesnt match requirement: maximum: 65535")
        if self._scheduler is None:
            raise ValueError(
                "ClusterParams.scheduler doesnt match requirement:" 
                "required: True"
            )
        if self._nworkers is None:
            raise ValueError(
                "ClusterParams.nworkers doesnt match requirement:" 
                "required: True"
            )
        if (self._nworkers is not None
            and
            self._nworkers < 1):
            raise ValueError(
                "ClusterParams.nworkers: " + str(self._nworkers) + 
                " doesnt match requirement: minimum: 1")
        if self._containerImage is None:
            raise ValueError(
                "ClusterParams.containerImage doesnt match requirement:" 
                "required: True"
            )
        if (self._containerImage is not None
            and
            len(self._containerImage) < 1):
            raise ValueError(
                "ClusterParams.containerImage: " + str(self._containerImage) + 
                " doesnt match requirement: minLength: 1")
        if (self._containerImage is not None
            and
            not re.match(
                r"[\x20-\x7E]*",
                 self._containerImage)):
            raise ValueError(
                "ClusterParams.containerImage: " + str(self._containerImage) + 
                " doesnt match requirement: pattern: [\x20-\x7E]*")
        if self._dataOutputMountPoint is None:
            raise ValueError(
                "ClusterParams.dataOutputMountPoint doesnt match requirement:" 
                "required: True"
            )
        if (self._dataOutputMountPoint is not None
            and
            len(self._dataOutputMountPoint) < 1):
            raise ValueError(
                "ClusterParams.dataOutputMountPoint: " + str(self._dataOutputMountPoint) + 
                " doesnt match requirement: minLength: 1")
        if self._clusterLifetime is None:
            raise ValueError(
                "ClusterParams.clusterLifetime doesnt match requirement:" 
                "required: True"
            )
        if (self._clusterLifetime is not None
            and
            not re.match(
                r"[0-9]+[DdHhMmSs]",
                 self._clusterLifetime)):
            raise ValueError(
                "ClusterParams.clusterLifetime: " + str(self._clusterLifetime) + 
                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
        if (self._expiryDuration is not None
            and
            not re.match(
                r"[0-9]+[DdHhMmSs]",
                 self._expiryDuration)):
            raise ValueError(
                "ClusterParams.expiryDuration: " + str(self._expiryDuration) + 
                " doesnt match requirement: pattern: [0-9]+[DdHhMmSs]")
        if (self._minTimesliceSeconds is not None
            and
            self._minTimesliceSeconds < 0):
            raise ValueError(
                "ClusterParams.minTimesliceSeconds: " + str(self._minTimesliceSeconds) + 
                " doesnt match requirement: minimum: 0")
        if (self._preemptClass is not None
            and
            len(self._preemptClass) < 1):
            raise ValueError(
                "ClusterParams.preemptClass: " + str(self._preemptClass) + 
                " doesnt match requirement: minLength: 1")
        if (self._jobOrder is not None
            and
            self._jobOrder < 1):
            raise ValueError(
                "ClusterParams.jobOrder: " + str(self._jobOrder) + 
                " doesnt match requirement: minimum: 1")
        if (self._jobOrder is not None
            and
            self._jobOrder > 99):
            raise ValueError(
                "ClusterParams.jobOrder: " + str(self._jobOrder) + 
                " doesnt match requirement: maximum: 99")
        if (self._jobPriority is not None
            and
            len(self._jobPriority) < 1):
            raise ValueError(
                "ClusterParams.jobPriority: " + str(self._jobPriority) + 
                " doesnt match requirement: minLength: 1")
        if (self._topologyConstraint is not None
            and
            len(self._topologyConstraint) < 1):
            raise ValueError(
                "ClusterParams.topologyConstraint: " + str(self._topologyConstraint) + 
                " doesnt match requirement: minLength: 1")
        if (self._scheduler is not None): self._scheduler.isValid()
        if (self._worker is not None): self._worker.isValid()
        if (self._additionalPortMappings is not None):
            for obj in self._additionalPortMappings:
                if (obj is not None): obj.isValid()
        if (self._dataInput is not None): self._dataInput.isValid()
        if (self._userSecretsSpec is not None):
            for obj in self._userSecretsSpec:
                if (obj is not None): obj.isValid()
        if (self._options is not None):
            for obj in self._options:
                if (obj is not None): obj.isValid()
        return True
    

