"""Scaffolding engine for generating project structure from stack configuration."""

import os
from pathlib import Path
from typing import Optional

from getupandrun.gpt.integration import StackConfig
from getupandrun.scaffold.generators import (
    ComposeGenerator,
    DockerfileGenerator,
    ServiceFileGenerator,
)
from getupandrun.scaffold.installers import DependencyInstaller
from getupandrun.utils.logger import (
    print_error,
    print_info,
    print_success,
)


class ScaffoldingEngine:
    """Engine for scaffolding project structure from stack configuration."""

    def __init__(self, project_name: Optional[str] = None) -> None:
        """
        Initialize scaffolding engine.

        Args:
            project_name: Optional custom project name. If None, uses config name.
        """
        self.project_name = project_name

    def scaffold(self, config: StackConfig, output_dir: Optional[str] = None) -> str:
        """
        Scaffold project structure from stack configuration.

        Args:
            config: StackConfig object from GPT
            output_dir: Output directory (defaults to current directory)

        Returns:
            Path to generated project directory
        """
        project_name = self.project_name or config.name
        project_path = Path(output_dir or ".") / project_name

        print_info(f"Scaffolding project: {project_name}")
        print_info(f"Output directory: {project_path.absolute()}")

        project_path.mkdir(exist_ok=True)

        try:
            self._generate_services(project_path, config, project_name)
            self._generate_docker_compose(project_path, config, project_name)
            self._generate_env_file(project_path, config)
            self._generate_makefile(project_path, project_name)
            self._generate_readme(project_path, config, project_name)
            self._generate_kubernetes(project_path, config, project_name)

            # Install dependencies (optional, can skip if tools not available)
            self._install_dependencies(project_path, config)

            print_success(f"Project scaffolded successfully at: {project_path.absolute()}")
            return str(project_path.absolute())

        except Exception as e:
            print_error(f"Error during scaffolding: {e}")
            raise

    def _generate_services(
        self, project_path: Path, config: StackConfig, project_name: str
    ) -> None:
        """Generate service directories and files."""
        for service in config.services:
            service_name = service.get("name", "service")
            service_type = service.get("type", "other")
            framework = service.get("framework", "")

            service_dir = project_path / service_name
            service_dir.mkdir(exist_ok=True)

            print_info(f"  Creating service: {service_name} ({service_type})")

            if service.get("dockerfile", True):
                dockerfile_content = DockerfileGenerator.generate(
                    service, framework, service_type
                )
                dockerfile_path = service_dir / "Dockerfile"
                dockerfile_path.write_text(dockerfile_content)
                print_info(f"    Created: {dockerfile_path.name}")

            if service_type == "frontend":
                ServiceFileGenerator.generate_frontend(service_dir, service, framework)
            elif service_type == "backend":
                ServiceFileGenerator.generate_backend(service_dir, service, framework, config)
            elif service_type == "database":
                # Skip SQLite as separate service - it's embedded in backend
                framework_lower = service.get("framework", "").lower()
                if "sqlite" not in framework_lower:
                    ServiceFileGenerator.generate_database(service_dir, service, framework)

    def _generate_docker_compose(
        self, project_path: Path, config: StackConfig, project_name: str
    ) -> None:
        """Generate docker-compose.yml file."""
        compose_content = ComposeGenerator.generate(project_path, config, project_name)
        compose_path = project_path / "docker-compose.yml"
        compose_path.write_text(compose_content)
        print_info(f"  Created: {compose_path.name}")

    def _generate_env_file(self, project_path: Path, config: StackConfig) -> None:
        """Generate .env file."""
        env_content = "# Environment variables\n"
        env_content += "# Generated by GetUpAndRun\n\n"

        for service in config.services:
            if service.get("type", "").lower() == "database":
                env_content += "POSTGRES_DB=app\n"
                env_content += "POSTGRES_USER=user\n"
                env_content += "POSTGRES_PASSWORD=password\n"
            elif service.get("type", "").lower() == "cache":
                env_content += "REDIS_PASSWORD=\n"

        env_path = project_path / ".env"
        env_path.write_text(env_content)
        print_info(f"  Created: {env_path.name}")

    def _generate_makefile(self, project_path: Path, project_name: str) -> None:
        """Generate Makefile."""
        makefile_content = f"""# Makefile for {project_name}
# Generated by GetUpAndRun

.PHONY: up down clean restart logs k8s-up k8s-down

up:
\tdocker-compose up -d

down:
\tdocker-compose down

clean:
\tdocker-compose down -v
\tdocker system prune -f

restart:
\tdocker-compose restart

logs:
\tdocker-compose logs -f

build:
\tdocker-compose build

ps:
\tdocker-compose ps

# Kubernetes commands
k8s-up:
\t@./deploy-k8s.sh

k8s-down:
\t@./teardown-k8s.sh
"""
        makefile_path = project_path / "Makefile"
        makefile_path.write_text(makefile_content)
        print_info(f"  Created: {makefile_path.name}")

    def _generate_readme(
        self, project_path: Path, config: StackConfig, project_name: str
    ) -> None:
        """Generate README.md file."""
        readme_content = f"""# {project_name}

{config.description or "Project generated by GetUpAndRun"}

## Services

"""
        for service in config.services:
            service_name = service.get("name", "service")
            service_type = service.get("type", "other")
            framework = service.get("framework", "")
            readme_content += f"- **{service_name}**: {service_type} ({framework})\n"

        readme_content += f"""
## Getting Started

### Prerequisites

- Docker
- Docker Compose

### Running the Project

#### Docker Compose (Local Development)

```bash
# Start all services
make up

# View logs
make logs

# Stop all services
make down

# Clean up (removes volumes)
make clean
```

#### Kubernetes Deployment

```bash
# Deploy to Kubernetes
make k8s-up

# Or use the script directly
./deploy-k8s.sh

# Tear down Kubernetes deployment
make k8s-down

# Or use the script directly
./teardown-k8s.sh

# Check status
kubectl get all -n {project_name}

# View logs
kubectl logs -n {project_name} deployment/<service-name>
```

**Note:** Before deploying to Kubernetes, make sure:
- kubectl is installed and configured
- You have access to a Kubernetes cluster
- Docker images are built and available (either locally or in a registry)

### Individual Service Commands

"""
        for service in config.services:
            service_name = service.get("name", "service")
            readme_content += f"#### {service_name}\n\n"
            readme_content += f"```bash\ncd {service_name}\n# Add service-specific commands here\n```\n\n"

        readme_path = project_path / "README.md"
        readme_path.write_text(readme_content)
        print_info(f"  Created: {readme_path.name}")

    def _generate_kubernetes(
        self, project_path: Path, config: StackConfig, project_name: str
    ) -> None:
        """Generate Kubernetes manifests and deployment scripts."""
        from getupandrun.kubernetes.generator import KubernetesGenerator
        from getupandrun.kubernetes.scripts import KubernetesScripts

        print_info("\nGenerating Kubernetes manifests...")
        KubernetesGenerator.generate(project_path, config, project_name)
        print_info("  Created: k8s/ directory with Kubernetes manifests")

        print_info("Generating Kubernetes deployment scripts...")
        KubernetesScripts.generate_deploy_script(project_path, project_name)
        print_info("  Created: deploy-k8s.sh")
        KubernetesScripts.generate_teardown_script(project_path, project_name)
        print_info("  Created: teardown-k8s.sh")

    def _install_dependencies(self, project_path: Path, config: StackConfig) -> None:
        """Install dependencies for all services."""
        print_info("\nInstalling dependencies...")
        for service in config.services:
            service_dir = project_path / service.get("name", "service")
            if service_dir.exists():
                DependencyInstaller.install_dependencies(service_dir, service)
