"""Generate kubectl deployment scripts."""

from pathlib import Path


class KubernetesScripts:
    """Generate kubectl deployment and teardown scripts."""

    @staticmethod
    def generate_deploy_script(project_path: Path, project_name: str) -> None:
        """
        Generate kubectl deployment script.

        Args:
            project_path: Project root directory
            project_name: Project name
        """
        script_content = f"""#!/bin/bash
# Kubernetes deployment script for {project_name}
# Generated by GetUpAndRun

set -e

NAMESPACE="{project_name}"
K8S_DIR="k8s"

echo "ğŸš€ Deploying {project_name} to Kubernetes..."

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo "âŒ Error: kubectl is not installed or not in PATH"
    echo "Install kubectl from: https://kubernetes.io/docs/tasks/tools/"
    exit 1
fi

# Check if we can connect to cluster
if ! kubectl cluster-info &> /dev/null; then
    echo "âŒ Error: Cannot connect to Kubernetes cluster"
    echo "Make sure kubectl is configured correctly: kubectl config get-contexts"
    exit 1
fi

# Create namespace
echo "ğŸ“¦ Creating namespace..."
kubectl apply -f $K8S_DIR/namespace.yaml

# Build and push images (if using local registry)
# Uncomment and modify if using a container registry:
# echo "ğŸ—ï¸  Building Docker images..."
# docker build -t {project_name}-frontend:latest ./frontend
# docker build -t {project_name}-backend:latest ./backend
# docker push <registry>/{project_name}-frontend:latest
# docker push <registry>/{project_name}-backend:latest

# Apply PersistentVolumeClaims first (for databases)
echo "ğŸ’¾ Creating persistent volumes..."
for pvc in $K8S_DIR/*-pvc.yaml; do
    if [ -f "$pvc" ]; then
        kubectl apply -f "$pvc"
    fi
done

# Apply ConfigMaps
echo "âš™ï¸  Creating config maps..."
for cm in $K8S_DIR/*-configmap.yaml; do
    if [ -f "$cm" ]; then
        kubectl apply -f "$cm"
    fi
done

# Apply Deployments
echo "ğŸš€ Creating deployments..."
for dep in $K8S_DIR/*-deployment.yaml; do
    if [ -f "$dep" ]; then
        kubectl apply -f "$dep"
    fi
done

# Apply Services
echo "ğŸŒ Creating services..."
for svc in $K8S_DIR/*-service.yaml; do
    if [ -f "$svc" ]; then
        kubectl apply -f "$svc"
    fi
done

# Wait for deployments to be ready
echo "â³ Waiting for deployments to be ready..."
kubectl wait --for=condition=available --timeout=300s deployment -n $NAMESPACE --all || true

echo "âœ… Deployment complete!"
echo ""
echo "ğŸ“Š Check status with:"
echo "  kubectl get all -n $NAMESPACE"
echo ""
echo "ğŸ“ View logs with:"
echo "  kubectl logs -n $NAMESPACE deployment/<service-name>"
echo ""
echo "ğŸ” Get service URLs with:"
echo "  kubectl get svc -n $NAMESPACE"
"""
        script_path = project_path / "deploy-k8s.sh"
        script_path.write_text(script_content)
        script_path.chmod(0o755)  # Make executable

    @staticmethod
    def generate_teardown_script(project_path: Path, project_name: str) -> None:
        """
        Generate kubectl teardown script.

        Args:
            project_path: Project root directory
            project_name: Project name
        """
        script_content = f"""#!/bin/bash
# Kubernetes teardown script for {project_name}
# Generated by GetUpAndRun

set -e

NAMESPACE="{project_name}"
K8S_DIR="k8s"

echo "ğŸ—‘ï¸  Tearing down {project_name} from Kubernetes..."

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo "âŒ Error: kubectl is not installed or not in PATH"
    exit 1
fi

# Delete namespace (this will delete all resources in the namespace)
echo "ğŸ—‘ï¸  Deleting namespace and all resources..."
kubectl delete namespace $NAMESPACE --ignore-not-found=true

echo "âœ… Teardown complete!"
"""
        script_path = project_path / "teardown-k8s.sh"
        script_path.write_text(script_content)
        script_path.chmod(0o755)  # Make executable

